[{"title":"ClientNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientNetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ClientNetWire.ClassName: &quot;ClientNetWire&quot;  "},{"title":"Functions​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#new","content":"constructor static &lt;/&gt; ClientNetWire.new(nameSpace: string) → ClientNetWire Creates a new ClientNetWire. If a ClientNetWire with the same nameSpace already exists, it will be returned instead. "},{"title":"BaseObject","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseObject","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#types","content":" "},{"title":"BaseObject​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BaseObject","content":"&lt;/&gt; type BaseObject = BaseObject  "},{"title":"Properties​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; BaseObject.ClassName: string  "},{"title":"Functions​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#functions","content":" "},{"title":"getObjectFromId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#getObjectFromId","content":"static &lt;/&gt; BaseObject.getObjectFromId(id: number) → BaseObject? Fetches the object with the given ID if it exists. local obj = BaseObject.new() local id = obj:GetId() print(BaseObject.getObjectFromId(id) == obj) -- true   "},{"title":"isDestroyed​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#isDestroyed","content":"static &lt;/&gt; BaseObject.isDestroyed(self: BaseObject) → boolean Checks whether or not the object is destroyed. local obj = BaseObject.new() print(BaseObject.isDestroyed(obj)) -- false obj:Destroy() print(BaseObject.isDestroyed(obj)) -- true   "},{"title":"new​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#new","content":"static &lt;/&gt; BaseObject.new( tbl: {[any]: any}?-- Table to construct the BaseObject with ) → BaseObject Constructs a new BaseObject local obj = BaseObject.new({ X = 1, Y = 2, }) obj.Z = 3 print(obj.X, obj.Y, obj.Z) -- 1, 2, 3 local SuperClass = BaseObject local MyClass = setmetatable({}, SuperClass) MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() local self = setmetatable(SuperClass.new(), MyClass) -- Custom logic here return self end function MyClass:Destroy() -- Overwrite the BaseObject Destroy method SuperClass.Destroy(self) -- If you overwrite the BaseObject Destroy method you need to have this line to call the original. end function MyClass:Print() print(&quot;Hello, World!&quot;) end return MyClass   "},{"title":"Destroy​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#Destroy","content":"&lt;/&gt; BaseObject:Destroy() → () Marks the Object as Destroyed, fires the Destroyed Signal, cleans up the BaseObject, and sets the metatable to nil/a special locked MT. Overriding If you override this method, you need to make sure you callSuperClass.Destroy(self) to call the superclass methods. function MyCustomClass:Destroy() SuperClass.Destroy(self) -- calls the superclass method to clean up events, tasks, etc.. end   "},{"title":"GetId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetId","content":"&lt;/&gt; BaseObject:GetId() → number Returns the ID of the BaseObject Can be used to fetch the object with BaseObject.getObjectFromId(id)  "},{"title":"IsA​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#IsA","content":"&lt;/&gt; BaseObject:IsA(classOrClassName: {[any]: any} | string) → boolean Returns true if the given object is of a given class. Takes a class name or class object.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetTask","content":"&lt;/&gt; BaseObject:GetTask(taskId: any) → Task? Fetches the task with the given ID if it exists. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:AddTask(part, nil, &quot;Test&quot;) print(obj:GetTask(&quot;Test&quot;) == part) -- true   "},{"title":"AddTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddTask","content":"&lt;/&gt; BaseObject:AddTask( task: Task, taskCleanupMethod: (string | true | nil)?,-- (if none is given it will try to infer; Passing true tells it to call it as a function) taskId: any? ) → Task-- The task that was given Adds a task to the janitor. If a taskId is provided, it will be used as the key for the task in the janitor and can then be fetched later with :GetTask(). If an ID is provided and there already exists a task with that ID, it will clean up the existing task and then replace the index with the new one. It will return the task that was added/given. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end) obj:Destroy() -- Prints &quot;Hello, World!&quot;   "},{"title":"AddPromise​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddPromise","content":"&lt;/&gt; BaseObject:AddPromise(prom: Promise) → Promise Adds a promise to the janitor. Similar to :AddTask(). Returns the same Promise that was given to it. local prom = Promise.delay(math.random(10)) local obj = BaseObject.new() obj:AddPromise(prom) task.wait(math.random(10)) obj:Destroy() -- Cancels the promise if it hasn't resolved yet   "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTask","content":"&lt;/&gt; BaseObject:RemoveTask( taskId: any, dontClean: boolean? ) → () Removes a task from the janitor. Cleans the task as if :DoCleaning was called. If dontClean is true, it will not clean up the task, it will just remove it from the janitor. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTask(&quot;Test&quot;) -- Prints &quot;Hello, World!&quot;   "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTaskNoClean","content":"&lt;/&gt; BaseObject:RemoveTaskNoClean(taskId: any) → () Removes a task from the janitor without cleaning it. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTaskNoClean(&quot;Test&quot;) -- Does NOT print &quot;Hello, World!&quot;   "},{"title":"FireSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#FireSignal","content":"&lt;/&gt; BaseObject:FireSignal( signalName: string,-- The name of the signal to fire ...: any-- Arguments to pass to the signal ) → () Fires the signal with the given name, if it exists. Equivalent to calling :GetSignal(signalName):Fire(...) except this does not require the signal to exist first. local obj = BaseObject.new() local SignalName = &quot;Test&quot; obj:RegisterSignal(SignalName) obj:GetSignal(SignalName):Connect(print) obj:FireSignal(SignalName, &quot;Hello, World!&quot;) -- Fires the signal with the argument &quot;Hello, World!&quot;   "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RegisterSignal","content":"&lt;/&gt; BaseObject:RegisterSignal( signalName: string-- Name of signal to register ) → () Marks a signal with the given name as registered. Does not actually build a new signal, it sets the index to a SignalMarker to identify it as registered so that it can be fetched later.  "},{"title":"HasSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#HasSignal","content":"&lt;/&gt; BaseObject:HasSignal(signalName: string) → boolean Checks whether or not a signal with the given name is registered. local obj = BaseObject.new() local SignalName = &quot;Test&quot; print(obj:HasSignal(SignalName)) -- false obj:RegisterSignal(SignalName) print(obj:HasSignal(SignalName)) -- true   "},{"title":"GetSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetSignal","content":"&lt;/&gt; BaseObject:GetSignal(signalName: string) → Signal Fetches a signal with the given name. Creates the Signal JIT.  "},{"title":"GetDestroyedSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetDestroyedSignal","content":"&lt;/&gt; BaseObject:GetDestroyedSignal() → Signal Returns a signal that fires when the object is destroyed. Creates the signal JIT. Kept for backwards compatibility. local obj = BaseObject.new() obj:GetDestroyedSignal():Connect(function() print(&quot;Object Destroyed!&quot;) end) obj:Destroy() -- Prints &quot;Object Destroyed!&quot;   "},{"title":"BindToInstance​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BindToInstance","content":"&lt;/&gt; BaseObject:BindToInstance( obj: Instance , destroyOnNilParent: boolean?-- Whether or not to destroy the object when the parent is nil'd ) → function-- Disconnects the binding Binds the object to the given instance. When the object is destroyed, it will destroy the instance. When the instance is destroyed, it will destroy the object. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:BindToInstance(part) do -- setup prints on destroy obj:AddTask(function() print(&quot;Object Destroyed!&quot;) end) part.Destroying:Connect(function() print(&quot;Part Destroyed!&quot;) end) end local X = if math.random(1,2) == 1 then obj or part X:Destroy() -- Prints &quot;Object Destroyed!&quot; and &quot;Part Destroyed!&quot; (Destroying one will destroy the other)  "},{"title":"BaseComponent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseComponent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#functions","content":" "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RegisterSignal","content":"&lt;/&gt; BaseComponent:RegisterSignal( signalName: string-- The name of the signal to register. ) → Signal-- The signal that was registered. Registers a signal to the component.  "},{"title":"GetSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetSignal","content":"&lt;/&gt; BaseComponent:GetSignal( signalName: string-- The name of the signal to get. ) → Signal-- The signal that was retrieved. Gets a signal from the component.  "},{"title":"FireSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#FireSignal","content":"&lt;/&gt; BaseComponent:FireSignal( signalName: string,-- The name of the signal to fire. ...: any-- The arguments to pass to the signal. ) → () Fires a signal from the component.  "},{"title":"ObserveProperty​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#ObserveProperty","content":"&lt;/&gt; BaseComponent:ObserveProperty( propertyName: string,-- The name of the property to observe callback: ((newValue: any) → ())-- The function to call when the property changes ) → function-- A function to disconnect the observer Watches for when the property changes and calls the callback. Also calls the callback initially with the current value  "},{"title":"OutProperty​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#OutProperty","content":"&lt;/&gt; BaseComponent:OutProperty( propertyName: string-- The name of the property to fetch ) → Value&lt;any&gt;-- The synchronized fusion value of the property Fetches an property and turns into into a synchronized usable value  "},{"title":"PropertyChanged​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#PropertyChanged","content":"&lt;/&gt; BaseComponent:PropertyChanged( propertyName: string,-- The name of the property to observe fn: ((...any) → ())?,-- The function to call when the property changes connectOnce: boolean?-- If true, the function will only be called the first time the property changes ) → RBXScriptConnection | RBXScriptSignal -- A connection or signal Fetches the PropertyChanged signal for the property if no function is given. If a function is provided, it will connect the function to the property changed signal and return the connection  "},{"title":"AddPromise​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AddPromise","content":"&lt;/&gt; BaseComponent:AddPromise(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Adds a promise to the component's janitor. Returns the same promise that was given.  "},{"title":"AddTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AddTask","content":"&lt;/&gt; BaseComponent:AddTask( task: T, cleanupMethod: (string | true)?, index: any? ) → T-- The same task that was given Adds a task to the component's janitor.  "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RemoveTaskNoClean","content":"&lt;/&gt; BaseComponent:RemoveTaskNoClean( index: any-- The index of the task to remove. ) → () Removes a task from the component's janitor without cleaning it.  "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RemoveTask","content":"&lt;/&gt; BaseComponent:RemoveTask( index: any,-- The id of the task to remove. dontClean: boolean?-- Optional flag to not clean the task. ) → () Removes a task from the component's janitor.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetTask","content":"&lt;/&gt; BaseComponent:GetTask( index: any-- The id of the task to get. ) → any-- The task that was retrieved. Gets a task from the janitor.  "},{"title":"GetAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetAttribute","content":"&lt;/&gt; BaseComponent:GetAttribute( attributeName: string-- The name of the attribute to fetch ) → any?-- The current value of the attribute Fetches the current Value of an attribute on the Component Instance  "},{"title":"SetAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#SetAttribute","content":"&lt;/&gt; BaseComponent:SetAttribute( attributeName: string,-- The name of the attribute to set value: any-- The value to set the attribute to ) → () Sets an attribute of this Component's instance to a value  "},{"title":"IncrementAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#IncrementAttribute","content":"&lt;/&gt; BaseComponent:IncrementAttribute( attributeName: string,-- The name of the attribute to increment increment: number?-- The amount to increment the attribute by. Defaults to 1 ) → number-- The new value of the attribute Increments the current value of the attribute by the increment. If no increment is provided, it defaults to 1  "},{"title":"UpdateAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#UpdateAttribute","content":"&lt;/&gt; BaseComponent:UpdateAttribute( attributeName: string,-- The name of the attribute to mutate mutator: ((value: any) → (any))-- The function to mutate the attribute with ) → any-- The new value of the attribute Updates the current value of the attribute into a new value from the return of the mutator function  "},{"title":"ObserveAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#ObserveAttribute","content":"&lt;/&gt; BaseComponent:ObserveAttribute( attributeName: string,-- The name of the attribute to observe callback: ((newValue: any) → ())-- The function to call when the attribute changes ) → function-- A function to disconnect the observer Watches for when the attribute changes and calls the callback. Also calls the callback initially with the current value  "},{"title":"OutAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#OutAttribute","content":"&lt;/&gt; BaseComponent:OutAttribute( attributeName: string-- The name of the attribute to fetch ) → Value&lt;any&gt;-- The synchronized fusion value of the attribute Fetches an attribute and turns into into a synchronized usable value  "},{"title":"DefaultAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#DefaultAttribute","content":"&lt;/&gt; BaseComponent:DefaultAttribute( attributeName: string,-- The name of the attribute to set value: any,-- The value to set the attribute to validDataTypes: {string}?-- A list of valid data types for the attribute ) → any-- The value of the attribute Sets an attribute to a default value if it is not already set, allows for type checking of the initial value  "},{"title":"AttributeChanged​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AttributeChanged","content":"&lt;/&gt; BaseComponent:AttributeChanged( attributeName: string,-- The name of the attribute to observe fn: ((...any) → ())?-- The function to call when the attribute changes ) → RBXScriptConnection | RBXScriptSignal -- A function to disconnect the observer or the signal Fetches the AttributeChanged signal for the attribute if no function is given. If a function is provided, it will connect the function to the attribute changed signal and return the connection "},{"title":"BaseTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#types","content":" "},{"title":"Id​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Id","content":"&lt;/&gt; type Id = number The id of a replicator.  "},{"title":"SearchCondition​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#SearchCondition","content":"&lt;/&gt; type SearchCondition = string | ClassToken | Tags | ( replicator: BaseTableReplicator, manager: TableManager? ) → (boolean) A condition that can be used to filter replicators. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If the condition is a function then it should return a boolean to indicate success. If the condition is a ClassToken then it will check if the replicator's class token matches the given token. If the condition is a string then it will check if the replicator's class token name matches the given string. If the condition is a Tags dictionary then it will check if the replicator's tags are a superset of the given tags.  "},{"title":"Tags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Tags","content":"&lt;/&gt; type Tags = {[string]: any} The valid tag format that can be given to a TableReplicator. This table will become locked once given to a TableReplicator. Do not attempt to modify it after the fact. local tags = table.freeze { OwnerId = Player.UserId; ToolType = &quot;Sword&quot;; }  "},{"title":"Properties​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#properties","content":" "},{"title":"ReplicatorCreated​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#ReplicatorCreated","content":"&lt;/&gt; BaseTableReplicator.ReplicatorCreated: Signal&lt;BaseTableReplicator&gt; A signal that fires whenever a new replicator is created. "},{"title":"Functions​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#functions","content":" "},{"title":"iterating over BaseTableReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#__iter","content":"Metamethod &lt;/&gt; for in BaseTableReplicator do Iterates over all replicators that are currently in memory. for _, replicator in TableReplicator do print(replicator:GetServerId()) end   "},{"title":"getFromServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getFromServerId","content":"Static &lt;/&gt; BaseTableReplicator.getFromServerId(id: Id) → BaseTableReplicator? Returns the replicator with the given id if one exists.  "},{"title":"forEach​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#forEach","content":"Static &lt;/&gt; BaseTableReplicator.forEach( condition: SearchCondition, fn: ( replicator: BaseTableReplicator, manager: TableManager? ) → (), allowDestroyedReplicators: boolean? ) → () forEach is a special function that allows you to run a function on all replicators that currently exist or will exist that match the given condition. caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned.  "},{"title":"promiseFirstReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#promiseFirstReplicator","content":"Static &lt;/&gt; BaseTableReplicator.promiseFirstReplicator( condition: SearchCondition, allowDestroyedReplicators: boolean? ) → Promise&lt;BaseTableReplicator,TableManager?&gt; promiseFirstReplicator is a special function that allows you to run a function on the first replicator to satisfy the given condition. If no replicator currently exists that satisfies the condition then it will wait for one to be created. caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned. BaseTableReplicator.promiseFirstReplicator(&quot;Test&quot;)   "},{"title":"getAll​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getAll","content":"Static &lt;/&gt; BaseTableReplicator.getAll(classTokenName: string?) → {BaseTableReplicator} Fetches all replicators that are currently in memory. This is very slow and should be used sparingly.  "},{"title":"listenForNewReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#listenForNewReplicator","content":"Static &lt;/&gt; BaseTableReplicator.listenForNewReplicator( classToken: CanBeArray&lt;string | ClassToken&gt;, fn: (replicator: BaseTableReplicator) → () ) → () → () Listens for new replicators that are created with the given class token.  "},{"title":"GetTableManager​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTableManager","content":"&lt;/&gt; BaseTableReplicator:GetTableManager() → TableManager Gets the TableManager that is being replicated.  "},{"title":"GetServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetServerId","content":"&lt;/&gt; BaseTableReplicator:GetServerId() → Id Returns the server id for this replicator. On the Server this is equivalent to :GetId()  "},{"title":"GetTokenName​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTokenName","content":"&lt;/&gt; BaseTableReplicator:GetTokenName() → string Fetches the name of the class token that this replicator is using.  "},{"title":"IsTopLevel​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsTopLevel","content":"&lt;/&gt; BaseTableReplicator:IsTopLevel() → boolean Returns whether or not this replicator is a top level replicator. A top level replicator is a replicator that has no parent. Only top level replicators can have their ReplicationTargets set.  "},{"title":"GetParent​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetParent","content":"&lt;/&gt; BaseTableReplicator:GetParent() → BaseTableReplicator? Returns the parent of this replicator if it has one. If this replicator is a top level replicator then this will return nil.  "},{"title":"GetChildren​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetChildren","content":"&lt;/&gt; BaseTableReplicator:GetChildren() → {BaseTableReplicator} Returns the immediate children of this replicator.  "},{"title":"GetDescendants​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetDescendants","content":"&lt;/&gt; BaseTableReplicator:GetDescendants() → {BaseTableReplicator} Returns the descendants of this replicator.  "},{"title":"FindFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#FindFirstChild","content":"&lt;/&gt; BaseTableReplicator:FindFirstChild( condition: SearchCondition, recursive: boolean? ) → BaseTableReplicator? Finds the first child that satisfies the given condition. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If recursive is true then it will search through all descendants. local child = tr:FindFirstChild(function(child) local manager = child:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 })   "},{"title":"PromiseFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#PromiseFirstChild","content":"&lt;/&gt; BaseTableReplicator:PromiseFirstChild(condition: SearchCondition) → Promise&lt;BaseTableReplicator&gt; Returns a promise that resolves when the first child that satisfies the given function is found. tr:PromiseFirstChild(function(replicator) local manager = replicator:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 }):andThen(function(replicator) print(&quot;Found child with data key 'Test' equal to 1!&quot;) end) tr:PromiseFirstChild(&quot;Test&quot;):andThen(function(replicator) print(&quot;Found child with classtoken 'Test'!&quot;) end) tr:PromiseFirstChild({UserId == 12345}):andThen(function(replicator) print(&quot;Found child with UserId Tag matching 12345!&quot;) end)   "},{"title":"GetTag​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTag","content":"&lt;/&gt; BaseTableReplicator:GetTag(tagKey: string) → any Returns the value of the given tag for this replicator.  "},{"title":"GetTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTags","content":"&lt;/&gt; BaseTableReplicator:GetTags() → Tags Returns the tags dictionary for this replicator.  "},{"title":"IsSupersetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSupersetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSupersetOfTags(tags: Tags) → boolean Checks whether or not the given tags are a subset of this replicator's tags. ELI5: Are all the given tags also on this replicator? Aliased as :ContainsAllTags(tags) ```lua local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSupersetOfTags({ Test1 = 1, }) -- true tr:IsSupersetOfTags({ Test2 = 2, }) -- true  "},{"title":"IsSubsetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSubsetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSubsetOfTags(tags: Tags) → boolean Checks whether or not this replicator's tags are a subset of the given tags. ELI5: Are all the tags on this replicator also on the given tags? Aliased as :IsWithinTags(tags) local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSubsetOfTags({ Test1 = 1, Test2 = 2, Test3 = 3, }) -- true tr:IsSubsetOfTags({ Test1 = 1, }) -- false  "},{"title":"ClientPlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientPlayerDataManager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#properties","content":" "},{"title":"DEFAULT_MANAGER_NAME​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#DEFAULT_MANAGER_NAME","content":"&lt;/&gt; ClientPlayerDataManager.DEFAULT_MANAGER_NAME: string The default internal manager name.  "},{"title":"PlayerDataReady​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#PlayerDataReady","content":"&lt;/&gt; ClientPlayerDataManager.PlayerDataReady: Signal&lt;Player &gt; A signal that fires when a Player's data is ready to be used. "},{"title":"Functions​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#new","content":"Constructor Static &lt;/&gt; ClientPlayerDataManager.new(config: { ProfileSchema: table, }) → ClientPlayerDataManager   "},{"title":"GetImmediate​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#GetImmediate","content":"&lt;/&gt; ClientPlayerDataManager:GetImmediate(managerName: string?) → TableReplicatorSingleton Gets the TableReplicatorSingleton for this manager so you can get immediate info from it if needed.  "},{"title":"GetManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#GetManager","content":"&lt;/&gt; ClientPlayerDataManager:GetManager(managerName: string?) → TableManager? Gets the TableManager associated with the given name. This method may return nil if the data has not replicated yet.  "},{"title":"PromiseManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#PromiseManager","content":"&lt;/&gt; ClientPlayerDataManager:PromiseManager(managerName: string?) → Promise Promises the TableManager associated with the given name. If it doesnt exist when called then it will wait for it to be replicated and then will resolve.  "},{"title":"RegisterManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#RegisterManager","content":"&lt;/&gt; ClientPlayerDataManager:RegisterManager(config: string | {Name: string;DefaultDataSchema: table;ConditionFn: ((replicator: TableReplicator) → boolean)?}) → TableReplicatorSingleton Registers a tableManager/TableReplicatorSingleton to be watched for on the client. Informal registration. Assumes data key in the profile template is the same as the given name. ClientPlayerDataManager:RegisterManager(&quot;Currency&quot;) Formal registration. Used for more complex/custom registering of managers ClientPlayerDataManager:RegisterManager({ Name = &quot;Currency&quot;, DefaultDataSchema = profileTemplate[&quot;Currency&quot;], ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end, })   "},{"title":"Start​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#Start","content":"unreleased &lt;/&gt; ClientPlayerDataManager:Start() → () Marks the CPDM as started. This is not currently neccessary "},{"title":"ClientTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientTableReplicator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#functions","content":" "},{"title":"fromTemplate​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#fromTemplate","content":"Static &lt;/&gt; ClientTableReplicator.fromTemplate() → () Creates a ReplicatedTableSingleton object from the given template configuration. See TableReplicatorSingleton.new for more information.  "},{"title":"listenForNewReplicator​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#listenForNewReplicator","content":"&lt;/&gt; ClientTableReplicator.listenForNewReplicator( classTokenName: string, fn: (replicator: ClientTableReplicator) → () ) → () → () Listens for a new ClientTableReplicator of the given ClassName.  "},{"title":"requestServerData​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#requestServerData","content":"&lt;/&gt; ClientTableReplicator.requestServerData() → Promise Requests all the existing replicators from the server. This should only be called once, calling it multiple times will return the same promise. All replicator listeners should be registered before calling this method. "},{"title":"DropletClientManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletClientManager","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#new","content":"constructor &lt;/&gt; DropletClientManager.new() → DropletClientManager Creates a new DropletClientManager if one has not already been made, returns the existing one if one already exists.  "},{"title":"RegisterResourceType​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#RegisterResourceType","content":"&lt;/&gt; DropletClientManager:RegisterResourceType( resourceType: string, data: ResourceTypeData ) → () Registers a new resource type.  "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#GetResourceTypeData","content":"&lt;/&gt; DropletClientManager:GetResourceTypeData(resourceType: string) → ResourceTypeData? Returns the resource type data for the given resource type  "},{"title":"GetCollectionRadius​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#GetCollectionRadius","content":"&lt;/&gt; DropletClientManager:GetCollectionRadius() → number Gets the distance at which a droplet must be within to be collected by the LocalPlayer "},{"title":"DropletManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#types","content":" "},{"title":"Droplet​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Droplet","content":"&lt;/&gt; type Droplet = Droplet   "},{"title":"ResourceTypeData​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#ResourceTypeData","content":"&lt;/&gt; type ResourceTypeData = ResourceTypeData   "},{"title":"ResourceSpawnData​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#ResourceSpawnData","content":"&lt;/&gt; type ResourceSpawnData = ResourceSpawnData  "},{"title":"Properties​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Server","content":"This item only works when running on the server. Server &lt;/&gt; DropletManager.Server: DropletServerManager Accessing this will automatically create a new DropletServerManager if one does not exist.  "},{"title":"Client​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Client","content":"This item only works when running on the client. Client &lt;/&gt; DropletManager.Client: DropletClientManager Accessing this will automatically create a new DropletClientManager if one does not exist.  "},{"title":"Util​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Util","content":"&lt;/&gt; DropletManager.Util: DropletUtil  "},{"title":"DropletServerManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletServerManager","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#new","content":"constructor &lt;/&gt; DropletServerManager.new() → DropletServerManager Creates a new DropletServerManager if one has not already been made, returns the existing one if one already exists.  "},{"title":"RegisterResourceType​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#RegisterResourceType","content":"&lt;/&gt; DropletServerManager:RegisterResourceType( resourceType: string, data: ResourceTypeData ) → () Registers a new resource type. Attempting to register a resource type with the same name as an existing one will error. local data = Import(&quot;ExampleResourceTypeData&quot;) -- This is an Example file included in the package you can check out. DropletServerManager:RegisterResourceType(&quot;Example&quot;, data)   "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#GetResourceTypeData","content":"&lt;/&gt; DropletServerManager:GetResourceTypeData(resourceType: string) → ResourceTypeData? Returns the resource type data for the given resource type.  "},{"title":"Spawn​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Spawn","content":"&lt;/&gt; DropletServerManager:Spawn( data: ResourceSpawnData-- The data used to spawn the droplet. ) → number-- The seed of the droplet request. Creates a new droplet request to create some defined number of droplets of a given ResourceType. The droplet request will be created on the server and replicated to the clients. A PlayerTargets array can be passed to specify which players the droplet request should be replicated to, if one isnt given it replicates to all connected players at the moment of the request. Caveats Some properties of the interface have special behaviors depending on their type. See 'ResourceSpawnData' for more info on important caveats and behavior. local Bounds = 35 local seed = DropletServerManager:Spawn({ ResourceType = &quot;Example&quot;; Value = NumberRange.new(0.6, 1.4); Count = NumberRange.new(2, 10); LifeTime = NumberRange.new(10, 20); SpawnLocation = Vector3.new( math.random(-Bounds,Bounds), 7, math.random(-Bounds,Bounds) ); CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector; })   "},{"title":"Claim​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Claim","content":"&lt;/&gt; DropletServerManager:Claim( collector: Player ,-- The player claiming the droplet. seed: number,-- The droplet request identifier. dropletNumber: number?-- The particular droplet number to claim. If nil, all remaining droplets will be claimed. ) → boolean-- Whether or not the claim was successful. Force claim a droplet(s) for a player.  "},{"title":"Droplet","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Droplet","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#types","content":" "},{"title":"Droplet​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Droplet","content":"&lt;/&gt; type Droplet = Droplet  "},{"title":"Functions​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#functions","content":" "},{"title":"GetValue​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetValue","content":"&lt;/&gt; Droplet:GetValue() → any   "},{"title":"GetMetadata​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetMetadata","content":"&lt;/&gt; Droplet:GetMetadata() → any?   "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetResourceTypeData","content":"&lt;/&gt; Droplet:GetResourceTypeData() → ResourceTypeData   "},{"title":"GetPosition​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetPosition","content":"&lt;/&gt; Droplet:GetPosition() → Vector3    "},{"title":"GetModel​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetModel","content":"&lt;/&gt; Droplet:GetModel() → Actor    "},{"title":"GetSetupData​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetSetupData","content":"&lt;/&gt; Droplet:GetSetupData() → any Returns the data that was returned by the ResourceTypeData.Setup function  "},{"title":"Identify​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Identify","content":"&lt;/&gt; Droplet:Identify() → ( number,-- The seed of the droplet number-- The id of the droplet ) Returns the seed and id of the droplet. Used for internal identification.  "},{"title":"IsTimingOut​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#IsTimingOut","content":"&lt;/&gt; Droplet:IsTimingOut() → boolean Returns whether or not the droplet is in the process of timing out.  "},{"title":"AttachModel​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#AttachModel","content":"&lt;/&gt; Droplet:AttachModel(object: Model | BasePart ) → () Attaches a Model or Part to the droplet. Use this to add your visuals to the droplet.  "},{"title":"Collect​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Collect","content":"&lt;/&gt; Droplet:Collect(playerWhoCollected: Player ) → ()   "},{"title":"Claim​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Claim","content":"&lt;/&gt; Droplet:Claim(playerWhoClaimed: Player ) → ()  "},{"title":"Collect​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Collect","content":"&lt;/&gt; DropletServerManager:Collect( collector: Player ,-- The player collecting the resource. seed: number,-- The droplet request identifier. dropletNumber: number?-- The particular droplet number to collect. If nil, all droplets will be collected. ) → boolean-- Whether or not the collection was successful. Force collects a droplet(s) resource and returns whether or not the collection was successful.  "},{"title":"GetCollectionRadius​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#GetCollectionRadius","content":"&lt;/&gt; DropletServerManager:GetCollectionRadius(player: Player ) → number Gets the collection radius for the given player.  "},{"title":"SetCollectionRadius​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#SetCollectionRadius","content":"&lt;/&gt; DropletServerManager:SetCollectionRadius( player: Player , radius: number ) → () Sets the collection radius for the given player. "},{"title":"NetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/NetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Server","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.Server: ServerNetWire   "},{"title":"Client​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Client","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.Client: ClientNetWire  "},{"title":"Functions​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#functions","content":" "},{"title":"createEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createEvent","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createEvent() → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information.  "},{"title":"createProperty​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createProperty","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createProperty(initialValue: any?) → ServerRemoteProperty Returns an PropertyMarker that is used to mark where a remoteProperty should be created. Calls ServerNetWire:RegisterProperty() when set to the index of a ServerNetWire. See ServerNetWire:RegisterProperty for more information.  "},{"title":"getServer​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#getServer","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.getServer(wireName: string) → ServerNetWire? Returns a ServerNetWire from the cache, if it exists.  "},{"title":"indexReady​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#indexReady","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.indexReady( wireOrName: ClientNetWire | string, idx: string-- The index to wait for existence of ) → Promise Returns a promise that resolves when the ClientNetWire is ready for use and the index exists. The resolved value is the value of the index.  "},{"title":"onReady​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#onReady","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.onReady(clientNetWire: ClientNetWire | string) → Promise Returns a promise that resolves when the ClientNetWire is ready for use.  "},{"title":"isReady​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#isReady","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.isReady(clientNetWire: ClientNetWire | string) → boolean Can be used to check if a clientNetWire is ready for use.  "},{"title":"destroy​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#destroy","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.destroy(clientNetWire: ClientNetWire) → () Destroys a ClientNetWire, removing it from the cache.  "},{"title":"getClient​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#getClient","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.getClient(wireName: string) → ClientNetWire? Returns a ClientNetWire from the cache, if it exists. "},{"title":"Component","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? Extensions: {Extension}? Methods: {[string]: function}? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end In this forked version of component, extensions can also add methods to the component class and extend other extensions via giving an extension a Methods table. For example: local ExtendedComponentMethods = {} function ExtendedComponentMethods.DoSomething(component) print(&quot;Hello World!&quot;) end local MyComponentExtension = {} MyComponentExtension.Methods = ExtendedComponentMethods This will add a method called DoSomething to the component class. Be careful when using with ShouldExtend It is important to note that these methods are added to the Component Class and not the Component Instance. This means that these methods will be availible regardless of whether the extension passes its shouldExtend function or not. If your code is dependent on extension methods existing only when they pass their shouldExtend function, you may want to avoid using this feature. If you want to utilize other extensions within your extension or guarantee that the given extension is loaded onto the component before your extension, you can use the Extensions table. For example: local SomeOtherExtension = require(somewhere.SomeOtherExtension) local MyComponentExtension = {} MyComponentExtension.Extensions = {SomeOtherExtension} This will guarantee that SomeOtherExtension is added to the component and loaded before MyComponentExtension. info The ShouldExtend function of SomeOtherExtension will still be called independently of the ShouldExtend function of MyExtension. Under the hood this just adds the extension to the components original extension array.  "},{"title":"DropletUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#types","content":" "},{"title":"WeightedArray<T>​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#WeightedArray<T>","content":"&lt;/&gt; type WeightedArray&lt;T&gt; = {{ Weight: number, Value: T }} A table of values with weights. The weights are used to calculate the probability of a value being chosen. The weights do not need to add up to 1. See ProbabilityDistributor for more information.  "},{"title":"NumOrRange​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#NumOrRange","content":"&lt;/&gt; type NumOrRange = number | NumberRange    "},{"title":"NumOrRangeOrWeightedArray​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#NumOrRangeOrWeightedArray","content":"&lt;/&gt; type NumOrRangeOrWeightedArray = NumOrRange | WeightedArray&lt;NumOrRange&gt;   "},{"title":"ResourceTypeData​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#ResourceTypeData","content":"&lt;/&gt; interface ResourceTypeData { Defaults: table SetupDroplet: (droplet: Droplet) → any? OnRenderUpdate: (( droplet: Droplet, renderTime: number ) → (CFrame? ))? OnDropletTimeout: ((droplet: Droplet) → ())? OnClientClaim: (( playerWhoCollected: Player , droplet: Droplet ) → ())? OnClientCollect: (( playerWhoCollected: Player , droplet: Droplet ) → ())? OnServerCollect: (( playerWhoCollected: Player , value: any, metadata: any ) → ())? }  [Defaults] is a table of default values for the droplet. This can be left empty. The values in this table are used to fill in any missing values in the ResourceSpawnData when a droplet is spawned as well as overriding certain behaviors internall for things like magnetization. [SetupDroplet] is called when a new droplet is created. Use this to setup your visuals and any variables you need to keep track of. All parts within this should be Anchored = false, CanCollide = false, and Massless = true. The return value of this function can be accessed via Droplet:GetSetupData() [OnRenderUpdate] is called every frame that the droplet is within render range of the LocalPlayer's Camera. Use this to update the visuals of your droplet. The return value, if one is given, must be a CFrame and is used for offsetting the droplet. [OnDropletTimeout] is called when the droplet times out. Use this to perform/cleanup any visual effects you may have. [OnClientClaim] is called when the server acknowledges that the droplet has been claimed. [OnClientCollect] is called when the droplet hits the player and is considered collected. It should be used for collection effects and other client side things. [OnServerCollect] is called once the server is informed by a client that the droplet has been collected. This is where you should perform any server side logic like actually giving things like Money or Exp.   "},{"title":"ResourceSpawnData​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#ResourceSpawnData","content":"&lt;/&gt; interface ResourceSpawnData { ResourceType: string-- The registered name of the resource type Value: any | NumOrRangeOrWeightedArray-- The value of the droplet Metadata: any?-- The metadata of the droplet SpawnLocation: Vector3 | CFrame | PVInstance -- The location to spawn the droplet CollectorMode: CollectorMode?-- The behavior of how the droplet is claimed PlayerTargets: Player | {Player }?-- The players that can collect the droplet LifeTime: NumOrRange?-- The time before the droplet dissapears Count: NumOrRangeOrWeightedArray?-- The number of droplets to spawn EjectionDuration: NumOrRangeOrWeightedArray?-- The time it takes to spew out all the droplets EjectionHorizontalVelocity: NumOrRangeOrWeightedArray?-- The horizontal velocity of the droplets when they are ejected EjectionVerticalVelocity: NumOrRangeOrWeightedArray?-- The vertical velocity of the droplets when they are ejected }  Special Behaviors Any index that takes a NumOrRangeOrWeightedArray will be parsed and calculated ahead of time internally so that the client and server are synced. For example, if you pass in a NumberRange for Value, the server will calculate a random decimal number between the min and max, this number would then be accessed by Droplet:GetValue() on the client.  "},{"title":"CollectorMode​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#CollectorMode","content":"&lt;/&gt; type CollectorMode = &quot;MultiCollector&quot; | &quot;SingleCollector&quot; The behavior of how the droplet is claimed. MultiCollector - Many players can collect this droplet, each has their own individual instance SingleCollector - Only one player can collect this droplet  "},{"title":"Properties​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#Enums","content":"&lt;/&gt; DropletUtil.Enums: {CollectorMode: { MultiCollector: CollectorMode, SingleCollector: CollectorMode }}  "},{"title":"PlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerDataManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#types","content":" "},{"title":"ServerPlayerDataManager​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#ServerPlayerDataManager","content":"&lt;/&gt; type ServerPlayerDataManager = ServerPlayerDataManager   "},{"title":"ClientPlayerDataManager​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#ClientPlayerDataManager","content":"&lt;/&gt; type ClientPlayerDataManager = ClientPlayerDataManager  "},{"title":"Properties​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#Server","content":"This item only works when running on the server. Server &lt;/&gt; PlayerDataManager.Server: ServerPlayerDataManager The ServerPlayerDataManager class.  "},{"title":"Client​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#Client","content":"This item only works when running on the client. Client &lt;/&gt; PlayerDataManager.Client: ClientPlayerDataManager The ClientPlayerDataManager class. "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#properties","content":" "},{"title":"Started​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#new","content":"Component &lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:Construct() self.MyData = &quot;Hello&quot; end function MyComponent:Start() local another = self:GetComponent(AnotherComponent) another:DoSomething() end function MyComponent:Stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:HeartbeatUpdate(dt) end function MyComponent:SteppedUpdate(dt) end function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"HeartbeatUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#HeartbeatUpdate","content":"Component Class &lt;/&gt; Component.HeartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:HeartbeatUpdate(dt) end   "},{"title":"SteppedUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#SteppedUpdate","content":"Component Class &lt;/&gt; Component.SteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:SteppedUpdate(dt) end   "},{"title":"RenderSteppedUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#RenderSteppedUpdate","content":"This item only works when running on the client. Client Component Class &lt;/&gt; Component.RenderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:RenderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetAll","content":"Component Class &lt;/&gt; Component:GetAll() → {Component} Gets a table array of all existing component objects. For example, if there was a component class linked to the &quot;MyComponent&quot; tag, and three Roblox instances in your game had that same tag, then calling GetAll would return the three component instances. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- ... local components = MyComponent:GetAll() for _,component in ipairs(components) do component:DoSomethingHere() end   "},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#FromInstance","content":"Component Class &lt;/&gt; Component:FromInstance(instance: Instance ) → Component? Gets an instance of a component class from the given Roblox instance. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = MyComponent:FromInstance(workspace.SomeInstance)   "},{"title":"WaitForInstance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#WaitForInstance","content":"Component Class &lt;/&gt; Component:WaitForInstance( instance: Instance , timeout: number? ) → Promise&lt;ComponentInstance&gt; Resolves a promise once the component instance is present on a given Roblox instance. An optional timeout can be provided to reject the promise if it takes more than timeout seconds to resolve. If no timeout is supplied, timeout defaults to 60 seconds. local MyComponent = require(somewhere.MyComponent) MyComponent:WaitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance) -- Do something with the component class end)   "},{"title":"UpdateAncestors​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#UpdateAncestors","content":"Component Class &lt;/&gt; Component:UpdateAncestors(newAncestors: {Instance }) → () Allows for you to update the valid ancestors of a component class. This is useful if you want to give a valid ancestor that may not exist when the component is first created. local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, }) task.defer(function() local newAncestors = {workspace:WaitForChild(&quot;SomeFolder&quot;)} MyComponent:UpdateAncestors(newAncestors) end)   "},{"title":"Construct​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Construct","content":"Component Class &lt;/&gt; Component:Construct() → () Construct is called before the component is started, and should be used to construct the component instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"Start​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Start","content":"Component Class &lt;/&gt; Component:Start() → () Start is called when the component is started. At this point in time, it is safe to grab other components also bound to the same instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() -- e.g., grab another component: local another = self:GetComponent(AnotherComponent) end   "},{"title":"Stop​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Stop","content":"Component Class &lt;/&gt; Component:Stop() → () Stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.Instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Stop() self.SomeStuff:Destroy() end   "},{"title":"GetComponent​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetComponent","content":"Component Instance &lt;/&gt; Component:GetComponent(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() local another = self:GetComponent(AnotherComponent) end   "},{"title":"ForEachSibling​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ForEachSibling","content":"Component Instance &lt;/&gt; Component:ForEachSibling( componentClass: ComponentClass, fn: ( component: Component, jani: Janitor ) → () ) → Connection Ties a function to the lifecycle of the calling component and the equivalent component of the givencomponentClass. The function is run whenever a component of the given class is started. The given function passes the sibling component of the given class and a janitor to handle any connections you may make within it. The Janitor is cleaned up whenever either compenent is stopped. local AnotherComponent = require(somewhere.AnotherComponent) local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Start() self:ForEachSibling(AnotherComponent, function(sibling, jani) print(sibling.SomeProperty) jani:Add(function() print(&quot;Sibling component stopped&quot;) end) end) end  "},{"title":"RemoteComponent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RemoteComponent","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#types","content":" "},{"title":"RemoteComponent​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#RemoteComponent","content":"&lt;/&gt; interface RemoteComponent { Client: table?-- Only availible on the server. Set this to a table to expose it to the client. Server: table?-- Only availible on the client. The indices of this are inferred from the server. } -- MyComponent.server.lua local MyComponent = Component.new { Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {RemoteComponent}, } MyComponent.Client = { TestProperty = NetWire.createProperty(0), TestSignal = NetWire.createEvent(), } function MyComponent.Client:TestMethod(player: Player) return (&quot;Hello from the server!&quot;) end -- MyComponent.client.lua local MyComponent = Component.new { Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {RemoteComponent}, } function MyComponent:Start() self.Server:TestMethod():andThen(print) end  "},{"title":"ExampleResourceTypeData","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ExampleResourceTypeData","content":"On this page ExampleResourceTypeData An Example ResourceTypeData file. This is used to define the general behavior of a droplet type. local GenericPart = Instance.new(&quot;Part&quot;) GenericPart.Name = &quot;GenericPart&quot; GenericPart.Transparency = 1 GenericPart.Size = Vector3.one GenericPart.Anchored = true GenericPart.CanCollide = false GenericPart.CanTouch = false GenericPart.CanQuery = false GenericPart.Massless = true -------------------------------------------------------------------------------- --// Data //-- -------------------------------------------------------------------------------- return { Defaults = { Value = NumberRange.new(0.6, 1.4); -- The value you want the droplet to have. This can be anything. -- Metadata = {}; -- You typically shouldnt default metadata. Count = NumberRange.new(2, 5); -- Number of droplets to spawn LifeTime = NumberRange.new(50, 60); -- Time before the droplet dissapears EjectionDuration = 1; -- Time it takes to spew out all the droplets EjectionHorizontalVelocity = NumberRange.new(0, 25); EjectionVerticalVelocity = NumberRange.new(25, 50); CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector; Mass = 1; -- Mass of the droplet (Used in magnitization calculations) MaxForce = math.huge; -- Maximum steering force applied to the droplet when magnitized to a player MaxVelocity = 150; -- Maxiumum velocity of the droplet when magnitized to a player CollectionRadius = 1.5; -- Radius from center of player the droplet must be to be considered 'collected' }; --[[ Called when a new droplet is created. Use this to setup your visuals and any variables you need to keep track of. All parts within this should be Anchored = false, CanCollide = false, and Massless = true. The return value of this function can be accessed via Droplet:GetSetupData() ]] SetupDroplet = function(droplet: Droplet) local Value = droplet:GetValue() :: number local VisualModel = Instance.new(&quot;Model&quot;) VisualModel.Name = &quot;VisualModel&quot; local OuterPart = GenericPart:Clone() OuterPart.Name = &quot;Outer&quot; OuterPart.Material = Enum.Material.Glass OuterPart.Transparency = 0.5 OuterPart.Color = Color3.fromRGB(16, 206, 16) OuterPart.Size = Vector3.one * Value OuterPart.Anchored = false OuterPart.Parent = VisualModel VisualModel.PrimaryPart = OuterPart local NumGen = Random.new() local InnerPart = OuterPart:Clone() InnerPart.Material = Enum.Material.Neon InnerPart.Name = &quot;Inner&quot; InnerPart.Color = Color3.fromRGB(219, 189, 18) InnerPart.Transparency = 0 InnerPart.CastShadow = false InnerPart.Size *= 0.6 + NumGen:NextNumber(-0.1, 0.1) InnerPart.CFrame = OuterPart.CFrame + Vector3.new( NumGen:NextNumber(-0.1, 0.1), NumGen:NextNumber(-0.1, 0.1), NumGen:NextNumber(-0.1, 0.1) ) InnerPart.Parent = VisualModel local Weld = Instance.new(&quot;WeldConstraint&quot;) Weld.Part0 = OuterPart Weld.Part1 = InnerPart Weld.Parent = VisualModel droplet:AddTask(task.spawn(function() for i = 0.025, 1, 0.025 do VisualModel:ScaleTo(i) task.wait() end VisualModel:ScaleTo(1) end), nil, &quot;GrowThread&quot;) droplet:AttachModel(VisualModel) return { VisualModel = VisualModel; SpinDirection = if math.random() &gt; 0.5 then 1 else -1; } end; -- Ran when the droplet is within render range of the LocalPlayer's Camera OnRenderUpdate = function(droplet: Droplet, rendertimeElapsed: number) local SetupData = droplet:GetSetupData() local OffsetCFrame = CFrame.new() do -- Bobbing local AMPLITUDE = 1 -- Studs of vertical movement (+- half of this) local FREQUENCY = 0.25 -- Cycles per second local Y = (AMPLITUDE * 0.5) * -math.cos((rendertimeElapsed*math.pi) * (FREQUENCY)) OffsetCFrame *= CFrame.new(0, AMPLITUDE + Y, 0) end do -- Rotating local TimeToMakeOneRotation = 4 local RotationsPerSecond = 1/TimeToMakeOneRotation OffsetCFrame *= CFrame.Angles(0, (rendertimeElapsed*math.pi) * RotationsPerSecond * SetupData.SpinDirection , 0) end return OffsetCFrame end; OnDropletTimeout = function(droplet: Droplet) local VisualModel = droplet:GetSetupData().VisualModel droplet:RemoveTask(&quot;GrowThread&quot;) for i = 1, 0.025, -0.025 do VisualModel:ScaleTo(i) task.wait() end end; OnClientClaim = function(playerWhoClaimed: Player, droplet: Droplet) -- droplet:Collect(playerWhoClaimed) end; --[[ Called when the droplet hits the player and is considered collected. This is ran on the client only. It should be used for collection effects and other client side things. ]] OnClientCollect = function(playerWhoCollected: Player, droplet: Droplet) local Value = droplet:GetValue() :: number local Part = GenericPart:Clone() Part.CFrame = droplet:GetPivot() task.delay(2, function() Part:Destroy() end) local CollectionSound = Instance.new(&quot;Sound&quot;) CollectionSound.SoundId = &quot;rbxassetid://402143943&quot; CollectionSound.Volume = 0.25 local PitchShift = Instance.new(&quot;PitchShiftSoundEffect&quot;) PitchShift.Octave = 2 - Value/1.5 PitchShift.Parent = CollectionSound CollectionSound.Parent = Part Part.Parent = workspace CollectionSound:Play() end; --[[ Called once the client informs the server that it has collected the droplet. ]] OnServerCollect = function(playerWhoCollected: Player, value: any, metadata: any) local ExpValue: number = value local leaderstats = playerWhoCollected:FindFirstChild(&quot;leaderstats&quot;) if not leaderstats then leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; leaderstats.Parent = playerWhoCollected end local expStat = leaderstats:FindFirstChild(&quot;Exp&quot;) if not expStat then expStat = Instance.new(&quot;NumberValue&quot;) expStat.Name = &quot;Exp&quot; expStat.Parent = leaderstats end expStat.Value += ExpValue -- Add the value to the player's &quot;exp&quot;. This is just an example. end; } ","keywords":""},{"title":"PlayerProfileManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerProfileManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#types","content":" "},{"title":"DataMigrator​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#DataMigrator","content":"&lt;/&gt; interface DataMigrator { FromVersion: string ToVersion: string Migrate: ( profileData: table, profileOwner: Player ) → (table) } Used to Transform data from one version to another -- Turn all the deprecated currency 'Candy' into the new currency 'Gems' at a 1:10 rate local migrator = { FromVersion = &quot;0.0.1&quot;, ToVersion = &quot;0.0.2&quot; Migrate = function(data: table, plr: Player) if not data.Gems then data.Gems = 0 end local candy = data.Candy or 0 data.Gems += candy * 10 data.Candy = nil return data end }   "},{"title":"PPM_Config​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PPM_Config","content":"&lt;/&gt; interface PPM_Config { DataStoreKey: string DefaultDataSchema: table UseMock: boolean? Migrator: {DataMigrator} GetPlayerKeyCallback: ((player: Player ) → (string))? ReconcileCallback: (( player: Player , profile: Profile ) → ())? OnProfileLoadFailureCallback: (( player: Player , err: string ) → ())? }  DataStoreKey is the internal Key used for the PlayerData's DataStore. DefaultDataSchema is a template table that is used for reconciling the player's profile with. It is what new players are given if they dont have existing data. UseMock determines whether or not a Mock ProfileStore will be used. Migrator is a table of DataMigrators that are used to transform data from one version to another. GetPlayerKeyCallback is a callback that is used to fetch the Key that each player's data is mapped to. ReconcileCallback is a callback that is called when the system attempts to reconcile the players profile. It will default to calling Profile:Reconcile if not provided. OnProfileLoadFailureCallback is a callback that is called if the player's data fails to load. It will default to kicking the player if not provided.  "},{"title":"Functions​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#new","content":"&lt;/&gt; PlayerProfileManager.new(config: PPM_Config) → PlayerProfileManager Creates a new PlayerProfileManager. This is a singleton class, so calling this function multiple times will return the same instance. Takes a config table, see PPM_Config for more info on the individual fields it supports. PlayerProfileManager.new({ DataStoreKey = &quot;PlayerData&quot;; DefaultDataSchema = { __VERSION = &quot;0.0.0&quot;; Currency = 0; }; })   "},{"title":"IsLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#IsLoaded","content":"&lt;/&gt; PlayerProfileManager:IsLoaded(player: Player ) → boolean Returns whether or not the player's profile is currently loaded. local isLoaded = PlayerProfileManager:IsLoaded(player)   "},{"title":"OnLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#OnLoaded","content":"&lt;/&gt; PlayerProfileManager:OnLoaded(player: Player ) → Promise&lt;()&gt; Returns a promise that will resolve when the player's profile is loaded. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:OnLoaded(player):andThen(function() print(&quot;Profile loaded for &quot; .. player.Name) end)   "},{"title":"GetProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#GetProfile","content":"&lt;/&gt; PlayerProfileManager:GetProfile(player: Player ) → Profile? Returns the player's profile, if it exists. May return nil if this players profile is not loaded. local profile: Profile? = PlayerProfileManager:GetProfile(player)   "},{"title":"PromiseProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PromiseProfile","content":"&lt;/&gt; PlayerProfileManager:PromiseProfile(player: Player ) → Promise&lt;Profile&gt; Returns a promise that resolves with the player's profile when it is ready. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:PromiseProfile(player):andThen(function(profile: Profile) print(&quot;Profile loaded for &quot; .. player.Name) end)  "},{"title":"ServerPlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerPlayerDataManager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#properties","content":" "},{"title":"DEFAULT_MANAGER_NAME​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#DEFAULT_MANAGER_NAME","content":"&lt;/&gt; ServerPlayerDataManager.DEFAULT_MANAGER_NAME: string The default internal manager name.  "},{"title":"PlayerDataReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#PlayerDataReady","content":"&lt;/&gt; ServerPlayerDataManager.PlayerDataReady: Signal&lt;Player &gt; A signal that fires when a Player's data is ready to be used. "},{"title":"Functions​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#new","content":"Constructor Singleton Static &lt;/&gt; ServerPlayerDataManager.new(ppm: PlayerProfileManager?) → ServerPlayerDataManager Constructs a new ServerPlayerDataManager instance. local PPM = PlayerProfileManager.new() local PlayerDataManager = PlayerDataManager.Server.new(PPM) PlayerProfileManager The ServerPlayerDataManager requires a PlayerProfileManager instance in order to properly function. You must provide a PlayerProfileManager instance before you call the :Start method. Optimally you should provide it during the constructor phase.  "},{"title":"OnReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#OnReady","content":"&lt;/&gt; ServerPlayerDataManager:OnReady(player: Player ) → Promise Promise that resolves when the player's data is ready to be used.  "},{"title":"IsReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#IsReady","content":"&lt;/&gt; ServerPlayerDataManager:IsReady(player: Player ) → boolean Checks whether or not a given player's data is ready  "},{"title":"PromiseManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#PromiseManager","content":"&lt;/&gt; ServerPlayerDataManager:PromiseManager( player: Player , managerName: string? ) → Promise Promises a TableManager for a given player. If a managerName is not specified then it will assume the default one. ServerPlayerDataManager:PromiseManager(Players.Raildex, &quot;Settings&quot;):andThen(function(manager) manager:Set(&quot;Volume&quot;, 0.5) end)   "},{"title":"GetReplicator​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#GetReplicator","content":"&lt;/&gt; ServerPlayerDataManager:GetReplicator( player: Player , replicatorName: string? ) → TableReplicator? Returns the TableReplicator for a given player. If a replicatorName is not specified then it will assume the default one. local replicator = ServerPlayerDataManager:GetReplicator(Players.Raildex, &quot;Settings&quot;)   "},{"title":"RegisterManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#RegisterManager","content":"&lt;/&gt; ServerPlayerDataManager:RegisterManager(config: { Name: string, GetData: ( player: Player , profile: Profile ) → table, } | string) → () Registers a config table for new managers to use for construction. Modifying the given table DO NOT MODIFY THE TABLE AFTER PASSING IT. Treat it as frozen. Doing so can cause potential desyncs between players.  "},{"title":"Start​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#Start","content":"&lt;/&gt; ServerPlayerDataManager:Start(ppm: PlayerProfileManager?) → () Starts the service and sets up all the Player's data managers. local PlayerDataManager = PlayerDataManager.Server.new() local PPM = PlayerProfileManager.new() PlayerDataManager:Start(PPM)  "},{"title":"ProbabilityDistributor","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ProbabilityDistributor","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#types","content":" "},{"title":"Weight​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Weight","content":"&lt;/&gt; type Weight = number | NumberRange | () → (number | NumberRange ) A valid input for the weight of an item in the WeightsTable. Allows for functions to be passed in to generate a weight on the fly. If a NumberRange is given in, it will generate a random INTEGER between the min and max values of the Range.  "},{"title":"WeightedItem<T>​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#WeightedItem<T>","content":"&lt;/&gt; interface WeightedItem&lt;T&gt; { Weight: Weight Value: T } The format weights and an associated value must be in.  "},{"title":"WeightedArray<T>​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#WeightedArray<T>","content":"&lt;/&gt; type WeightedArray&lt;T&gt; = {WeightedItem&lt;T&gt;} A valid input for the WeightsTable. "},{"title":"Functions​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#new","content":"&lt;/&gt; ProbabilityDistributor.new( weights: {WeightedItem&lt;T&gt;},-- A table of weights to distribute. randomOrSeed: (Random | number)?-- An optional random number generator to use for the rolls. If a number is passed, it will be used as the seed for a new random number generator. If nothing is passed, it will create a new Random and use the current time as the seed. ) → ProbabilityDistributor&lt;T&gt;-- A new probability distributor of type T. Where T is the type of the value of the weighted item. Constructs a new ProbabilityDistributor  "},{"title":"Roll​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Roll","content":"&lt;/&gt; ProbabilityDistributor:Roll( luck: number?-- [Optional] A number between 0 and 1 that determines how lucky the roll is. The number acts as a chance that it rerolls the item for a better version. 'Better'ness is determined by the initial order of the weights table. ) → T-- The value of the item that was rolled. Rolls the probability distributor for a weighted item.  "},{"title":"Clone​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Clone","content":"&lt;/&gt; ProbabilityDistributor:Clone() → ProbabilityDistributor&lt;T&gt;-- A new probability distributor of type T. Where T is the type of the value of the weighted item. Clones the probability distributor.  "},{"title":"Sample​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Sample","content":"&lt;/&gt; ProbabilityDistributor:Sample( numOfSamples: number?,-- The number of samples to take. Defaults to 10,000. luck: number?-- The luck to use for the rolls. Defaults to 0. ) → {[T]: number}-- A table of the items that were rolled and how many times they were rolled. Samples the probability distributor to show the distribution of the rolls. "},{"title":"ServerNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerNetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ServerNetWire.ClassName: &quot;ServerNetWire&quot;  "},{"title":"Functions​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#new","content":"constructor static &lt;/&gt; ServerNetWire.new(nameSpace: string | Service) → () Constructs a new ServerNetWire. If a ServerNetWire with the same nameSpace already exists, it will be returned instead.  "},{"title":"setupServiceNetworking​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#setupServiceNetworking","content":"constructor static &lt;/&gt; ServerNetWire.setupServiceNetworking(service: Service) → ServerNetWire Creates a ServerNetWire from a Roam Service. This method will read the service's Name and Client table to create the NetWire. The goal of this function is to recreate the simplicity of Knit's networking features without the systems being coupled together. In order to access the service on the client, use NetWire.Client(&quot;SERVICE_NAME&quot;). local ExampleService = Roam.createService { Name = &quot;ExampleService&quot; } ExampleService.Client = { TestEvent = NetWire.createEvent() } function ExampleService.Client:Greeting(plr: Player, msg: string) print(plr.Name, &quot;said&quot;, msg) end ---------------------------------------------------------------- function ExampleService:RoamInit() NetWire.Server.setupServiceNetworking(self) end function ExampleService:RoamStart() self.Client.TestEvent:FireAll(&quot;Hello from ExampleService!&quot;) -- send a message to all clients end Client Table Overwrite Calling this function will overwrite the service's Client table with the NetWire. You should not store anything aside from supported NetWire objects in the Client table. Where to call This function should be called within the init method of the service. This is to prevent netwires from being created outside of a running game.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#Destroy","content":"destructor &lt;/&gt; ServerNetWire:Destroy() → () Destroys the NetWire and removes it from the internal cache.  "},{"title":"RegisterEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterEvent","content":"&lt;/&gt; ServerNetWire:RegisterEvent(eventName: string) → () Creates a remote event with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteSignal Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteSignal -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestEvent = NetWire.createEvent() myWire.TestEvent:Connect(function(plr: Player, someArg) print(someArg) end) myWire.TestEvent:FireAll(&quot;Hello from the server!&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire.TestEvent:Connect(function(someArg) print(someArg) end) myWire.TestEvent:Fire(&quot;Hello from the client!&quot;)   "},{"title":"RegisterProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterProperty","content":"&lt;/&gt; ServerNetWire:RegisterProperty( propertyName: string, initialValue: any? ) → () Creates a remote property with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteProperty Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteProperty -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestProperty = NetWire.createProperty(&quot;Hello&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) if myWire.TestProperty:IsReady() then -- Check if its ready first print( myWire.TestProperty:Get() ) -- &quot;Hello&quot; end   "},{"title":"RegisterMethod​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterMethod","content":"&lt;/&gt; ServerNetWire:RegisterMethod( functionName: string, callback: ( self: any, plr: Player , ...any ) → (...any), tbl: {}? ) → () Creates a remote function with the given name. This is not suggested to be used by end users; instead you should just append a function to a netwire object and it will properly wrap it for you. -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) function myWire:TestMethod(plr: Player, arg: number) return arg * 2 end --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire:TestMethod(5):andThen(function(result) print(result) -- 10 end)  "},{"title":"ServerTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#types","content":" "},{"title":"ClassToken​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ClassToken","content":"&lt;/&gt; type ClassToken = {Name: string} A unique symbol that identifies the STR Class. This is used to identify the STR Class when it is replicated to the client. Use .newClassToken to generate an object of this type. Do NOT manually create the table.  "},{"title":"ReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicationTargets","content":"&lt;/&gt; type ReplicationTargets = &quot;All&quot; | Player | {Player } The Player(s) that the STR should replicate to. If &quot;All&quot; is given then the STR will replicate to all current and future players. "},{"title":"Properties​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#properties","content":" "},{"title":"AddedActivePlayer​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#AddedActivePlayer","content":"&lt;/&gt; ServerTableReplicator.AddedActivePlayer: Signal&lt;Player &gt; A signal that fires whenever a player starts being replicated to. This happens when their client requests the current data from the server.  "},{"title":"All​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#All","content":"&lt;/&gt; ServerTableReplicator.All: ServerTableReplicator A STR that replicates to all current and future players. Used as a global parent for child STRs that need a home and should be replicated to all current and future players. Do not modify anything about this STR, only use it as a Parent.  "},{"title":"None​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#None","content":"&lt;/&gt; ServerTableReplicator.None: ServerTableReplicator A STR that doesnt replicate to anyone. Used as a global parent for child STRs that shouldnt be replicated. Do not modify anything about this STR, only use it as a Parent. "},{"title":"Functions​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#functions","content":" "},{"title":"newClassToken​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#newClassToken","content":"&lt;/&gt; ServerTableReplicator.newClassToken(tokenName: string) → ClassToken Returns a ClassToken Symbol that is used for identifying the STR Class. We use unique symbols instead of strings to prevent accidental collisions. warning This may only be called once per unique string. The returned symbol should be used repeatedly instead of calling this function again. Calling this function again with the same string will result in an error.  "},{"title":"new​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#new","content":"&lt;/&gt; ServerTableReplicator.new(config: { ClassToken: ClassToken, TableManager: TableManager, ReplicationTargets: ReplicationTargets?, Parent: ServerTableReplicator?, Tags: {[string]: any}?, Client: {[string]: any}?, }) → () Creates a new ServerTableReplicator instance. The config must be given a TableManager instance and a ClassToken Symbol. A list of replication targets can be provided to specify which players the STR should replicate to immediately. If no replication targets are specified, the STR will not replicate to any players. You can specify a Parent STR instead of giving ReplicationTargets and it will inherit the replication targets of the top level STR. Optionally, a list of tags can be provided to help identify the STR. The tags list will become immutable internally after the STR is created. EXAMPLE: -- Some Server Script local token = ServerTableReplicator.newClassToken(&quot;PlayerData&quot;) Players.PlayerAdded:Connect(function(player) local manager = TableManager.new({ Money = math.random(1, 100); }) local replicator = ServerTableReplicator.new({ TableManager = manager, ClassToken = token, ReplicationTargets = &quot;All&quot;, Tags = {UserId = player.UserId}, }) end) -- Some Client Script ClientTableReplicator.listenToNewReplicator(&quot;PlayerData&quot;, function(replicator) print(&quot;New PlayerData STR: &quot;, replicator:GetTag(&quot;UserId&quot;)) print(&quot;Money: &quot;, replicator:GetTableManager():Get(&quot;Money&quot;)) end) Top Level Replicators A replicator must be given either a Parent Replicator or a list of ReplicationTargets. If both are given then it will produce an error. If you give ReplicationTargets then that Replicator will be known as TopLevel. Only TopLevel Replicators can have their ReplicationTargets manually changed. If a Parent Replicator is given, the Child Replicator will inherit the replication targets of the Ancestor TopLevel Replicator.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Destroy","content":"&lt;/&gt; ServerTableReplicator:Destroy() → () Destroys the Replicator on both the Server and any replicated Clients  "},{"title":"IsReplicatingToAll​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsReplicatingToAll","content":"&lt;/&gt; ServerTableReplicator:IsReplicatingToAll() → boolean Returns whether or not this STR is replicating to all current and future players.  "},{"title":"IsReplicationTarget​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsReplicationTarget","content":"&lt;/&gt; ServerTableReplicator:IsReplicationTarget(player: Player ) → boolean Checks whether the player is a valid target for replication. Not whether the player is currently being replicated to.  "},{"title":"GetReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetReplicationTargets","content":"&lt;/&gt; ServerTableReplicator:GetReplicationTargets() → {Player } Gets the list of Players that this Replicator is attempting to replicate to.  "},{"title":"GetActiveReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetActiveReplicationTargets","content":"&lt;/&gt; ServerTableReplicator:GetActiveReplicationTargets() → {Player } Gets the list of Players that this Replicator is currently replicating to. This is different from GetReplicationTargets as it does not include pending replication targets.  "},{"title":"SetParent​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetParent","content":"&lt;/&gt; ServerTableReplicator:SetParent(newParent: ServerTableReplicator) → () Sets the Parent of this STR to the given STR.  "},{"title":"DestroyFor​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#DestroyFor","content":"&lt;/&gt; ServerTableReplicator:DestroyFor(targets: ReplicationTargets) → () Removes a player or list of players from the replication targets.  "},{"title":"ReplicateFor​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicateFor","content":"&lt;/&gt; ServerTableReplicator:ReplicateFor(targets: ReplicationTargets) → () Adds a player or list of players to the replication targets.  "},{"title":"SetReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetReplicationTargets","content":"&lt;/&gt; ServerTableReplicator:SetReplicationTargets(targets: ReplicationTargets) → () Overwrites the current replication targets with the new targets. "},{"title":"Roam","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Roam","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#types","content":" "},{"title":"ServiceConfig​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#ServiceConfig","content":"&lt;/&gt; interface ServiceConfig { Name: string-- Name of the Service. Must be unique. Used when accessing via .getService RequiredServices: {Service}?-- The Services that this Service depends on. Roam will ensure that these Services are initialized before this Service. StartMethodName: string?-- Overrides default StartMethodName of &quot;RoamStart&quot; InitMethodName: string?-- Overrides default InitMethodName of &quot;RoamInit&quot; } local myOtherService = require(ReplicatedStorage.MyOtherService) local MyService = Roam.createService { Name = &quot;MyService&quot;, RequiredServices = {myOtherService}, } Deffering RequiredServices Do NOT add services to the RequiredServices after you have created or registered the service. This will cause undefined behavior. "},{"title":"Properties​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#ClassName","content":"&lt;/&gt; Roam.ClassName: &quot;Roam&quot; The ClassName of the Roam module.  "},{"title":"Debug​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#Debug","content":"&lt;/&gt; Roam.Debug: boolean Whether or not to print debug messages. Default is false.  "},{"title":"Bootstrappers​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#Bootstrappers","content":"&lt;/&gt; Roam.Bootstrappers: { Server: (script: Script ) → (), Client: (script: Script ) → () } A table of generic bootstrappers for Roam / Orion. "},{"title":"Functions​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#functions","content":" "},{"title":"createService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#createService","content":"&lt;/&gt; Roam.createService(serviceDef: ServiceConfig) → Service Creates a Service/Table with Roam to be Initialized and Started when Roam starts. Cannot be called after Roam has been started. local Roam = require(ReplicatedStorage.Roam) local MyService = Roam.createService { Name = &quot;MyService&quot; } function MyService:DoSomething() print(&quot;yeee haw!&quot;) end -- Default StartMethodName is &quot;RoamStart&quot; (Can be overriden in service creation config) function MyService:RoamStart() print(&quot;MyService started!&quot;) self:DoSomething() end -- Default InitMethodName is &quot;RoamInit&quot; (Can be overriden in service creation config) function MyService:RoamInit() print(&quot;MyService initialized!&quot;) end return MyService   "},{"title":"registerService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#registerService","content":"&lt;/&gt; Roam.registerService( service: Service, serviceConfig: (ServiceConfig | string)? ) → Service Registers a Service/Table with Roam to be Initialized and Started when Roam starts. Cannot be called after Roam has been started. This method was added to allow for easy backporting of existing services to Roam. This is an alternative method to setting up services over using createService. local MyRegisteredService = {} function MyRegisteredService:Start() print(&quot;MyRegisteredService started!&quot;) end function MyRegisteredService:Init() print(&quot;MyRegisteredService initialized!&quot;) end local Roam = require(Packages.Roam) Roam.registerService(MyRegisteredService, &quot;MyRegisteredService&quot;) return MyRegisteredService   "},{"title":"requireModules​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#requireModules","content":"&lt;/&gt; Roam.requireModules( parents: Instance | {Instance }, config: { DeepSearch: boolean?, RequirePredicate: ((obj: ModuleScript ) → boolean)?, IgnoreDescendantsPredicate: ((obj: Instance ) → boolean)?, }? ) → {Service} Requires all the modules that are children of the given parent. This is an easy way to quickly load all services that might be in a folder. Takes an optional predicate function to filter which modules are loaded. Services collected this way must not yield. DeepSearch -&gt; whether it checks descendants or just children RequirePredicate -&gt; a predicate function that determines whether a module should be required IgnoreDescendantsPredicate -&gt; A Predicate for whether the Descendants of the Module should be Searched (Only matters if DeepSearch is true) local pred = function(obj: ModuleScript): boolean return obj.Name:match(&quot;Service$&quot;) ~= nil end Roam.requireModules(ReplicatedStorage.Shared, { DeepSearch = true, RequirePredicate = pred, IgnoreDescendantsPredicate = function(obj: Instance): boolean return obj.Name == &quot;Ignore&quot; end, })   "},{"title":"getNameFromService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#getNameFromService","content":"&lt;/&gt; Roam.getNameFromService(service: Service) → string Fetches the name of a registered Service.  "},{"title":"getService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#getService","content":"&lt;/&gt; Roam.getService(serviceName: string) → Service Fetches a registered Service by name. Cannot be called until Roam has been started.  "},{"title":"start​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#start","content":"&lt;/&gt; Roam.start(postInitPreStart: (() → (Promise?))?) → Promise Starts Roam. Should only be called once. Optional argument postInitPreStart is a function that is called after all services have been initialized, but before they are started. caution Be sure that all services have been created before calling Start. Services cannot be added later. Roam.start() :andThenCall(print, &quot;Roam started!&quot;) :catch(warn)   "},{"title":"onStart​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#onStart","content":"&lt;/&gt; Roam.onStart() → Promise Returns a promise that is resolved once Roam has started. This is useful for any code that needs to tie into Roam services but is not the script that called Start. Roam.onStart():andThen(function() local MyService = Roam.Services.MyService MyService:DoSomething() end):catch(warn)   "},{"title":"isReady​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#isReady","content":"&lt;/&gt; Roam.isReady() → boolean Returns whether or not Roam has been successfully started and is ready for external access. "},{"title":"TableState","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableState","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#new","content":"&lt;/&gt; TableState.new( manager: TableManager, Path: Path ) → TableState Creates a new TableState. This is used to observe and modify values in a TableManager easier. Equivalent to tblMngr:ToState(Path) local tbl = { Coins = 0; Inventory = { &quot;Sword&quot;; &quot;Shield&quot;; }; } local tblMngr = TableManager.new(tbl) local coinsState = TableState.new(tblMngr, &quot;Coins&quot;) print( coinsState == tblMngr:ToTableState(&quot;Coins&quot;) ) -- true coinsState:Set(100) -- equivalent to `tblMngr:SetValue(&quot;Coins&quot;, 100)` local inventoryState = TableState.new(tblMngr, &quot;Inventory&quot;) inventoryState:Insert(&quot;Potion&quot;) -- equivalent to `tblMngr:ArrayInsert(&quot;Inventory&quot;, &quot;Potion&quot;)` States with array values You should avoid setting states to be a particular index in array because if the array is shifted then the state can potentially be pointing to the wrong value.  "},{"title":"Set​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Set","content":"&lt;/&gt; TableState:Set(...: any) → () Sets the value this state is associated with. :Set(999) -- Sets the value itself to 999 :Set(1, 999) -- Sets the value at index 1 to 999 (State must be an array)   "},{"title":"Get​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Get","content":"&lt;/&gt; TableState:Get(index: number?) → any Gets the value this state is associated with. Takes an optional argument to specify the index of the array to get. :Get() -- Gets the value itself :Get(1) -- Gets the value at index 1 of the state (State must be an array) (Equivalent to :Get()[1])   "},{"title":"Increment​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Increment","content":"&lt;/&gt; TableState:Increment(...: any) → any Increments the value this state is associated with. :Increment(999) -- Increments the value itself by 999 :Increment(1, 999) -- Increments the value at index 1 by 999 (State must be an array)   "},{"title":"Insert​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Insert","content":"&lt;/&gt; TableState:Insert(...: any) → () Inserts a value into the array this state is associated with. :Insert(999) -- Appends 999 onto the array :Insert(5, 999) -- Inserts 999 at index 5 of the array   "},{"title":"Remove​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Remove","content":"&lt;/&gt; TableState:Remove(index: number) → any-- The removed value. Removes the value at the given index from the array this state is associated with.  "},{"title":"RemoveFirstValue​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#RemoveFirstValue","content":"&lt;/&gt; TableState:RemoveFirstValue(valueToFind: any) → number-- The index of the removed value. Removes the first value that matches the given value from the array this state is associated with.  "},{"title":"Observe​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Observe","content":"&lt;/&gt; TableState:Observe(fn: (new: any) → ()) → () → () Observes changes to the value this state is associated with. Also fires immediately. See TableManager:Observe for more information. "},{"title":"TableManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#types","content":" "},{"title":"CanBeArray<T>​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#CanBeArray<T>","content":"&lt;/&gt; type CanBeArray&lt;T&gt; = T | {T} A type that could be an individual of the type or an array of the type.  "},{"title":"Path​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Path","content":"&lt;/&gt; type Path = string | {any} A path to a value in a table. Can be written as a string in dot format or an array of strings. :::Note The array format is faster to parse and should be used when possible. ::: local tbl = { MyPath = { To = { Value = 0; }; }; } local path1: Path = &quot;MyPath.To.Value&quot; -- Style 1 local path2: Path = {&quot;MyPath&quot;, &quot;To&quot;, &quot;Value&quot;} -- Style 2   "},{"title":"ValueListenerFn​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ValueListenerFn","content":"&lt;/&gt; type ValueListenerFn = ( newValue: any, oldValue: any?, changeMetadata: ChangeMetadata? ) → ()   "},{"title":"ListenerType​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenerType","content":"&lt;/&gt; type ListenerType = &quot;ValueChanged&quot; | &quot;ArraySet&quot; | &quot;ArrayInsert&quot; | &quot;ArrayRemove&quot; This information is mostly for internal use.  "},{"title":"DataChangeSource​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#DataChangeSource","content":"&lt;/&gt; type DataChangeSource = &quot;self&quot; | &quot;child&quot; | &quot;parent&quot; This information is mostly for internal use.  "},{"title":"ChangeMetadata​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ChangeMetadata","content":"&lt;/&gt; interface ChangeMetadata { ListenerType: ListenerType-- The listener type that was fired. SourceDirection: DataChangeSource-- The source direction of the change. SourcePath: {string}-- The origin path of the change. NewValue: any?-- [Only for value changes] The new value. OldValue: any?-- [Only for value changes] The old value. } Metadata about the change that fired a listener. Used to provide more context to listeners. Allows you to figure out where the change came from, if it wasnt a direct change. "},{"title":"Properties​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Enums","content":"&lt;/&gt; TableManager.Enums: { ListenerType: ListenerTypeEnum, DataChangeSource: DataChangeSourceEnum } A collection of enums used by the TableManager. "},{"title":"Functions​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#new","content":"Constructor &lt;/&gt; TableManager.new(data: table?) → TableManager Creates a new TableManager. Takes a table to manage, if one is not given then it will construct an empty table. Modifying the given table Once you give a table to a TableManager, you should never modify it directly. Doing so can result in the TableManager being unable to properly track changes and potentially cause data desyncs. Key/Value Rules The given table's keys should follow these rules: No Mixed Tables (Tables containing keys of different datatypes) Avoid using tables as keys. Keys must not contain periods. Keys must not be empty strings. Tables/Arrays should be assigned to only one key. (No shared references as this can cause desyncs) Nested tables/arrays should not be given to other TableManager instances. (Can cause desyncs) info Only one TableManager should be created for a given table. Attempting to create a TableManager for a table that is already being managed will return the existing TableManager. Call metamethod You can call the TableManager class to create a new instance of it. TableManager() is equivalent to TableManager.new(). local tbl = { Coins = 0; Inventory = { &quot;Sword&quot;; &quot;Shield&quot;; }; } local tblMngr = TableManager.new(tbl) tblMngr:SetValue(&quot;Coins&quot;, 100) tblMngr:IncrementValue(&quot;Coins&quot;, 55) print(tblMngr:Get(&quot;Coins&quot;)) -- 155 tblMngr:ArrayInsert(&quot;Inventory&quot;, &quot;Potion&quot;) tblMngr:ArrayInsert(&quot;Inventory&quot;, 2, &quot;Bow&quot;) print(tblMngr:Get(&quot;Inventory&quot;)) -- {&quot;Sword&quot;, &quot;Bow&quot;, &quot;Shield&quot;, &quot;Potion&quot;}   "},{"title":"Destroy​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Destroy","content":"&lt;/&gt; TableManager:Destroy() → () Disconnects any listeners and removes the table from the managed tables.  "},{"title":"Set​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Set","content":"&lt;/&gt; TableManager:Set( path: Path, ...: any ) → () Sets the value at the given path to the given value. :Set acts as a combined function for :SetValue and :ArraySet. :Set(myPathToValue, newValue) :Set(myPathToArray, index, newValue) Overwriting the root table Overwriting the root table is not recommended, but is technically possible by giving an empty table or string as a Path. Doing so has not been tested in depth and may result in unintended behavior. Setting array values You cannot set values to nil in an array with this method due to the way it parses args. Use ArraySet instead if you need to set values to nil.  "},{"title":"Increment​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Increment","content":"&lt;/&gt; TableManager:Increment( path: Path, ...: any ) → number? Increments the value at the given path by the given amount. If the value is not a number, it will throw an error. :Increment acts as a combined function for :IncrementValue and :ArrayIncrement. :Increment(myPathToValue, amountToIncrementBy) :Increment(myPathToArray, index, amountToIncrementBy)   "},{"title":"Update​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Update","content":"&lt;/&gt; TableManager:Update( path: Path, ...: any ) → any? Mutates the value at the given path by calling the given function with the current value. :Update(myPathToValue, function(currentValue) return currentValue + 1 end) Aliases :Mutate is an alias for :Update. This alias is consistent with all other 'Update' methods.  "},{"title":"SetValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetValue","content":"&lt;/&gt; TableManager:SetValue( path: Path, value: any ) → boolean Sets the value at the given path to the given value. This will fire the ValueChanged signal if the value is different. Returns a boolean indicating whether or not the value was changed. local didChange = manager:SetValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"IncrementValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#IncrementValue","content":"&lt;/&gt; TableManager:IncrementValue( path: Path, amount: Numeric ) → number Increments the value at the given path by the given amount. If the value at the path or the given amount is not a number, it will throw an error. Returns the newly incremeneted value. local newValue = manager:IncrementValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"UpdateValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#UpdateValue","content":"&lt;/&gt; TableManager:UpdateValue( path: Path, fn: (currentValue: any) → (any) ) → any Mutates the value at the given path by calling the given function with the current value. The function should return the new value. manager:SetValue(&quot;MyPath.To.Value&quot;, &quot;Hello World&quot;) local newValue = manager:UpdateValue(&quot;MyPath.To.Value&quot;, function(currentValue) return string.upper(currentValue) .. &quot;!&quot; end) print(newValue) -- HELLO WORLD! print(manager:GetValue(&quot;MyPath.To.Value&quot;)) -- HELLO WORLD!   "},{"title":"SetManyValues​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetManyValues","content":"&lt;/&gt; TableManager:SetManyValues( path: Path, valueDict: {[any]: any} ) → () Sets the values at the given path to the given values. This will fire the ValueChanged listener for each value that is different. caution Uses pairs to check through the given table and thus Does not support setting values to nil. local manager = TableManager.new({ Foo = { Bar = { Value1 = 0; Value2 = 0; Value3 = 0; }; }; }) manager:SetManyValues(&quot;Foo.Bar&quot;, { Value1 = 100; Value3 = 300; })   "},{"title":"ArrayUpdate​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayUpdate","content":"&lt;/&gt; TableManager:ArrayUpdate( path: Path,-- The path to the array to mutate. index: number | {number} | &quot;#&quot;,-- The index or indices to mutate. If &quot;#&quot; is given, it will mutate all indices. fn: (currentValue: any) → (any)-- The function to call with the current value. Should return the new value. ) → () Mutates an index or indices in the array at the given path by calling the given function with the current value. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayUpdate(&quot;MyArray&quot;, 3, function(currentValue) return currentValue * 2 }) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 6, 4, 5}   "},{"title":"ArrayIncrement​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayIncrement","content":"&lt;/&gt; TableManager:ArrayIncrement( path: Path,-- The path to the array to increment. index: number | {number},-- The index or indices to increment. amount: number?-- The amount to increment by. If not given, it will increment by 1. ) → () Increments the indices at the given path by the given amount. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayIncrement(&quot;MyArray&quot;, 3, 10) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 13, 4, 5}   "},{"title":"ArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArraySet","content":"&lt;/&gt; TableManager:ArraySet( path: Path, index: (CanBeArray&lt;number&gt; | '#')?, value: any ) → () Sets the value at the given index in the array at the given path. The index can be a number or an array of numbers. If an array is given then the value will be set at each of those indices in the array.  "},{"title":"ArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayInsert","content":"&lt;/&gt; TableManager:ArrayInsert( path: Path, ...: any ) → () Inserts the given value into the array at the given path at the given index. If no index is given, it will insert at the end of the array. This follows the convention of table.insert where the index is given in the middle only if there are 3 args. x:ArrayInsert(&quot;MyArray&quot;, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at index 1 x:ArrayInsert(&quot;MyArray&quot;, 1) -- appends 1 to the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, 2) -- Inserts 2 at index 1   "},{"title":"ArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemove","content":"&lt;/&gt; TableManager:ArrayRemove( path: Path, index: number? ) → any Removes the value at the given index from the array at the given path. If no index is given, it will remove the last value in the array. Returns the value that was removed if one was.  "},{"title":"ArrayRemoveFirstValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemoveFirstValue","content":"&lt;/&gt; TableManager:ArrayRemoveFirstValue( path: Path, value: any ) → number? Removes the first instance of the given value from the array at the given path. Returns a number indicating the index that it was was removed from if one was.  "},{"title":"Get​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Get","content":"&lt;/&gt; TableManager:Get( path: Path, idx: (number | string)? ) → any Fetches the value at the given path. Accepts a string path or an array path. Accepts an optional secondary argument to fetch a value at an index in an array. Aliases: GetValue local manager = TableManager.new({ Currency = { Coins = 100; Gems = 10; }; }) -- The following are all equivalent acceptable methods of fetching the value. print(manager:Get(&quot;Currency.Coins&quot;)) -- 100 print(manager:Get({&quot;Currency&quot;, &quot;Coins&quot;})) -- 100 print(manager:Get().Currency.Coins) -- 100 Getting the Root Table Calling :Get() with no arguments, an empty string, or an empty table will return the root table.  "},{"title":"ToTableState​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ToTableState","content":"&lt;/&gt; TableManager:ToTableState(path: Path) → TableState Returns a TableState Object for the given path. warning This method is not feature complete and does not work for all edge cases and should be used with caution. local path = &quot;MyPath.To.Value&quot; local state = manager:ToTableState(path) state:Set(100) manager:Increment(path, 50) state:Increment(25) print(state:Get()) -- 175   "},{"title":"ToFusionState​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ToFusionState","content":"&lt;/&gt; TableManager:ToFusionState(path: Path) → FusionState&lt;any&gt; Returns a Fusion State object that is bound to the value at the given path. This method is memoized so calling it repeatedly with the same path will return the same State object and quickly. Deffered Signals The value of the Fusion State object is updated via the ValueChanged listener and thus may be deffered if your signals are deffered. Setting Although this currently returns a Fusion Value object, it is not recommended to set the value as this may be a Computed in the future. Setting the state will not actually change the value in the TableManager. local path = &quot;MyPath.To.Value&quot; manager:SetValue(path, 100) local state = manager:ToFusionState(path) print(peek(state)) -- 100 manager:SetValue(path, 200) task.wait() -- If your signals are deffered then the state will update on the next frame print(peek(state)) -- 200   "},{"title":"PromiseValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#PromiseValue","content":"&lt;/&gt; TableManager:PromiseValue( path: Path, condition: (value: any?) → (boolean) ) → Promise Creates a promise that resolves when the given condition is met. The condition is immediately and every time the value changes. If no condition is given then it will resolve with the current value unless it is nil, in which case it will resolve on the first change.  "},{"title":"Observe​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Observe","content":"&lt;/&gt; TableManager:Observe( path: Path,-- The path to the value to observe. fn: ValueListenerFn,-- The function to call when the value changes. runOnNil: boolean?-- Whether or not to fire the function when the value is nil. ) → Connection-- A connection used to disconnect the listener. Observes a value at a path and calls the function immediately with the current value, as well as when it changes. Listening to nil values It will NOT fire if the new/starting value is nil, unless runOnNil is true. When it changes from nil, the oldValue will be the last known non nil value. The binding call of the function is an exception and will give nil as the oldValue. This is done so that Observe can be used to execute instructions when a value is percieved as 'ready'. local path = &quot;MyPath.To.Value&quot; local connection = manager:Observe(path, function(newValue) print(&quot;Value at&quot;, path, &quot;is&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"ListenToKeyChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToKeyChange","content":"&lt;/&gt; TableManager:ListenToKeyChange( parentPath: Path?, fn: ( keyChanged: any, newValue: any, oldValue: any ) → () ) → () Listens to a change at a specified path and calls the function when the value changes. manager:Set(&quot;Stats&quot;, { Health = 100; Mana = 50; }) local connection = manager:ListenToKeyChange(&quot;Stats&quot;, function(key, newValue) print(`{key} changed to {newValue}`) end) manager:SetValue(&quot;Stats.Health&quot;, 200) -- Health changed to 200 manager:SetValue(&quot;Stats.Mana&quot;, 100) -- Mana changed to 100   "},{"title":"ListenToKeyAdd​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToKeyAdd","content":"&lt;/&gt; TableManager:ListenToKeyAdd( parentPath: Path?, fn: ( newKey: any, newValue: any ) → () ) → Connection Listens to when a new key is added (Changed from nil) to a table at a specified path and calls the function.  "},{"title":"ListenToKeyRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToKeyRemove","content":"&lt;/&gt; TableManager:ListenToKeyRemove( parentPath: Path?, fn: ( removedKey: any, lastValue: any ) → () ) → Connection Listens to when a key is removed (Set to nil) from a table at a specified path and calls the function.  "},{"title":"ListenToValueChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToValueChange","content":"&lt;/&gt; TableManager:ListenToValueChange( path: Path, fn: ValueListenerFn ) → Connection Listens to a change at a specified path and calls the function when the value changes. This does NOT fire when the value is an array/dictionary and one of its children changes. local connection = manager:ListenToValueChange(&quot;MyPath.To.Value&quot;, function(newValue, oldValue) print(&quot;Value changed from&quot;, oldValue, &quot;to&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"ListenToArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToArraySet","content":"&lt;/&gt; TableManager:ListenToArraySet( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when an index is set in an array at a specified path and calls the function. The function receives the index and the new value. caution The array listeners do not fire from changes to parent or child values.  "},{"title":"ListenToArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToArrayInsert","content":"&lt;/&gt; TableManager:ListenToArrayInsert( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when a value is inserted into an array at a specified path and calls the function when the value changes.  "},{"title":"ListenToArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToArrayRemove","content":"&lt;/&gt; TableManager:ListenToArrayRemove( path: Path, fn: ( oldIndex: number, oldValue: any ) → () ) → Connection Listens to when a value is removed from an array at a specified path and calls the function. "},{"title":"TableReplicatorSingleton","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableReplicatorSingleton","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#new","content":"&lt;/&gt; TableReplicatorSingleton.new(config: Config) → () "},{"title":"Types","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton##","content":""},{"title":"​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Config","content":"interface Config { ClassTokenName: string-- The name of the class token to listen for. DefaultDataSchema: table?-- The default schema to use if the replicator is not ready yet. ConditionFn: ((replicator: ClientTableReplicator) → boolean)?-- A function that returns whether or not the replicator is valid and should be bound. }  Creates a new TableReplicatorSingleton. local ClientPlayerData = TableReplicatorSingleton.new { ClassTokenName = &quot;PlayerData&quot;; DefaultDataSchema = Import(&quot;PlayerDataSchema&quot;); ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end; } return ClientPlayerData   "},{"title":"Get​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Get","content":"&lt;/&gt; TableReplicatorSingleton:Get( path: Path, index: number? ) → any? Fetches the value at the path. An index can be provided to fetch the value at that index. If the value is not ready yet, it will return the value rom the default schema if one was given. If the path is untraversable, it will return nil. local coins = ClientPlayerData:Get(&quot;Coins&quot;) local thirdItem = ClientPlayerData:Get(&quot;Inventory&quot;, 3) -- Equivalent to `ClientPlayerData:Get(&quot;Inventory&quot;)[3]`   "},{"title":"Observe​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Observe","content":"&lt;/&gt; TableReplicatorSingleton:Observe( path: Path, callback: (newValue: any?) → () ) → () → () Called immediately and then whenever the value at the path changes. The callback will be called with the new value. ClientPlayerData:Observe(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToValueChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToValueChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToValueChange( path: Path, callback: (...any) → () ) → function-- A function that, when called, will disconnect the listener. Called when the value at the path is changed. The callback will be called with the new value. ClientPlayerData:ListenToValueChange(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToAnyChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToAnyChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToAnyChange( path: Path, callback: (...any) → () ) → () → () Called when the value at the path is changed through any means. This includes if the value is an array and a value in the array is changed, inserted, or removed.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ToFusionState","content":"&lt;/&gt; TableReplicatorSingleton:ToFusionState(path: Path) → State&lt;any&gt; Returns a Fusion State object that will automatically update when the value at the path changes. This is useful for when you want to use Fusion dependents to respond to changes in the value. local coinsState = ClientPlayerData:ToFusionState(&quot;Coins&quot;) New &quot;TextLabel&quot; { Text = coinsState; }   "},{"title":"GetTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableManager","content":"&lt;/&gt; TableReplicatorSingleton:GetTableManager() → TableManager Gets the TableManager for the TableReplicatorSingleton. This will error if the TableManager is not ready yet. local TM = ClientPlayerData:GetTableManager()   "},{"title":"GetTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:GetTableReplicator() → ClientTableReplicator Gets the TableReplicator for the TableReplicatorSingleton. This will error if the TableReplicator is not ready yet. local TR = ClientPlayerData:GetTableReplicator()   "},{"title":"PromiseTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableManager","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableManager() → Promise&lt;TableManager&gt; Returns a promise that resolves with the TableManager when it is ready. ClientPlayerData:PromiseTableManager():andThen(function(TM: TableManager) print(&quot;TableManager is ready!&quot;) end)   "},{"title":"PromiseTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableReplicator() → Promise&lt;ClientTableReplicator&gt; Returns a promise that resolves with the TableReplicator when it is ready. ClientPlayerData:PromiseTableReplicator():andThen(function(TR: ClientTableReplicator) print(&quot;TableReplicator is ready!&quot;) end)   "},{"title":"IsReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#IsReady","content":"&lt;/&gt; TableReplicatorSingleton:IsReady() → boolean Returns whether or not a valid Replicator has been found and hooked into. if ClientPlayerData:IsReady() then print(&quot;We have a valid Replicator!&quot;) end   "},{"title":"OnReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#OnReady","content":"&lt;/&gt; TableReplicatorSingleton:OnReady() → Promise&lt;()&gt; Returns a promise that resolves when the TableReplicatorSingleton is ready. ClientPlayerData:OnReady():andThen(function() print(&quot;Found a valid Replicator!&quot;) end)  "}]