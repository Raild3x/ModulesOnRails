[{"title":"ClientNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientNetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ClientNetWire.ClassName: &quot;ClientNetWire&quot;  "},{"title":"Functions​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#new","content":"constructor static &lt;/&gt; ClientNetWire.new(nameSpace: string) → ClientNetWire Creates a new ClientNetWire. If a ClientNetWire with the same nameSpace already exists, it will be returned instead. "},{"title":"ClientTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientTableReplicator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#functions","content":" "},{"title":"fromTemplate​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#fromTemplate","content":"Static &lt;/&gt; ClientTableReplicator.fromTemplate() → () Creates a ReplicatedTableSingleton object from the given template configuration. See TableReplicatorSingleton.new for more information.  "},{"title":"listenForNewReplicator​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#listenForNewReplicator","content":"&lt;/&gt; ClientTableReplicator.listenForNewReplicator( classTokenName: string, fn: (replicator: ClientTableReplicator) → () ) → () → () Listens for a new ClientTableReplicator of the given ClassName.  "},{"title":"requestServerData​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#requestServerData","content":"&lt;/&gt; ClientTableReplicator.requestServerData() → Promise Requests all the existing replicators from the server. This should only be called once, calling it multiple times will return the same promise. All replicator listeners should be registered before calling this method. "},{"title":"NetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/NetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#properties","content":" "},{"title":"Client​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Client","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.Client: ClientNetWire   "},{"title":"Server​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Server","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.Server: ServerNetWire  "},{"title":"Functions​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#functions","content":" "},{"title":"indexReady​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#indexReady","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.indexReady( wireOrName: ClientNetWire | string, idx: string-- The index to wait for existence of ) → Promise Returns a promise that resolves when the ClientNetWire is ready for use and the index exists. The resolved value is the value of the index.  "},{"title":"onReady​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#onReady","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.onReady(clientNetWire: ClientNetWire | string) → Promise Returns a promise that resolves when the ClientNetWire is ready for use.  "},{"title":"isReady​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#isReady","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.isReady(clientNetWire: ClientNetWire | string) → boolean Can be used to check if a clientNetWire is ready for use.  "},{"title":"destroy​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#destroy","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.destroy(clientNetWire: ClientNetWire) → () Destroys a ClientNetWire, removing it from the cache.  "},{"title":"getClient​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#getClient","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.getClient(wireName: string) → ClientNetWire? Returns a ClientNetWire from the cache, if it exists.  "},{"title":"createEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createEvent","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createEvent() → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information.  "},{"title":"createProperty​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createProperty","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createProperty(initialValue: any?) → ServerRemoteProperty Returns an PropertyMarker that is used to mark where a remoteProperty should be created. Calls ServerNetWire:RegisterProperty() when set to the index of a ServerNetWire. See ServerNetWire:RegisterProperty for more information.  "},{"title":"getServer​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#getServer","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.getServer(wireName: string) → ServerNetWire? Returns a ServerNetWire from the cache, if it exists. "},{"title":"ServerNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerNetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ServerNetWire.ClassName: &quot;ServerNetWire&quot;  "},{"title":"Functions​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#new","content":"constructor static &lt;/&gt; ServerNetWire.new(nameSpace: string | Service) → () Constructs a new ServerNetWire. If a ServerNetWire with the same nameSpace already exists, it will be returned instead.  "},{"title":"setupServiceNetworking​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#setupServiceNetworking","content":"constructor static &lt;/&gt; ServerNetWire.setupServiceNetworking(service: Service) → ServerNetWire Creates a ServerNetWire from a Roam Service. This method will read the service's Name and Client table to create the NetWire. The goal of this function is to recreate the simplicity of Knit's networking features without the systems being coupled together. local ExampleService = Roam.createService { Name = &quot;ExampleService&quot; } ExampleService.Client = { TestEvent = NetWire.createEvent() } function ExampleService:RoamInit() NetWire.Server.setupServiceNetworking(self) end Client Table Overwrite Calling this function will overwrite the service's Client table with the NetWire. You should not store anything aside from supported NetWire objects in the Client table. Where to call This function should be called within the init method of the service. This is to prevent netwires from being created outside of a running game.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#Destroy","content":"destructor &lt;/&gt; ServerNetWire:Destroy() → () Destroys the NetWire and removes it from the internal cache.  "},{"title":"RegisterEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterEvent","content":"&lt;/&gt; ServerNetWire:RegisterEvent(eventName: string) → () Creates a remote event with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteSignal Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteSignal -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestEvent = NetWire.createEvent() myWire.TestEvent:Connect(function(plr: Player, someArg) print(someArg) end) myWire.TestEvent:FireAll(&quot;Hello from the server!&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire.TestEvent:Connect(function(someArg) print(someArg) end) myWire.TestEvent:Fire(&quot;Hello from the client!&quot;)   "},{"title":"RegisterProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterProperty","content":"&lt;/&gt; ServerNetWire:RegisterProperty( propertyName: string, initialValue: any? ) → () Creates a remote property with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteProperty Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteProperty -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestProperty = NetWire.createProperty(&quot;Hello&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) if myWire.TestProperty:IsReady() then -- Check if its ready first print( myWire.TestProperty:Get() ) -- &quot;Hello&quot; end   "},{"title":"RegisterMethod​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterMethod","content":"&lt;/&gt; ServerNetWire:RegisterMethod( functionName: string, callback: ( self: any, plr: Player , ...any ) → (...any), tbl: {}? ) → () Creates a remote function with the given name. This is not suggested to be used by end users; instead you should just append a function to a netwire object and it will properly wrap it for you. -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) function myWire:TestMethod(plr: Player, arg: number) return arg * 2 end --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire:TestMethod(5):andThen(function(result) print(result) -- 10 end)  "},{"title":"BaseObject","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseObject","content":"","keywords":""},{"title":"BaseTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#types","content":" "},{"title":"Id​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Id","content":"&lt;/&gt; type Id = number The id of a replicator.  "},{"title":"SearchCondition​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#SearchCondition","content":"&lt;/&gt; type SearchCondition = string | ClassToken | Tags | ( replicator: BaseTableReplicator, manager: TableManager? ) → (boolean) A condition that can be used to filter replicators. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If the condition is a function then it should return a boolean to indicate success. If the condition is a ClassToken then it will check if the replicator's class token matches the given token. If the condition is a string then it will check if the replicator's class token name matches the given string. If the condition is a Tags dictionary then it will check if the replicator's tags are a superset of the given tags.  "},{"title":"Tags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Tags","content":"&lt;/&gt; type Tags = {[string]: any} The valid tag format that can be given to a TableReplicator. This table will become locked once given to a TableReplicator. Do not attempt to modify it after the fact. local tags = table.freeze { OwnerId = Player.UserId; ToolType = &quot;Sword&quot;; }  "},{"title":"Properties​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#properties","content":" "},{"title":"ReplicatorCreated​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#ReplicatorCreated","content":"&lt;/&gt; BaseTableReplicator.ReplicatorCreated: Signal&lt;BaseTableReplicator&gt; A signal that fires whenever a new replicator is created. "},{"title":"Functions​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#functions","content":" "},{"title":"iterating over BaseTableReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#__iter","content":"Metamethod &lt;/&gt; for in BaseTableReplicator do Iterates over all replicators that are currently in memory. for _, replicator in TableReplicator do print(replicator:GetServerId()) end   "},{"title":"getFromServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getFromServerId","content":"Static &lt;/&gt; BaseTableReplicator.getFromServerId(id: Id) → BaseTableReplicator? Returns the replicator with the given id if one exists.  "},{"title":"forEach​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#forEach","content":"Static &lt;/&gt; BaseTableReplicator.forEach( condition: SearchCondition, fn: ( replicator: BaseTableReplicator, manager: TableManager? ) → (), allowDestroyedReplicators: boolean? ) → () forEach is a special function that allows you to run a function on all replicators that currently exist or will exist that match the given condition. caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned.  "},{"title":"promiseFirstReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#promiseFirstReplicator","content":"Static &lt;/&gt; BaseTableReplicator.promiseFirstReplicator( condition: SearchCondition, allowDestroyedReplicators: boolean? ) → Promise&lt;BaseTableReplicator,TableManager?&gt; promiseFirstReplicator is a special function that allows you to run a function on the first replicator to satisfy the given condition. If no replicator currently exists that satisfies the condition then it will wait for one to be created. caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned. BaseTableReplicator.promiseFirstReplicator(&quot;Test&quot;)   "},{"title":"getAll​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getAll","content":"Static &lt;/&gt; BaseTableReplicator.getAll(classTokenName: string?) → {BaseTableReplicator} Fetches all replicators that are currently in memory. This is very slow and should be used sparingly.  "},{"title":"listenForNewReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#listenForNewReplicator","content":"Static &lt;/&gt; BaseTableReplicator.listenForNewReplicator( classToken: CanBeArray&lt;string | ClassToken&gt;, fn: (replicator: BaseTableReplicator) → () ) → () → () Listens for new replicators that are created with the given class token.  "},{"title":"GetTableManager​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTableManager","content":"&lt;/&gt; BaseTableReplicator:GetTableManager() → TableManager Gets the TableManager that is being replicated.  "},{"title":"GetServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetServerId","content":"&lt;/&gt; BaseTableReplicator:GetServerId() → Id Returns the server id for this replicator. On the Server this is equivalent to :GetId()  "},{"title":"GetTokenName​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTokenName","content":"&lt;/&gt; BaseTableReplicator:GetTokenName() → string Fetches the name of the class token that this replicator is using.  "},{"title":"IsTopLevel​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsTopLevel","content":"&lt;/&gt; BaseTableReplicator:IsTopLevel() → boolean Returns whether or not this replicator is a top level replicator. A top level replicator is a replicator that has no parent. Only top level replicators can have their ReplicationTargets set.  "},{"title":"GetParent​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetParent","content":"&lt;/&gt; BaseTableReplicator:GetParent() → BaseTableReplicator? Returns the parent of this replicator if it has one. If this replicator is a top level replicator then this will return nil.  "},{"title":"GetChildren​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetChildren","content":"&lt;/&gt; BaseTableReplicator:GetChildren() → {BaseTableReplicator} Returns the immediate children of this replicator.  "},{"title":"GetDescendants​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetDescendants","content":"&lt;/&gt; BaseTableReplicator:GetDescendants() → {BaseTableReplicator} Returns the descendants of this replicator.  "},{"title":"FindFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#FindFirstChild","content":"&lt;/&gt; BaseTableReplicator:FindFirstChild( condition: SearchCondition, recursive: boolean? ) → BaseTableReplicator? Finds the first child that satisfies the given condition. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If recursive is true then it will search through all descendants. local child = tr:FindFirstChild(function(child) local manager = child:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 })   "},{"title":"PromiseFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#PromiseFirstChild","content":"&lt;/&gt; BaseTableReplicator:PromiseFirstChild(condition: SearchCondition) → Promise&lt;BaseTableReplicator&gt; Returns a promise that resolves when the first child that satisfies the given function is found. tr:PromiseFirstChild(function(replicator) local manager = replicator:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 }):andThen(function(replicator) print(&quot;Found child with data key 'Test' equal to 1!&quot;) end) tr:PromiseFirstChild(&quot;Test&quot;):andThen(function(replicator) print(&quot;Found child with classtoken 'Test'!&quot;) end) tr:PromiseFirstChild({UserId == 12345}):andThen(function(replicator) print(&quot;Found child with UserId Tag matching 12345!&quot;) end)   "},{"title":"GetTag​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTag","content":"&lt;/&gt; BaseTableReplicator:GetTag(tagKey: string) → any Returns the value of the given tag for this replicator.  "},{"title":"GetTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTags","content":"&lt;/&gt; BaseTableReplicator:GetTags() → Tags Returns the tags dictionary for this replicator.  "},{"title":"IsSupersetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSupersetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSupersetOfTags(tags: Tags) → boolean Checks whether or not the given tags are a subset of this replicator's tags. ELI5: Are all the given tags also on this replicator? Aliased as :ContainsAllTags(tags) ```lua local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSupersetOfTags({ Test1 = 1, }) -- true tr:IsSupersetOfTags({ Test2 = 2, }) -- true  "},{"title":"IsSubsetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSubsetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSubsetOfTags(tags: Tags) → boolean Checks whether or not this replicator's tags are a subset of the given tags. ELI5: Are all the tags on this replicator also on the given tags? Aliased as :IsWithinTags(tags) local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSubsetOfTags({ Test1 = 1, Test2 = 2, Test3 = 3, }) -- true tr:IsSubsetOfTags({ Test1 = 1, }) -- false  "},{"title":"PlayerProfileManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerProfileManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#types","content":" "},{"title":"DataMigrator​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#DataMigrator","content":"&lt;/&gt; interface DataMigrator { FromVersion: string ToVersion: string Migrate: ( profileData: table, profileOwner: Player ) → (table) }   "},{"title":"PPM_Config​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PPM_Config","content":"&lt;/&gt; interface PPM_Config { DataStoreKey: string DefaultDataSchema: table UseMock: boolean? Migrator: {DataMigrator} GetPlayerKeyCallback: ((player: Player ) → (string))? ReconcileCallback: (( player: Player , profile: Profile ) → ())? OnProfileLoadFailure: (( player: Player , err: string ) → ())? } OnProfileLoadFailure will default to kicking the player if not provided. ReconcileCallback will default to calling Profile:Reconcile if not provided. "},{"title":"Functions​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#new","content":"&lt;/&gt; PlayerProfileManager.new(config: PPM_Config) → PlayerProfileManager Creates a new PlayerProfileManager. This is a singleton class, so calling this function multiple times will return the same instance. Takes a config table with the following fields. PlayerProfileManager.new({ DataStoreKey = &quot;PlayerData&quot;; DefaultDataSchema = { __VERSION = &quot;0.0.0&quot;; Currency = 0; }; })   "},{"title":"IsLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#IsLoaded","content":"&lt;/&gt; PlayerProfileManager:IsLoaded(player: Player ) → boolean Returns whether or not the player's profile is currently loaded. local isLoaded = PlayerProfileManager:IsLoaded(player)   "},{"title":"OnLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#OnLoaded","content":"&lt;/&gt; PlayerProfileManager:OnLoaded(player: Player ) → Promise&lt;()&gt; Returns a promise that will resolve when the player's profile is loaded. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:OnLoaded(player):andThen(function() print(&quot;Profile loaded for &quot; .. player.Name) end)   "},{"title":"GetProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#GetProfile","content":"&lt;/&gt; PlayerProfileManager:GetProfile(player: Player ) → Profile? Returns the player's profile, if it exists. May return nil if this players profile is not loaded. local profile: Profile? = PlayerProfileManager:GetProfile(player)   "},{"title":"PromiseProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PromiseProfile","content":"&lt;/&gt; PlayerProfileManager:PromiseProfile(player: Player ) → Promise&lt;Profile&gt; Returns a promise that resolves with the player's profile when it is ready. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:PromiseProfile(player):andThen(function(profile: Profile) print(&quot;Profile loaded for &quot; .. player.Name) end)  "},{"title":"Types​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#types","content":" "},{"title":"BaseObject​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BaseObject","content":"&lt;/&gt; type BaseObject = BaseObject  "},{"title":"Properties​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; BaseObject.ClassName: string  "},{"title":"Functions​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#functions","content":" "},{"title":"getObjectFromId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#getObjectFromId","content":"static &lt;/&gt; BaseObject.getObjectFromId(id: number) → BaseObject? Fetches the object with the given ID if it exists. local obj = BaseObject.new() local id = obj:GetId() print(BaseObject.getObjectFromId(id) == obj) -- true   "},{"title":"isDestroyed​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#isDestroyed","content":"static &lt;/&gt; BaseObject.isDestroyed(self: BaseObject) → boolean Checks whether or not the object is destroyed. local obj = BaseObject.new() print(BaseObject.isDestroyed(obj)) -- false obj:Destroy() print(BaseObject.isDestroyed(obj)) -- true   "},{"title":"new​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#new","content":"static &lt;/&gt; BaseObject.new( tbl: {[any]: any}?-- Table to construct the BaseObject with ) → BaseObject Constructs a new BaseObject local obj = BaseObject.new({ X = 1, Y = 2, }) obj.Z = 3 print(obj.X, obj.Y, obj.Z) -- 1, 2, 3 local SuperClass = setmetatable({}, BaseObject) SuperClass.__index = SuperClass SuperClass.ClassName = &quot;SuperClass&quot; function SuperClass.new() local self = setmetatable(BaseObject.new(), SuperClass) return self end function SuperClass:Destroy() -- Overwrite the BaseObject Destroy method getmetatable(SuperClass).Destroy(self) -- If you overwrite the BaseObject Destroy method you need to have this line to call the original. end function SuperClass:Print() print(&quot;Hello, World!&quot;) end return SuperClass   "},{"title":"Destroy​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#Destroy","content":"&lt;/&gt; BaseObject:Destroy() → () Marks the Object as Destroyed, fires the Destroyed Signal, cleans up the BaseObject, and sets the metatable to nil/a special locked MT. Overriding If you override this method, you need to make sure you callgetmetatable(self).Destroy(self) to call the superclass methods. function MyCustomClass:Destroy() getmetatable(SuperClass).Destroy(self) -- calls the superclass method to clean up events, tasks, etc.. end   "},{"title":"GetId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetId","content":"&lt;/&gt; BaseObject:GetId() → number Returns the ID of the BaseObject Can be used to fetch the object with BaseObject.getObjectFromId(id)  "},{"title":"IsA​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#IsA","content":"&lt;/&gt; BaseObject:IsA(classOrClassName: {[any]: any} | string) → boolean Returns true if the given object is of a given class. Takes a class name or class object.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetTask","content":"&lt;/&gt; BaseObject:GetTask(taskId: any) → Task? Fetches the task with the given ID if it exists. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:AddTask(part, nil, &quot;Test&quot;) print(obj:GetTask(&quot;Test&quot;) == part) -- true   "},{"title":"AddTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddTask","content":"&lt;/&gt; BaseObject:AddTask( task: Task, taskCleanupMethod: (string | true | nil)?,-- (if none is given it will try to infer; Passing true tells it to call it as a function) taskId: any? ) → Task-- The task that was given Adds a task to the janitor. If a taskId is provided, it will be used as the key for the task in the janitor and can then be fetched later with :GetTask(). If an ID is provided and there already exists a task with that ID, it will clean up the existing task and then replace the index with the new one. It will return the task that was added/given. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end) obj:Destroy() -- Prints &quot;Hello, World!&quot;   "},{"title":"AddPromise​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddPromise","content":"&lt;/&gt; BaseObject:AddPromise(prom: Promise) → Promise Adds a promise to the janitor. Similar to :AddTask(). Returns the same Promise that was given to it. local prom = Promise.delay(math.random(10)) local obj = BaseObject.new() obj:AddPromise(prom) task.wait(math.random(10)) obj:Destroy() -- Cancels the promise if it hasn't resolved yet   "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTask","content":"&lt;/&gt; BaseObject:RemoveTask( taskId: any, dontClean: boolean? ) → () Removes a task from the janitor. Cleans the task as if :DoCleaning was called. If dontClean is true, it will not clean up the task, it will just remove it from the janitor. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTask(&quot;Test&quot;) -- Prints &quot;Hello, World!&quot;   "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTaskNoClean","content":"&lt;/&gt; BaseObject:RemoveTaskNoClean(taskId: any) → () Removes a task from the janitor without cleaning it. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTaskNoClean(&quot;Test&quot;) -- Does NOT print &quot;Hello, World!&quot;   "},{"title":"FireSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#FireSignal","content":"&lt;/&gt; BaseObject:FireSignal( signalName: string,-- The name of the signal to fire ...: any-- Arguments to pass to the signal ) → () Fires the signal with the given name, if it exists. Equivalent to calling :GetSignal(signalName):Fire(...) except this does not require the signal to exist first. local obj = BaseObject.new() local SignalName = &quot;Test&quot; obj:RegisterSignal(SignalName) obj:GetSignal(SignalName):Connect(print) obj:FireSignal(SignalName, &quot;Hello, World!&quot;) -- Fires the signal with the argument &quot;Hello, World!&quot;   "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RegisterSignal","content":"&lt;/&gt; BaseObject:RegisterSignal( signalName: string-- Name of signal to register ) → () Marks a signal with the given name as registered. Does not actually build a new signal, it sets the index to a SignalMarker to identify it as registered so that it can be fetched later.  "},{"title":"HasSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#HasSignal","content":"&lt;/&gt; BaseObject:HasSignal(signalName: string) → boolean Checks whether or not a signal with the given name is registered. local obj = BaseObject.new() local SignalName = &quot;Test&quot; print(obj:HasSignal(SignalName)) -- false obj:RegisterSignal(SignalName) print(obj:HasSignal(SignalName)) -- true   "},{"title":"GetSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetSignal","content":"&lt;/&gt; BaseObject:GetSignal(signalName: string) → Signal Fetches a signal with the given name. Creates the Signal JIT.  "},{"title":"GetDestroyedSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetDestroyedSignal","content":"&lt;/&gt; BaseObject:GetDestroyedSignal() → Signal Returns a signal that fires when the object is destroyed. Creates the signal JIT. Kept for backwards compatibility. local obj = BaseObject.new() obj:GetDestroyedSignal():Connect(function() print(&quot;Object Destroyed!&quot;) end) obj:Destroy() -- Prints &quot;Object Destroyed!&quot;   "},{"title":"BindToInstance​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BindToInstance","content":"&lt;/&gt; BaseObject:BindToInstance( obj: Instance , destroyOnNilParent: boolean?-- Whether or not to destroy the object when the parent is nil'd ) → function-- Disconnects the binding Binds the object to the given instance. When the object is destroyed, it will destroy the instance. When the instance is destroyed, it will destroy the object. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:BindToInstance(part) do -- setup prints on destroy obj:AddTask(function() print(&quot;Object Destroyed!&quot;) end) part.Destroying:Connect(function() print(&quot;Part Destroyed!&quot;) end) end local X = if math.random(1,2) == 1 then obj or part X:Destroy() -- Prints &quot;Object Destroyed!&quot; and &quot;Part Destroyed!&quot; (Destroying one will destroy the other)  "},{"title":"TableReplicatorSingleton","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableReplicatorSingleton","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#new","content":"&lt;/&gt; TableReplicatorSingleton.new(config: Config) → () "},{"title":"Types","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton##","content":""},{"title":"​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Config","content":"interface Config { ClassTokenName: string-- The name of the class token to listen for. DefaultDataSchema: table?-- The default schema to use if the replicator is not ready yet. ConditionFn: ((replicator: ClientTableReplicator) → boolean)?-- A function that returns whether or not the replicator is valid and should be bound. }  Creates a new TableReplicatorSingleton. local ClientPlayerData = TableReplicatorSingleton.new { ClassTokenName = &quot;PlayerData&quot;; DefaultDataSchema = Import(&quot;PlayerDataSchema&quot;); ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end; } return ClientPlayerData   "},{"title":"Get​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Get","content":"&lt;/&gt; TableReplicatorSingleton:Get( path: Path, index: number? ) → any? Fetches the value at the path. An index can be provided to fetch the value at that index. If the value is not ready yet, it will return the value rom the default schema if one was given. If the path is untraversable, it will return nil. local coins = ClientPlayerData:Get(&quot;Coins&quot;) local thirdItem = ClientPlayerData:Get(&quot;Inventory&quot;, 3) -- Equivalent to `ClientPlayerData:Get(&quot;Inventory&quot;)[3]`   "},{"title":"Observe​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Observe","content":"&lt;/&gt; TableReplicatorSingleton:Observe( path: Path, callback: (newValue: any?) → () ) → () → () Called immediately and then whenever the value at the path changes. The callback will be called with the new value. ClientPlayerData:Observe(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToValueChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToValueChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToValueChange( path: Path, callback: (...any) → () ) → function-- A function that, when called, will disconnect the listener. Called when the value at the path is changed. The callback will be called with the new value. ClientPlayerData:ListenToValueChange(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToAnyChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToAnyChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToAnyChange( path: Path, callback: (...any) → () ) → () → () Called when the value at the path is changed through any means. This includes if the value is an array and a value in the array is changed, inserted, or removed.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ToFusionState","content":"&lt;/&gt; TableReplicatorSingleton:ToFusionState(path: Path) → State&lt;any&gt; Returns a Fusion State object that will automatically update when the value at the path changes. This is useful for when you want to use Fusion dependents to respond to changes in the value. local coinsState = ClientPlayerData:ToFusionState(&quot;Coins&quot;) New &quot;TextLabel&quot; { Text = coinsState; }   "},{"title":"GetTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableManager","content":"&lt;/&gt; TableReplicatorSingleton:GetTableManager() → TableManager Gets the TableManager for the TableReplicatorSingleton. This will error if the TableManager is not ready yet. local TM = ClientPlayerData:GetTableManager()   "},{"title":"GetTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:GetTableReplicator() → ClientTableReplicator Gets the TableReplicator for the TableReplicatorSingleton. This will error if the TableReplicator is not ready yet. local TR = ClientPlayerData:GetTableReplicator()   "},{"title":"PromiseTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableManager","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableManager() → Promise&lt;TableManager&gt; Returns a promise that resolves with the TableManager when it is ready. ClientPlayerData:PromiseTableManager():andThen(function(TM: TableManager) print(&quot;TableManager is ready!&quot;) end)   "},{"title":"PromiseTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableReplicator() → Promise&lt;ClientTableReplicator&gt; Returns a promise that resolves with the TableReplicator when it is ready. ClientPlayerData:PromiseTableReplicator():andThen(function(TR: ClientTableReplicator) print(&quot;TableReplicator is ready!&quot;) end)   "},{"title":"IsReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#IsReady","content":"&lt;/&gt; TableReplicatorSingleton:IsReady() → boolean Returns whether or not a valid Replicator has been found and hooked into. if ClientPlayerData:IsReady() then print(&quot;We have a valid Replicator!&quot;) end   "},{"title":"OnReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#OnReady","content":"&lt;/&gt; TableReplicatorSingleton:OnReady() → Promise&lt;()&gt; Returns a promise that resolves when the TableReplicatorSingleton is ready. ClientPlayerData:OnReady():andThen(function() print(&quot;Found a valid Replicator!&quot;) end)  "},{"title":"ServerTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#types","content":" "},{"title":"ClassToken​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ClassToken","content":"&lt;/&gt; type ClassToken = {Name: string} A unique symbol that identifies the STR Class. This is used to identify the STR Class when it is replicated to the client. Use .newClassToken to generate an object of this type. Do NOT manually create the table.  "},{"title":"ReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicationTargets","content":"&lt;/&gt; type ReplicationTargets = &quot;All&quot; | Player | {Player } The Player(s) that the STR should replicate to. If &quot;All&quot; is given then the STR will replicate to all current and future players. "},{"title":"Properties​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#properties","content":" "},{"title":"AddedActivePlayer​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#AddedActivePlayer","content":"&lt;/&gt; ServerTableReplicator.AddedActivePlayer: Signal&lt;Player &gt; A signal that fires whenever a player starts being replicated to. This happens when their client requests the current data from the server.  "},{"title":"All​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#All","content":"&lt;/&gt; ServerTableReplicator.All: ServerTableReplicator A STR that replicates to all current and future players. Used as a global parent for child STRs that need a home and should be replicated to all current and future players. Do not modify anything about this STR, only use it as a Parent.  "},{"title":"None​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#None","content":"&lt;/&gt; ServerTableReplicator.None: ServerTableReplicator A STR that doesnt replicate to anyone. Used as a global parent for child STRs that shouldnt be replicated. Do not modify anything about this STR, only use it as a Parent. "},{"title":"Functions​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#functions","content":" "},{"title":"newClassToken​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#newClassToken","content":"&lt;/&gt; ServerTableReplicator.newClassToken(tokenName: string) → ClassToken Returns a ClassToken Symbol that is used for identifying the STR Class. We use unique symbols instead of strings to prevent accidental collisions. warning This may only be called once per unique string. The returned symbol should be used repeatedly instead of calling this function again. Calling this function again with the same string will result in an error.  "},{"title":"new​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#new","content":"&lt;/&gt; ServerTableReplicator.new(config: { ClassToken: ClassToken, TableManager: TableManager, ReplicationTargets: ReplicationTargets?, Parent: ServerTableReplicator?, Tags: {[string]: any}?, Client: {[string]: any}?, }) → () Creates a new ServerTableReplicator instance. The config must be given a TableManager instance and a ClassToken Symbol. A list of replication targets can be provided to specify which players the STR should replicate to immediately. If no replication targets are specified, the STR will not replicate to any players. You can specify a Parent STR instead of giving ReplicationTargets and it will inherit the replication targets of the top level STR. Optionally, a list of tags can be provided to help identify the STR. The tags list will become immutable internally after the STR is created. EXAMPLE: -- Some Server Script local token = ServerTableReplicator.newClassToken(&quot;PlayerData&quot;) Players.PlayerAdded:Connect(function(player) local manager = TableManager.new({ Money = math.random(1, 100); }) local replicator = ServerTableReplicator.new({ TableManager = manager, ClassToken = token, ReplicationTargets = &quot;All&quot;, Tags = {UserId = player.UserId}, }) end) -- Some Client Script ClientTableReplicator.listenToNewReplicator(&quot;PlayerData&quot;, function(replicator) print(&quot;New PlayerData STR: &quot;, replicator:GetTag(&quot;UserId&quot;)) print(&quot;Money: &quot;, replicator:GetTableManager():Get(&quot;Money&quot;)) end) Top Level Replicators A replicator must be given either a Parent Replicator or a list of ReplicationTargets. If both are given then it will produce an error. If you give ReplicationTargets then that Replicator will be known as TopLevel. Only TopLevel Replicators can have their ReplicationTargets manually changed. If a Parent Replicator is given, the Child Replicator will inherit the replication targets of the Ancestor TopLevel Replicator.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Destroy","content":"&lt;/&gt; ServerTableReplicator:Destroy() → () Destroys the Replicator on both the Server and any replicated Clients  "},{"title":"IsReplicatingToAll​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsReplicatingToAll","content":"&lt;/&gt; ServerTableReplicator:IsReplicatingToAll() → boolean Returns whether or not this STR is replicating to all current and future players.  "},{"title":"IsReplicationTarget​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsReplicationTarget","content":"&lt;/&gt; ServerTableReplicator:IsReplicationTarget(player: Player ) → boolean Checks whether the player is a valid target for replication. Not whether the player is currently being replicated to.  "},{"title":"GetReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetReplicationTargets","content":"&lt;/&gt; ServerTableReplicator:GetReplicationTargets() → {Player } Gets the list of Players that this Replicator is attempting to replicate to.  "},{"title":"GetActiveReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetActiveReplicationTargets","content":"&lt;/&gt; ServerTableReplicator:GetActiveReplicationTargets() → {Player } Gets the list of Players that this Replicator is currently replicating to. This is different from GetReplicationTargets as it does not include pending replication targets.  "},{"title":"SetParent​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetParent","content":"&lt;/&gt; ServerTableReplicator:SetParent(newParent: ServerTableReplicator) → () Sets the Parent of this STR to the given STR.  "},{"title":"DestroyFor​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#DestroyFor","content":"&lt;/&gt; ServerTableReplicator:DestroyFor(targets: ReplicationTargets) → () Removes a player or list of players from the replication targets.  "},{"title":"ReplicateFor​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicateFor","content":"&lt;/&gt; ServerTableReplicator:ReplicateFor(targets: ReplicationTargets) → () Adds a player or list of players to the replication targets.  "},{"title":"SetReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetReplicationTargets","content":"&lt;/&gt; ServerTableReplicator:SetReplicationTargets(targets: ReplicationTargets) → () Overwrites the current replication targets with the new targets. "},{"title":"TableState","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableState","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#new","content":"&lt;/&gt; TableState.new( manager: TableManager, Path: Path ) → TableState Creates a new TableState. This is used to observe and modify values in a TableManager easier. Equivalent to tblMngr:ToState(Path) local tbl = { Coins = 0; Inventory = { &quot;Sword&quot;; &quot;Shield&quot;; }; } local tblMngr = TableManager.new(tbl) local coinsState = TableState.new(tblMngr, &quot;Coins&quot;) print( coinsState == tblMngr:ToTableState(&quot;Coins&quot;) ) -- true coinsState:Set(100) -- equivalent to `tblMngr:SetValue(&quot;Coins&quot;, 100)` local inventoryState = TableState.new(tblMngr, &quot;Inventory&quot;) inventoryState:Insert(&quot;Potion&quot;) -- equivalent to `tblMngr:ArrayInsert(&quot;Inventory&quot;, &quot;Potion&quot;)` States with array values You should avoid setting states to be a particular index in array because if the array is shifted then the state can potentially be pointing to the wrong value.  "},{"title":"Set​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Set","content":"&lt;/&gt; TableState:Set(...: any) → () Sets the value this state is associated with. :Set(999) -- Sets the value itself to 999 :Set(1, 999) -- Sets the value at index 1 to 999 (State must be an array)   "},{"title":"Get​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Get","content":"&lt;/&gt; TableState:Get(index: number?) → any Gets the value this state is associated with. Takes an optional argument to specify the index of the array to get. :Get() -- Gets the value itself :Get(1) -- Gets the value at index 1 of the state (State must be an array) (Equivalent to :Get()[1])   "},{"title":"Increment​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Increment","content":"&lt;/&gt; TableState:Increment(...: any) → any Increments the value this state is associated with. :Increment(999) -- Increments the value itself by 999 :Increment(1, 999) -- Increments the value at index 1 by 999 (State must be an array)   "},{"title":"Insert​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Insert","content":"&lt;/&gt; TableState:Insert(...: any) → () Inserts a value into the array this state is associated with. :Insert(999) -- Appends 999 onto the array :Insert(5, 999) -- Inserts 999 at index 5 of the array   "},{"title":"Remove​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Remove","content":"&lt;/&gt; TableState:Remove(index: number) → any-- The removed value. Removes the value at the given index from the array this state is associated with.  "},{"title":"RemoveFirstValue​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#RemoveFirstValue","content":"&lt;/&gt; TableState:RemoveFirstValue(valueToFind: any) → number-- The index of the removed value. Removes the first value that matches the given value from the array this state is associated with.  "},{"title":"Observe​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Observe","content":"&lt;/&gt; TableState:Observe(fn: (new: any) → ()) → () → () Observes changes to the value this state is associated with. Also fires immediately. See TableManager:Observe for more information. "},{"title":"TableManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#types","content":" "},{"title":"CanBeArray<T>​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#CanBeArray<T>","content":"&lt;/&gt; type CanBeArray&lt;T&gt; = T | {T} A type that could be an individual of the type or an array of the type.  "},{"title":"Path​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Path","content":"&lt;/&gt; type Path = string | {any} A path to a value in a table. Can be written as a string in dot format or an array of strings. :::Note The array format is faster to parse and should be used when possible. ::: local tbl = { MyPath = { To = { Value = 0; }; }; } local path1: Path = &quot;MyPath.To.Value&quot; -- Style 1 local path2: Path = {&quot;MyPath&quot;, &quot;To&quot;, &quot;Value&quot;} -- Style 2   "},{"title":"ValueListenerFn​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ValueListenerFn","content":"&lt;/&gt; type ValueListenerFn = ( newValue: any, oldValue: any?, changeMetadata: ChangeMetadata? ) → ()   "},{"title":"ListenerType​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenerType","content":"&lt;/&gt; type ListenerType = &quot;ValueChanged&quot; | &quot;ArraySet&quot; | &quot;ArrayInsert&quot; | &quot;ArrayRemove&quot; This information is mostly for internal use.  "},{"title":"DataChangeSource​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#DataChangeSource","content":"&lt;/&gt; type DataChangeSource = &quot;self&quot; | &quot;child&quot; | &quot;parent&quot; This information is mostly for internal use.  "},{"title":"ChangeMetadata​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ChangeMetadata","content":"&lt;/&gt; interface ChangeMetadata { ListenerType: ListenerType-- The listener type that was fired. SourceDirection: DataChangeSource-- The source direction of the change. SourcePath: {string}-- The origin path of the change. NewValue: any?-- [Only for value changes] The new value. OldValue: any?-- [Only for value changes] The old value. } Metadata about the change that fired a listener. Used to provide more context to listeners. Allows you to figure out where the change came from, if it wasnt a direct change. "},{"title":"Properties​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Enums","content":"&lt;/&gt; TableManager.Enums: { ListenerType: ListenerTypeEnum, DataChangeSource: DataChangeSourceEnum } A collection of enums used by the TableManager. "},{"title":"Functions​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#new","content":"Constructor &lt;/&gt; TableManager.new(data: table?) → TableManager Creates a new TableManager. Takes a table to manage, if one is not given then it will construct an empty table. Modifying the given table Once you give a table to a TableManager, you should never modify it directly. Doing so can result in the TableManager being unable to properly track changes and potentially cause data desyncs. Key/Value Rules The given table's keys should follow these rules: No Mixed Tables (Tables containing keys of different datatypes) Avoid using tables as keys. Keys must not contain periods. Keys must not be empty strings. Tables/Arrays should be assigned to only one key. (No shared references as this can cause desyncs) Nested tables/arrays should not be given to other TableManager instances. (Can cause desyncs) info Only one TableManager should be created for a given table. Attempting to create a TableManager for a table that is already being managed will return the existing TableManager. Call metamethod You can call the TableManager class to create a new instance of it. TableManager() is equivalent to TableManager.new(). local tbl = { Coins = 0; Inventory = { &quot;Sword&quot;; &quot;Shield&quot;; }; } local tblMngr = TableManager.new(tbl) tblMngr:SetValue(&quot;Coins&quot;, 100) tblMngr:IncrementValue(&quot;Coins&quot;, 55) print(tblMngr:Get(&quot;Coins&quot;)) -- 155 tblMngr:ArrayInsert(&quot;Inventory&quot;, &quot;Potion&quot;) tblMngr:ArrayInsert(&quot;Inventory&quot;, 2, &quot;Bow&quot;) print(tblMngr:Get(&quot;Inventory&quot;)) -- {&quot;Sword&quot;, &quot;Bow&quot;, &quot;Shield&quot;, &quot;Potion&quot;}   "},{"title":"Destroy​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Destroy","content":"&lt;/&gt; TableManager:Destroy() → () Disconnects any listeners and removes the table from the managed tables.  "},{"title":"Set​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Set","content":"&lt;/&gt; TableManager:Set( path: Path, ...: any ) → () Sets the value at the given path to the given value. :Set acts as a combined function for :SetValue and :ArraySet. :Set(myPathToValue, newValue) :Set(myPathToArray, index, newValue) Overwriting the root table Overwriting the root table is not recommended, but is technically possible by giving an empty table or string as a Path. Doing so has not been tested in depth and may result in unintended behavior. Setting array values You cannot set values to nil in an array with this method due to the way it parses args. Use ArraySet instead if you need to set values to nil.  "},{"title":"Increment​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Increment","content":"&lt;/&gt; TableManager:Increment( path: Path, ...: any ) → number? Increments the value at the given path by the given amount. If the value is not a number, it will throw an error. :Increment acts as a combined function for :IncrementValue and :ArrayIncrement. :Increment(myPathToValue, amountToIncrementBy) :Increment(myPathToArray, index, amountToIncrementBy)   "},{"title":"Mutate​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Mutate","content":"&lt;/&gt; TableManager:Mutate( path: Path, ...: any ) → any? Mutates the value at the given path by calling the given function with the current value. :Mutate(myPathToValue, function(currentValue) return currentValue + 1 end)   "},{"title":"SetValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetValue","content":"&lt;/&gt; TableManager:SetValue( path: Path, value: any ) → boolean Sets the value at the given path to the given value. This will fire the ValueChanged signal if the value is different. Returns a boolean indicating whether or not the value was changed. local didChange = manager:SetValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"IncrementValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#IncrementValue","content":"&lt;/&gt; TableManager:IncrementValue( path: Path, amount: Numeric ) → number Increments the value at the given path by the given amount. If the value at the path or the given amount is not a number, it will throw an error. Returns the newly incremeneted value. local newValue = manager:IncrementValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"MutateValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#MutateValue","content":"&lt;/&gt; TableManager:MutateValue( path: Path, fn: (currentValue: any) → (any) ) → any Mutates the value at the given path by calling the given function with the current value. The function should return the new value. manager:SetValue(&quot;MyPath.To.Value&quot;, &quot;Hello World&quot;) local newValue = manager:MutateValue(&quot;MyPath.To.Value&quot;, function(currentValue) return string.upper(currentValue) .. &quot;!&quot; end) print(newValue) -- HELLO WORLD! print(manager:GetValue(&quot;MyPath.To.Value&quot;)) -- HELLO WORLD!   "},{"title":"SetManyValues​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetManyValues","content":"&lt;/&gt; TableManager:SetManyValues( path: Path, valueDict: {[any]: any} ) → () Sets the values at the given path to the given values. This will fire the ValueChanged listener for each value that is different. caution Uses pairs to check through the given table and thus Does not support setting values to nil. local manager = TableManager.new({ Foo = { Bar = { Value1 = 0; Value2 = 0; Value3 = 0; }; }; }) manager:SetManyValues(&quot;Foo.Bar&quot;, { Value1 = 100; Value3 = 300; })   "},{"title":"ArrayMutate​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayMutate","content":"&lt;/&gt; TableManager:ArrayMutate( path: Path,-- The path to the array to mutate. index: number | {number} | &quot;#&quot;,-- The index or indices to mutate. If &quot;#&quot; is given, it will mutate all indices. fn: (currentValue: any) → (any)-- The function to call with the current value. Should return the new value. ) → () Mutates an index or indices in the array at the given path by calling the given function with the current value. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayMutate(&quot;MyArray&quot;, 3, function(currentValue) return currentValue * 2 }) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 6, 4, 5}   "},{"title":"ArrayIncrement​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayIncrement","content":"&lt;/&gt; TableManager:ArrayIncrement( path: Path,-- The path to the array to increment. index: number | {number},-- The index or indices to increment. amount: number?-- The amount to increment by. If not given, it will increment by 1. ) → () Increments the indices at the given path by the given amount. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayIncrement(&quot;MyArray&quot;, 3, 10) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 13, 4, 5}   "},{"title":"ArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArraySet","content":"&lt;/&gt; TableManager:ArraySet( path: Path, index: (CanBeArray&lt;number&gt; | '#')?, value: any ) → () Sets the value at the given index in the array at the given path. The index can be a number or an array of numbers. If an array is given then the value will be set at each of those indices in the array.  "},{"title":"ArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayInsert","content":"&lt;/&gt; TableManager:ArrayInsert( path: Path, ...: any ) → () Inserts the given value into the array at the given path at the given index. If no index is given, it will insert at the end of the array. This follows the convention of table.insert where the index is given in the middle only if there are 3 args. x:ArrayInsert(&quot;MyArray&quot;, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at index 1 x:ArrayInsert(&quot;MyArray&quot;, 1) -- appends 1 to the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, 2) -- Inserts 2 at index 1   "},{"title":"ArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemove","content":"&lt;/&gt; TableManager:ArrayRemove( path: Path, index: number? ) → any Removes the value at the given index from the array at the given path. If no index is given, it will remove the last value in the array. Returns the value that was removed if one was.  "},{"title":"ArrayRemoveFirstValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemoveFirstValue","content":"&lt;/&gt; TableManager:ArrayRemoveFirstValue( path: Path, value: any ) → number? Removes the first instance of the given value from the array at the given path. Returns a number indicating the index that it was was removed from if one was.  "},{"title":"Get​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Get","content":"&lt;/&gt; TableManager:Get( path: Path, idx: (number | string)? ) → any Fetches the value at the given path. Accepts a string path or an array path. Accepts an optional secondary argument to fetch a value at an index in an array. Aliases: GetValue local manager = TableManager.new({ Currency = { Coins = 100; Gems = 10; }; }) -- The following are all equivalent acceptable methods of fetching the value. print(manager:Get(&quot;Currency.Coins&quot;)) -- 100 print(manager:Get({&quot;Currency&quot;, &quot;Coins&quot;})) -- 100 print(manager:Get().Currency.Coins) -- 100 Getting the Root Table Calling :Get() with no arguments, an empty string, or an empty table will return the root table.  "},{"title":"ToTableState​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ToTableState","content":"&lt;/&gt; TableManager:ToTableState(path: Path) → TableState Returns a TableState Object for the given path. warning This method is not feature complete and does not work for all edge cases and should be used with caution. local path = &quot;MyPath.To.Value&quot; local state = manager:ToTableState(path) state:Set(100) manager:Increment(path, 50) state:Increment(25) print(state:Get()) -- 175   "},{"title":"ToFusionState​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ToFusionState","content":"&lt;/&gt; TableManager:ToFusionState(path: Path) → FusionState&lt;any&gt; Returns a Fusion State object that is bound to the value at the given path. This method is memoized so calling it repeatedly with the same path will return the same State object and quickly. Deffered Signals The value of the Fusion State object is updated via the ValueChanged listener and thus may be deffered if your signals are deffered. Setting Although this currently returns a Fusion Value object, it is not recommended to set the value as this may be a Computed in the future. Setting the state will not actually change the value in the TableManager. local path = &quot;MyPath.To.Value&quot; manager:SetValue(path, 100) local state = manager:ToFusionState(path) print(peek(state)) -- 100 manager:SetValue(path, 200) task.wait() -- If your signals are deffered then the state will update on the next frame print(peek(state)) -- 200   "},{"title":"PromiseValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#PromiseValue","content":"&lt;/&gt; TableManager:PromiseValue( path: Path, condition: (value: any?) → (boolean) ) → Promise Creates a promise that resolves when the given condition is met. The condition is immediately and every time the value changes. If no condition is given then it will resolve with the current value unless it is nil, in which case it will resolve on the first change.  "},{"title":"Observe​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Observe","content":"&lt;/&gt; TableManager:Observe( path: Path,-- The path to the value to observe. fn: ValueListenerFn,-- The function to call when the value changes. runOnNil: boolean?-- Whether or not to fire the function when the value is nil. ) → Connection-- A connection used to disconnect the listener. Observes a value at a path and calls the function immediately with the current value, as well as when it changes. Listening to nil values It will NOT fire if the new/starting value is nil, unless runOnNil is true. When it changes from nil, the oldValue will be the last known non nil value. The binding call of the function is an exception and will give nil as the oldValue. This is done so that Observe can be used to execute instructions when a value is percieved as 'ready'. local path = &quot;MyPath.To.Value&quot; local connection = manager:Observe(path, function(newValue) print(&quot;Value at&quot;, path, &quot;is&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"ListenToKeyChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToKeyChange","content":"&lt;/&gt; TableManager:ListenToKeyChange( parentPath: Path?, fn: ( keyChanged: any, newValue: any, oldValue: any ) → () ) → () Listens to a change at a specified path and calls the function when the value changes. manager:Set(&quot;Stats&quot;, { Health = 100; Mana = 50; }) local connection = manager:ListenToKeyChange(&quot;Stats&quot;, function(key, newValue) print(`{key} changed to {newValue}`) end) manager:SetValue(&quot;Stats.Health&quot;, 200) -- Health changed to 200 manager:SetValue(&quot;Stats.Mana&quot;, 100) -- Mana changed to 100   "},{"title":"ListenToKeyAdd​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToKeyAdd","content":"&lt;/&gt; TableManager:ListenToKeyAdd( parentPath: Path?, fn: ( newKey: any, newValue: any ) → () ) → Connection Listens to when a new key is added (Changed from nil) to a table at a specified path and calls the function.  "},{"title":"ListenToKeyRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToKeyRemove","content":"&lt;/&gt; TableManager:ListenToKeyRemove( parentPath: Path?, fn: ( removedKey: any, lastValue: any ) → () ) → Connection Listens to when a key is removed (Set to nil) from a table at a specified path and calls the function.  "},{"title":"ListenToValueChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToValueChange","content":"&lt;/&gt; TableManager:ListenToValueChange( path: Path, fn: ValueListenerFn ) → Connection Listens to a change at a specified path and calls the function when the value changes. This does NOT fire when the value is an array/dictionary and one of its children changes. local connection = manager:ListenToValueChange(&quot;MyPath.To.Value&quot;, function(newValue, oldValue) print(&quot;Value changed from&quot;, oldValue, &quot;to&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"ListenToArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToArraySet","content":"&lt;/&gt; TableManager:ListenToArraySet( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when an index is set in an array at a specified path and calls the function. The function receives the index and the new value. caution The array listeners do not fire from changes to parent or child values.  "},{"title":"ListenToArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToArrayInsert","content":"&lt;/&gt; TableManager:ListenToArrayInsert( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when a value is inserted into an array at a specified path and calls the function when the value changes.  "},{"title":"ListenToArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenToArrayRemove","content":"&lt;/&gt; TableManager:ListenToArrayRemove( path: Path, fn: ( oldIndex: number, oldValue: any ) → () ) → Connection Listens to when a value is removed from an array at a specified path and calls the function. "}]