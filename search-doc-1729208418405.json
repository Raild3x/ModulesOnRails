[{"title":"--------","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/--------","content":"On this page --------","keywords":""},{"title":"CmdrHandler","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrHandler","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#Server","content":"&lt;/&gt; CmdrHandler.Server: CmdrServer   "},{"title":"Client​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#Client","content":"&lt;/&gt; CmdrHandler.Client: CmdrClient  "},{"title":"CmdrClient","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrClient","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#functions","content":" "},{"title":"PromiseCmdr​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#PromiseCmdr","content":"&lt;/&gt; CmdrClient:PromiseCmdr() → Promise Returns a promise that resolves with the Cmdr instance.https://eryn.io/Cmdr/api/CmdrClient.html return Promise  "},{"title":"HasPermission​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#HasPermission","content":"&lt;/&gt; CmdrClient:HasPermission( commandName: string-- The name of the command to check ) → boolean Checks if a player has permission to run a command  "},{"title":"ExecuteCommand​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#ExecuteCommand","content":"&lt;/&gt; CmdrClient:ExecuteCommand(...: string) → Promise&lt;string&gt; Executes a command CmdrService:ExecuteCommand(&quot;blink&quot;)   "},{"title":"GetPermissions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetPermissions","content":"&lt;/&gt; CmdrClient:GetPermissions() → {any} Gets the permissions for the local player Does not return permissions granted from groups  "},{"title":"GetGroupRankPermissions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetGroupRankPermissions","content":"&lt;/&gt; CmdrClient:GetGroupRankPermissions( groupId: number,-- The Roblox group id to get permissions for rank: number-- The rank to get permissions for ) → {string}-- The permissions granted to the rank Gets the permissions granted to a particular rank in a group local permissions = CmdrService:GetGroupRankPermissions(15905255, 230)   "},{"title":"GetPermissionInheritance​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetPermissionInheritance","content":"&lt;/&gt; CmdrClient:GetPermissionInheritance(permissionGroup: string) → {string} Fetches the inherited permission group for a permission group "},{"title":"CameraUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CameraUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"CameraUtil","url":"/ModulesOnRails/api/CameraUtil#properties","content":" "},{"title":"Instance​","type":1,"pageTitle":"CameraUtil","url":"/ModulesOnRails/api/CameraUtil#Instance","content":"&lt;/&gt; CameraUtil.Instance: Camera  The current camera instance.  "},{"title":"CameraCFrame​","type":1,"pageTitle":"CameraUtil","url":"/ModulesOnRails/api/CameraUtil#CameraCFrame","content":"&lt;/&gt; CameraUtil.CameraCFrame: State&lt;CFrame &gt; A Fusion State containing the current camera's CFrame.  "},{"title":"ViewportSize​","type":1,"pageTitle":"CameraUtil","url":"/ModulesOnRails/api/CameraUtil#ViewportSize","content":"&lt;/&gt; CameraUtil.ViewportSize: State&lt;Vector2 &gt; A Fusion State containing the current camera's ViewportSize.  "},{"title":"ViewportSizeY​","type":1,"pageTitle":"CameraUtil","url":"/ModulesOnRails/api/CameraUtil#ViewportSizeY","content":"&lt;/&gt; CameraUtil.ViewportSizeY: State&lt;number&gt; A Fusion Computed containing the current camera's ViewportSize.Y. "},{"title":"Functions​","type":1,"pageTitle":"CameraUtil","url":"/ModulesOnRails/api/CameraUtil#functions","content":" "},{"title":"isOnScreen​","type":1,"pageTitle":"CameraUtil","url":"/ModulesOnRails/api/CameraUtil#isOnScreen","content":"&lt;/&gt; CameraUtil.isOnScreen( worldPoint: Vector3 ,-- The world position to check. viewportMargin: number?-- The acceptable margin of viewport space to be considered on screen. Defaults to 50. ) → ( boolean,-- Whether or not the position is on screen. number-- The distance the point is from the camera ) A function that takes a world position and returns whether or not that point is on screen within the camera's viewport. "},{"title":"DebugUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DebugUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DebugUtil","url":"/ModulesOnRails/api/DebugUtil#functions","content":" "},{"title":"getDebugFlag​","type":1,"pageTitle":"DebugUtil","url":"/ModulesOnRails/api/DebugUtil#getDebugFlag","content":"&lt;/&gt; DebugUtil.getDebugFlag( flagName: string,-- The name of the debug flag. asState: boolean?-- Whether to return the State object or the current value. ) → UsedAs&lt;boolean&gt; Gets the current state of a debug flag.  "},{"title":"toggleDebugFlag​","type":1,"pageTitle":"DebugUtil","url":"/ModulesOnRails/api/DebugUtil#toggleDebugFlag","content":"&lt;/&gt; DebugUtil.toggleDebugFlag(flagName: string) → boolean-- The new value of the flag. Toggles the state of a debug flag.  "},{"title":"setDebugFlag​","type":1,"pageTitle":"DebugUtil","url":"/ModulesOnRails/api/DebugUtil#setDebugFlag","content":"&lt;/&gt; DebugUtil.setDebugFlag( flagName: string, value: boolean ) → State&lt;boolean&gt;-- The new state of the flag. Sets the state of a debug flag.  "},{"title":"observeDebugFlag​","type":1,"pageTitle":"DebugUtil","url":"/ModulesOnRails/api/DebugUtil#observeDebugFlag","content":"&lt;/&gt; DebugUtil.observeDebugFlag( flagName: string, callback: (boolean) → (), onlyOnChange: boolean?-- Whether to call the callback only on changes and not immediately. ) → function-- The unbind function. Observes the state of a debug flag.  "},{"title":"setup​","type":1,"pageTitle":"DebugUtil","url":"/ModulesOnRails/api/DebugUtil#setup","content":"&lt;/&gt; DebugUtil.setup() → () Initializes the DebugUtil module. "},{"title":"DropletClientManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletClientManager","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#new","content":"constructor &lt;/&gt; DropletClientManager.new() → DropletClientManager Creates a new DropletClientManager if one has not already been made, returns the existing one if one already exists.  "},{"title":"RegisterResourceType​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#RegisterResourceType","content":"&lt;/&gt; DropletClientManager:RegisterResourceType( resourceType: string, data: ResourceTypeData ) → () Registers a new resource type.  "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#GetResourceTypeData","content":"&lt;/&gt; DropletClientManager:GetResourceTypeData(resourceType: string) → ResourceTypeData? Returns the resource type data for the given resource type  "},{"title":"GetCollectionRadius​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#GetCollectionRadius","content":"&lt;/&gt; DropletClientManager:GetCollectionRadius() → number Gets the distance at which a droplet must be within to be collected by the LocalPlayer "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → () }   "},{"title":"Connection​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → () } Represents a connection. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → ()) → Connection Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object.  "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → ()) → Connection Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object. "},{"title":"ClientPlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientPlayerDataManager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#properties","content":" "},{"title":"DEFAULT_MANAGER_NAME​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#DEFAULT_MANAGER_NAME","content":"&lt;/&gt; ClientPlayerDataManager.DEFAULT_MANAGER_NAME: string The default internal manager name.  "},{"title":"PlayerDataReady​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#PlayerDataReady","content":"&lt;/&gt; ClientPlayerDataManager.PlayerDataReady: Signal&lt;Player &gt; A signal that fires when a Player's data is ready to be used. "},{"title":"Functions​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#new","content":"Constructor Static &lt;/&gt; ClientPlayerDataManager.new(config: { ProfileSchema: table, }) → ClientPlayerDataManager   "},{"title":"GetImmediate​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#GetImmediate","content":"&lt;/&gt; ClientPlayerDataManager:GetImmediate(managerName: string?) → TableReplicatorSingleton Gets the TableReplicatorSingleton for this manager so you can get immediate info from it if needed.  "},{"title":"GetManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#GetManager","content":"&lt;/&gt; ClientPlayerDataManager:GetManager(managerName: string?) → TableManager? Gets the TableManager associated with the given name. This method may return nil if the data has not replicated yet.  "},{"title":"PromiseManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#PromiseManager","content":"&lt;/&gt; ClientPlayerDataManager:PromiseManager(managerName: string?) → Promise Promises the TableManager associated with the given name. If it doesnt exist when called then it will wait for it to be replicated and then will resolve.  "},{"title":"RegisterManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#RegisterManager","content":"&lt;/&gt; ClientPlayerDataManager:RegisterManager(config: string | {Name: string;DefaultDataSchema: table;ConditionFn: ((replicator: TableReplicator) → boolean)?}) → TableReplicatorSingleton Registers a tableManager/TableReplicatorSingleton to be watched for on the client. Informal registration. Assumes data key in the profile template is the same as the given name. ClientPlayerDataManager:RegisterManager(&quot;Currency&quot;) Formal registration. Used for more complex/custom registering of managers. Equivalent to the above ClientPlayerDataManager:RegisterManager({ Name = &quot;Currency&quot;, DefaultDataSchema = profileTemplate[&quot;Currency&quot;], ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end, })   "},{"title":"Start​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#Start","content":"unreleased &lt;/&gt; ClientPlayerDataManager:Start() → () Marks the CPDM as started. This is not currently neccessary "},{"title":"Comm","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Comm","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#properties","content":" "},{"title":"ServerComm​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#ServerComm","content":"&lt;/&gt; Comm.ServerComm: ServerComm   "},{"title":"ClientComm​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#ClientComm","content":"&lt;/&gt; Comm.ClientComm: ClientComm   "},{"title":"ServerComm​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#ServerComm","content":"&lt;/&gt; Comm.ServerComm: ServerComm   "},{"title":"ClientComm​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#ClientComm","content":"&lt;/&gt; Comm.ClientComm: ClientComm  "},{"title":"Droplet","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Droplet","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#types","content":" "},{"title":"Droplet​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Droplet","content":"&lt;/&gt; type Droplet = Droplet  "},{"title":"Functions​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#functions","content":" "},{"title":"GetValue​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetValue","content":"&lt;/&gt; Droplet:GetValue() → any   "},{"title":"GetMetadata​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetMetadata","content":"&lt;/&gt; Droplet:GetMetadata() → any?   "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetResourceTypeData","content":"&lt;/&gt; Droplet:GetResourceTypeData() → ResourceTypeData   "},{"title":"GetPosition​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetPosition","content":"&lt;/&gt; Droplet:GetPosition() → Vector3    "},{"title":"GetModel​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetModel","content":"&lt;/&gt; Droplet:GetModel() → Actor    "},{"title":"GetSetupData​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetSetupData","content":"&lt;/&gt; Droplet:GetSetupData() → any Returns the data that was returned by the ResourceTypeData.Setup function  "},{"title":"Identify​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Identify","content":"&lt;/&gt; Droplet:Identify() → ( number,-- The seed of the droplet number-- The id of the droplet ) Returns the seed and id of the droplet. Used for internal identification.  "},{"title":"IsTimingOut​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#IsTimingOut","content":"&lt;/&gt; Droplet:IsTimingOut() → boolean Returns whether or not the droplet is in the process of timing out.  "},{"title":"AttachModel​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#AttachModel","content":"&lt;/&gt; Droplet:AttachModel(object: Model | BasePart ) → () Attaches a Model or Part to the droplet. Use this to add your visuals to the droplet.  "},{"title":"Collect​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Collect","content":"&lt;/&gt; Droplet:Collect(playerWhoCollected: Player ) → ()   "},{"title":"Claim​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Claim","content":"&lt;/&gt; Droplet:Claim(playerWhoClaimed: Player ) → ()  "},{"title":"ClientTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientTableReplicator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#functions","content":" "},{"title":"fromTemplate​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#fromTemplate","content":"Static &lt;/&gt; ClientTableReplicator.fromTemplate() → () Creates a ReplicatedTableSingleton object from the given template configuration. See TableReplicatorSingleton.new for more information.  "},{"title":"onNew​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#onNew","content":"&lt;/&gt; ClientTableReplicator.onNew( classTokenName: string, fn: (replicator: ClientTableReplicator) → () ) → () → () Listens for a new ClientTableReplicator of the given ClassName. Listening after server data loaded If you call this method after the ClientTableReplicator has already requested and loaded the server data, then this listener may miss the creation of some replicators. It is recommended to call this method before calling .requestServerData() or use .forEach() instead.  "},{"title":"requestServerData​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#requestServerData","content":"&lt;/&gt; ClientTableReplicator.requestServerData() → Promise Requests all the existing replicators from the server. This should only be called once, calling it multiple times will return the same promise. All replicator listeners should be registered before calling this method. "},{"title":"Error","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Error","content":"On this page Error An object to represent runtime errors that occur during execution. Promises that experience an error like this will be rejected with an instance of this object.","keywords":""},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal&lt;any&gt; Fires when the property receives an updated value from the server. clientRemoteProperty.Changed:Connect(function(value) print(&quot;New value&quot;, value) end)   "},{"title":"Changed​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal&lt;any&gt; Fires when the property receives an updated value from the server. clientRemoteProperty.Changed:Connect(function(value) print(&quot;New value&quot;, value) end)  "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#functions","content":" "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Gets the value of the property object. caution This value might not be ready right away. Use OnReady() or IsReady() before calling Get(). If not ready, this value will return nil.  "},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty:OnReady() → Promise&lt;any&gt; Returns a Promise which resolves once the property object is ready to be used. The resolved promise will also contain the value of the property. -- Use andThen clause: clientRemoteProperty:OnReady():andThen(function(initialValue) print(initialValue) end) -- Use await: local success, initialValue = clientRemoteProperty:OnReady():await() if success then print(initialValue) end   "},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty:IsReady() → boolean Returns true if the property object is ready to be used. In other words, it has successfully gained connection to the server-side version and has synced in the initial value. if clientRemoteProperty:IsReady() then local value = clientRemoteProperty:Get() end   "},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty:Observe(observer: (any) → nil) → Connection Observes the value of the property. The observer will be called right when the value is first ready, and every time the value changes. This is safe to call immediately (i.e. no need to use IsReady or OnReady before using this method). Observing is essentially listening to Changed, but also sends the initial value right away (or at least once OnReady is completed). local function ObserveValue(value) print(value) end clientRemoteProperty:Observe(ObserveValue)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the ClientRemoteProperty object.  "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Gets the value of the property object. caution This value might not be ready right away. Use OnReady() or IsReady() before calling Get(). If not ready, this value will return nil.  "},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty:OnReady() → Promise&lt;any&gt; Returns a Promise which resolves once the property object is ready to be used. The resolved promise will also contain the value of the property. -- Use andThen clause: clientRemoteProperty:OnReady():andThen(function(initialValue) print(initialValue) end) -- Use await: local success, initialValue = clientRemoteProperty:OnReady():await() if success then print(initialValue) end   "},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty:IsReady() → boolean Returns true if the property object is ready to be used. In other words, it has successfully gained connection to the server-side version and has synced in the initial value. if clientRemoteProperty:IsReady() then local value = clientRemoteProperty:Get() end   "},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty:Observe(observer: (any) → nil) → Connection Observes the value of the property. The observer will be called right when the value is first ready, and every time the value changes. This is safe to call immediately (i.e. no need to use IsReady or OnReady before using this method). Observing is essentially listening to Changed, but also sends the initial value right away (or at least once OnReady is completed). local function ObserveValue(value) print(value) end clientRemoteProperty:Observe(ObserveValue)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the ClientRemoteProperty object. "},{"title":"ClientNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientNetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ClientNetWire.ClassName: &quot;ClientNetWire&quot;   "},{"title":"ClassName​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ClientNetWire.ClassName: &quot;ClientNetWire&quot;  "},{"title":"Functions​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#functions","content":" "},{"title":"indexReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#indexReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.indexReady( wireOrName: ClientNetWire | string, idx: string-- The index to wait for existence of ) → Promise Returns a promise that resolves when the ClientNetWire is ready for use and the index exists. The resolved value is the value of the index.  "},{"title":"onReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#onReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.onReady(clientNetWire: ClientNetWire | string) → Promise Returns a promise that resolves when the ClientNetWire is ready for use.  "},{"title":"isReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#isReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.isReady(clientNetWire: ClientNetWire | string) → boolean Can be used to check if a clientNetWire is ready for use.  "},{"title":"destroy​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#destroy","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.destroy(clientNetWire: ClientNetWire) → () Destroys a ClientNetWire, removing it from the cache.  "},{"title":"new​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#new","content":"constructor static &lt;/&gt; ClientNetWire.new(nameSpace: string) → ClientNetWire Creates a new ClientNetWire. If a ClientNetWire with the same nameSpace already exists, it will be returned instead.  "},{"title":"indexReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#indexReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.indexReady( wireOrName: ClientNetWire | string, idx: string-- The index to wait for existence of ) → Promise Returns a promise that resolves when the ClientNetWire is ready for use and the index exists. The resolved value is the value of the index.  "},{"title":"onReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#onReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.onReady(clientNetWire: ClientNetWire | string) → Promise Returns a promise that resolves when the ClientNetWire is ready for use.  "},{"title":"isReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#isReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.isReady(clientNetWire: ClientNetWire | string) → boolean Can be used to check if a clientNetWire is ready for use.  "},{"title":"destroy​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#destroy","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.destroy(clientNetWire: ClientNetWire) → () Destroys a ClientNetWire, removing it from the cache.  "},{"title":"new​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#new","content":"constructor static &lt;/&gt; ClientNetWire.new(nameSpace: string) → ClientNetWire Creates a new ClientNetWire. If a ClientNetWire with the same nameSpace already exists, it will be returned instead. "},{"title":"DrawUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DrawUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DrawUtil","url":"/ModulesOnRails/api/DrawUtil#functions","content":" "},{"title":"vectorFromCFrame​","type":1,"pageTitle":"DrawUtil","url":"/ModulesOnRails/api/DrawUtil#vectorFromCFrame","content":"&lt;/&gt; DrawUtil.vectorFromCFrame( name: string, cf: CFrame , color: Color3? , scale: number? ) → () Creates a Vector visualization in the world from a CFrame.  "},{"title":"vector​","type":1,"pageTitle":"DrawUtil","url":"/ModulesOnRails/api/DrawUtil#vector","content":"&lt;/&gt; DrawUtil.vector( name: string,-- The name of the vector. from: (Vector3 | CFrame | PVInstance | Attachment ),-- The starting position of the vector. to: (Vector3 | CFrame | PVInstance | Attachment )?,-- The ending position of the vector. color: Color3? ,-- The color of the vector. Defaults to a random color. _scale: number?-- The scale of the vector. Defaults to 1. ) → () Creates a vector visualization in the world. DrawUtil.vector(&quot;MyVector&quot;, Vector3.new(0, 0, 0), Vector3.new(10, 10, 10), Color3.new(1, 0, 0), 1)   "},{"title":"clearVector​","type":1,"pageTitle":"DrawUtil","url":"/ModulesOnRails/api/DrawUtil#clearVector","content":"&lt;/&gt; DrawUtil.clearVector( name: string-- The name of the vector to clear. ) → () Clears a vector from the world.  "},{"title":"point​","type":1,"pageTitle":"DrawUtil","url":"/ModulesOnRails/api/DrawUtil#point","content":"&lt;/&gt; DrawUtil.point( name: string,-- The name of the point. Calling with the same name will override the previous point info. position: Vector3 | CFrame ,-- The position of the point. radius: number?,-- The radius of the point. Defaults to 0.25. color: Color3? -- The color of the point. Defaults to Color3.new(1, 1, 1). ) → Part -- The part that was created. Draws a point in the world.  "},{"title":"clearPoint​","type":1,"pageTitle":"DrawUtil","url":"/ModulesOnRails/api/DrawUtil#clearPoint","content":"&lt;/&gt; DrawUtil.clearPoint( name: string-- The name of the point to clear. ) → () Clears a point from the world.  "},{"title":"line​","type":1,"pageTitle":"DrawUtil","url":"/ModulesOnRails/api/DrawUtil#line","content":"&lt;/&gt; DrawUtil.line( name: string, from: Vector3 , to: Vector3 , radius: number?, color: Color3? ) → Part  Draws a line between two points in the world.  "},{"title":"clearLine​","type":1,"pageTitle":"DrawUtil","url":"/ModulesOnRails/api/DrawUtil#clearLine","content":"&lt;/&gt; DrawUtil.clearLine( name: string-- The name of the line to clear. ) → () Clears a line from the world. "},{"title":"FusionUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/FusionUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"FusionUtil","url":"/ModulesOnRails/api/FusionUtil#properties","content":" "},{"title":"0.2.0​","type":1,"pageTitle":"FusionUtil","url":"/ModulesOnRails/api/FusionUtil#0.2.0","content":"&lt;/&gt; FusionUtil.0.2.0: table Util for Fusion 0.2.0 local fUtil = RailUtil.Fusion[&quot;0.2.0&quot;]   "},{"title":"0.2.5​","type":1,"pageTitle":"FusionUtil","url":"/ModulesOnRails/api/FusionUtil#0.2.5","content":"&lt;/&gt; FusionUtil.0.2.5: table Util for my forked version of Fusion 0.2.0 local fUtil = RailUtil.Fusion[&quot;0.2.5&quot;]   "},{"title":"0.3.0​","type":1,"pageTitle":"FusionUtil","url":"/ModulesOnRails/api/FusionUtil#0.3.0","content":"Latest Version &lt;/&gt; FusionUtil.0.3.0: table Util for Fusion 0.3.0 local fUtil = RailUtil.Fusion[&quot;0.3.0&quot;]  "},{"title":"[0.2.0]FusionUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/[0.2.0] FusionUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"[0.2.0]FusionUtil","url":"/ModulesOnRails/api/[0.2.0] FusionUtil#functions","content":" "},{"title":"isState​","type":1,"pageTitle":"[0.2.0]FusionUtil","url":"/ModulesOnRails/api/[0.2.0] FusionUtil#isState","content":"&lt;/&gt; [0.2.0] FusionUtil.isState( v: any-- The object to check ) → boolean-- Whether the value is a state object Checks if the given value is a state object. local a = Value(10) print( FusionUtil.isState(a) ) -- true   "},{"title":"isValue​","type":1,"pageTitle":"[0.2.0]FusionUtil","url":"/ModulesOnRails/api/[0.2.0] FusionUtil#isValue","content":"&lt;/&gt; [0.2.0] FusionUtil.isValue( v: any-- The object to check ) → boolean-- Whether the value is a state object with a set method Checks if the given value is a state object with a set method. local a = Value(10) print( FusionUtil.isValue(a) ) -- true   "},{"title":"use<T>​","type":1,"pageTitle":"[0.2.0]FusionUtil","url":"/ModulesOnRails/api/[0.2.0] FusionUtil#use<T>","content":"&lt;/&gt; [0.2.0] FusionUtil.use&lt;T&gt;( obj: CanBeState&lt;T&gt;-- The state or literal to get the value of ) → T-- The value of the state or literal Returns the given literal or state object's value. local a = Value(10) local b = 20 local use = FusionUtil.use print( use(a) ) -- 10 print( use(b) ) -- 20   "},{"title":"promiseStateChange​","type":1,"pageTitle":"[0.2.0]FusionUtil","url":"/ModulesOnRails/api/[0.2.0] FusionUtil#promiseStateChange","content":"&lt;/&gt; [0.2.0] FusionUtil.promiseStateChange( state: State&lt;any&gt;,-- The state to observe callback: ((value: any) → boolean)?-- An optional condition to check before resolving the promise ) → Promise-- The promise that will resolve when the state changes Creates a promise that resolves when the given state changes. If a callback is given then the callback must return true for the promise to resolve. local a = Value(10) FusionUtil.promiseStateChange(a, function(value) return value &gt; 10 end):andThen(function(value) print(&quot;Value is now greater than 10&quot;) end) a:set(5) -- Promise does not resolve a:set(15) -- Promise resolves   "},{"title":"formatAssetId​","type":1,"pageTitle":"[0.2.0]FusionUtil","url":"/ModulesOnRails/api/[0.2.0] FusionUtil#formatAssetId","content":"&lt;/&gt; [0.2.0] FusionUtil.formatAssetId( id: CanBeState&lt;string | number&gt;,-- The AssetId to format default: (string | number)?-- The default AssetId to use if the id is nil ) → CanBeState&lt;string&gt;-- The State that is synced with the AssetId Takes an AssetId and ensures it to a valid State. local assetId = FusionUtil.formatAssetId(&quot;rbxassetid://1234567890&quot;) print( use(assetId) ) -- &quot;rbxassetid://1234567890&quot; local assetId = FusionUtil.formatAssetId(1234567890) print( use(assetId) ) -- &quot;rbxassetid://1234567890&quot;   "},{"title":"ratio​","type":1,"pageTitle":"[0.2.0]FusionUtil","url":"/ModulesOnRails/api/[0.2.0] FusionUtil#ratio","content":"&lt;/&gt; [0.2.0] FusionUtil.ratio( numerator: CanBeState&lt;number&gt;,-- The numerator of the ratio denominator: CanBeState&lt;number&gt;,-- The denominator of the ratio mutator: (CanBeState&lt;T&gt; | (ratio: number) → T)?-- An optional State to scale by or a function to mutate the ratio ) → State&lt;T&gt;-- The ratio (Potentially mutated) Generates a computed that calculates the ratio of two numbers as a State. local numerator = Value(100) local denominator = Value(200) local ratio = FusionUtil.ratio(numerator, denominator) print( use(ratio) ) -- 0.5   "},{"title":"eq​","type":1,"pageTitle":"[0.2.0]FusionUtil","url":"/ModulesOnRails/api/[0.2.0] FusionUtil#eq","content":"&lt;/&gt; [0.2.0] FusionUtil.eq( stateToCheck1: CanBeState&lt;any&gt;,-- The first potential state to check stateToCheck2: CanBeState&lt;any&gt;-- The second potential state to check ) → State&lt;boolean&gt;-- A state resolving to the equality of the two given arguments A simple equality function that returns true if the two states are equal. local a = Value(10) local b = Value(10) local c = FusionUtil.eq(a, b) print( use(c) ) -- true a:set(20) print( use(c) ) -- false  "},{"title":"DropletManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#types","content":" "},{"title":"Droplet​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Droplet","content":"&lt;/&gt; type Droplet = Droplet   "},{"title":"ResourceTypeData​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#ResourceTypeData","content":"&lt;/&gt; type ResourceTypeData = ResourceTypeData   "},{"title":"ResourceSpawnData​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#ResourceSpawnData","content":"&lt;/&gt; type ResourceSpawnData = ResourceSpawnData  "},{"title":"Properties​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Server","content":"This item only works when running on the server. Server &lt;/&gt; DropletManager.Server: DropletServerManager Accessing this will automatically create a new DropletServerManager if one does not exist.  "},{"title":"Client​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Client","content":"This item only works when running on the client. Client &lt;/&gt; DropletManager.Client: DropletClientManager Accessing this will automatically create a new DropletClientManager if one does not exist.  "},{"title":"Util​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Util","content":"&lt;/&gt; DropletManager.Util: DropletUtil  "},{"title":"CmdrServer","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrServer","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#functions","content":" "},{"title":"PromiseCmdr​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#PromiseCmdr","content":"&lt;/&gt; CmdrServer:PromiseCmdr() → Promise&lt;Cmdr&gt; Promise that resolves to the Cmdr module data  "},{"title":"RegisterCommandFromModule​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#RegisterCommandFromModule","content":"&lt;/&gt; CmdrServer:RegisterCommandFromModule( module: ModuleScript -- The module to register the command from ) → Promise&lt;nil&gt; Registers a command from a module with Cmdr. Command modules must return a table of type CommandModuleData. -- Commands/Kill.lua return { Name = &quot;kill&quot;; Aliases = {&quot;slay&quot;}; Description = &quot;Kills a player or set of players.&quot;; Group = &quot;DefaultAdmin&quot;; -- The permission group required to run this command Args = { { Type = &quot;players&quot;; Name = &quot;victims&quot;; Description = &quot;The players to kill.&quot;; }, }; -- Executors ClientRun = nil, -- No client side needed ServerRun = function (_, players) for _, player in pairs(players) do if player.Character then player.Character:BreakJoints() end end return (&quot;Killed %d players.&quot;):format(#players) end } CmdrServer:RegisterCommandFromModule(script.Parent.Commands.Kill)   "},{"title":"ExecuteCommand​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#ExecuteCommand","content":"&lt;/&gt; CmdrServer:ExecuteCommand( commandText: string, executor: Player? , options: { Data: any?, IsHuman: boolean }? ) → Promise&lt;string&gt; Executes a command with Cmdr from the server CmdrServer:ExecuteCommand(&quot;kill Raildex&quot;):andThen(function(result) print(result) end)   "},{"title":"ExecuteCommandAsClient​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#ExecuteCommandAsClient","content":"&lt;/&gt; CmdrServer:ExecuteCommandAsClient( executor: Player , ...: string ) → () Executes a command with Cmdr as if it were run by a client CmdrServer:ExecuteCommandAsClient(Players.Raildex, &quot;kill&quot;, &quot;*&quot;) CmdrServer:ExecuteCommandAsClient(Players.Raildex, &quot;kill *&quot;)   "},{"title":"HasPermission​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#HasPermission","content":"&lt;/&gt; CmdrServer:HasPermission( plr: Player ,-- The player to check commandName: string-- The name of the command to check ) → boolean Checks if a player has permission to run a command  "},{"title":"GetPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetPermissions","content":"&lt;/&gt; CmdrServer:GetPermissions(plr: Player ) → {any} Gets the permissions for a player  "},{"title":"SetPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#SetPermissions","content":"&lt;/&gt; CmdrServer:SetPermissions( plr: Player , permissions: string | {string} ) → () Sets the direct permissions for a player. Does not override inherited permissions or group permissions. CmdrServer:SetPermissions(Players.Raildex, &quot;Admin&quot;) info The 'Creator' permission grants all permissions regardless of group inheritance.  "},{"title":"GivePermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GivePermissions","content":"&lt;/&gt; CmdrServer:GivePermissions( plr: Player ,-- The player to grant permissions to permissions: string | {string}-- The permissions to grant ) → () Grants a player a permission group(s). Adds the given permissions to the player's current permissions. CmdrServer:GivePermissions(Players.Raildex, &quot;Admin&quot;)   "},{"title":"GetGroupRankPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetGroupRankPermissions","content":"&lt;/&gt; CmdrServer:GetGroupRankPermissions( groupId: number,-- The Roblox group id to get permissions for rank: number-- The rank to get permissions for ) → {string}-- The permissions granted to the rank Gets the permissions granted to a particular rank in a group. local permissions = CmdrServer:GetGroupRankPermissions(15905255, 230)   "},{"title":"GiveGroupPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GiveGroupPermissions","content":"&lt;/&gt; CmdrServer:GiveGroupPermissions( groupId: number,-- The Roblox group id to grant permissions to ranks: number | NumberRange ,-- The ranks to apply the permissions to. Can be a single rank or a range of ranks. permissions: string | {string}-- The permissions to grant to the group ) → function-- A function that can be called to remove the permissions Grants a Roblox group permissions to run a command. Takes the ranks to apply the permissions to, and the permissions to grant. local revoke = CmdrServer:GiveGroupPermissions(15905255, 230, &quot;Admin&quot;)   "},{"title":"SetPermissionInheritance​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#SetPermissionInheritance","content":"&lt;/&gt; CmdrServer:SetPermissionInheritance( permissionGroup: string,-- The permission group to set the inheritance for inheritedGroups: string | {string}-- The groups to inherit permissions from ) → nil Sets the permission inheritance for a permission group. This will override any previous inheritance. CmdrServer:SetPermissionInheritance(&quot;Admin&quot;, &quot;DefaultAdmin&quot;) CmdrServer:SetPermissionInheritance(&quot;Admin&quot;, {&quot;DefaultAdmin&quot;, &quot;Moderator&quot;})   "},{"title":"GetPermissionInheritance​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetPermissionInheritance","content":"&lt;/&gt; CmdrServer:GetPermissionInheritance(permissionGroup: string) → {string} Fetches the inherited permission group for a permission group  "},{"title":"RegisterType​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#RegisterType","content":"&lt;/&gt; CmdrServer:RegisterType( name: string,-- The name of the type typeData: TypeDefinition&lt;T&gt;-- The type data to register ) → Promise Registers a type with Cmdr "},{"title":"CmdrTypes","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrTypes","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#types","content":" "},{"title":"ArgumentContext<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#ArgumentContext<T>","content":"&lt;/&gt; interface ArgumentContext&lt;T&gt; { Command: CommandContext&lt;T&gt;-- The command context this argument belongs to. Name: string-- The name of the argument Type: TypeDefinition&lt;T&gt;-- The type definition of the argument Required: boolean-- Whether or not this argument is required Executor: Player -- The player that ran the command this argument belongs to. RawValue: string-- The raw value of the argument RawSegments: {string}-- The raw segments of the argument Prefix: string-- The prefix of the argument }   "},{"title":"CommandContext<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandContext<T>","content":"&lt;/&gt; interface CommandContext&lt;T&gt; { Executor: Player -- The player who executed the command Name: string-- the name of the command Description: string-- the description of the command Alias: string-- The specific alias of this command that was used to trigger this command (may be the same as Name) Aliases: {string}-- The list of aliases that could have been used to trigger this command Group: any-- The group this command is a part of. Defined in command definitions, typically a string. RawText: string-- the raw text of the command RawArguments: {string}-- the raw arguments of the command Arguments: {ArgumentContext&lt;T&gt;}-- the parsed arguments of the command Cmdr: table Dispatcher: table-- the dispatcher that ran the command State: table-- A blank table that can be used to store user-defined information about this command's current execution. This could potentially be used with hooks to add information to this table which your command or other hooks could consume. }   "},{"title":"TypeDefinition<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#TypeDefinition<T>","content":"&lt;/&gt; interface TypeDefinition&lt;T&gt; { DisplayName: string-- The display name of the type Prefixes: string-- The prefixes that this type can use Transform: ( rawText: string, executor: Player ) → any-- A function that transforms the raw text into the desired type Validate: (value: T) → ( boolean, string? )-- A function that validates the value. Returns a boolean and an optional error message. ValidateOnce: (value: T) → ( boolean, string? )-- A function that validates the value once. Returns a boolean and an optional error message. Autocomplete: (value: T) → ( {string}, {IsPartial: boolean?} )-- A function that returns a list of possible completions for the value. Returns a list of strings and an optional boolean indicating if the completions are partial. Parse: (value: T) → any-- A function that parses the value Default: (plr: Player ) → string-- A function that returns the default value for the type Listable: boolean-- Whether or not this type is listable }   "},{"title":"CommandArgument​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandArgument","content":"&lt;/&gt; interface CommandArgument { Type: string | TypeDefinition&lt;any&gt;-- The type of the argument Name: string-- The name of the argument Description: string-- The description of the argument Optional: boolean-- Whether or not this argument is optional Default: any-- The default value of the argument }   "},{"title":"CommandDefinition<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandDefinition<T>","content":"&lt;/&gt; interface CommandDefinition&lt;T&gt; { Name: string-- The name of the command Description: string-- The description of the command Aliases: {string}?-- The aliases of the command Group: any?-- The group this command is a part of Args: {CommandArgument | (context: CommandContext&lt;T&gt;) → CommandArgument}-- The arguments of the command Data: (( context: CommandContext&lt;T&gt;, ...any ) → any)?-- The data of the command AutoExec: {string}?-- The autoexec of the command ClientRun: (( context: CommandContext&lt;T&gt;, ...any ) → string?)?-- The client run of the command }  "},{"title":"BaseComponent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseComponent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#functions","content":" "},{"title":"GetAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetAttribute","content":"&lt;/&gt; BaseComponent:GetAttribute( attributeName: string-- The name of the attribute to fetch ) → any?-- The current value of the attribute Fetches the current Value of an attribute on the Component Instance  "},{"title":"SetAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#SetAttribute","content":"&lt;/&gt; BaseComponent:SetAttribute( attributeName: string,-- The name of the attribute to set value: any-- The value to set the attribute to ) → () Sets an attribute of this Component's instance to a value  "},{"title":"IncrementAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#IncrementAttribute","content":"&lt;/&gt; BaseComponent:IncrementAttribute( attributeName: string,-- The name of the attribute to increment increment: number?-- The amount to increment the attribute by. Defaults to 1 ) → number-- The new value of the attribute Increments the current value of the attribute by the increment. If no increment is provided, it defaults to 1  "},{"title":"UpdateAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#UpdateAttribute","content":"&lt;/&gt; BaseComponent:UpdateAttribute( attributeName: string,-- The name of the attribute to mutate mutator: ((value: any) → (any))-- The function to mutate the attribute with ) → any-- The new value of the attribute Updates the current value of the attribute into a new value from the return of the mutator function  "},{"title":"ObserveAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#ObserveAttribute","content":"&lt;/&gt; BaseComponent:ObserveAttribute( attributeName: string,-- The name of the attribute to observe callback: ((newValue: any) → ())-- The function to call when the attribute changes ) → function-- A function to disconnect the observer Watches for when the attribute changes and calls the callback. Also calls the callback initially with the current value  "},{"title":"OutAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#OutAttribute","content":"&lt;/&gt; BaseComponent:OutAttribute( attributeName: string-- The name of the attribute to fetch ) → Value&lt;any&gt;-- The synchronized fusion value of the attribute Fetches an attribute and turns into into a synchronized usable value  "},{"title":"DefaultAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#DefaultAttribute","content":"&lt;/&gt; BaseComponent:DefaultAttribute( attributeName: string,-- The name of the attribute to set value: any,-- The value to set the attribute to validDataTypes: {string}?-- A list of valid data types for the attribute ) → any-- The value of the attribute Sets an attribute to a default value if it is not already set, allows for type checking of the initial value  "},{"title":"AttributeChanged​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AttributeChanged","content":"&lt;/&gt; BaseComponent:AttributeChanged( attributeName: string,-- The name of the attribute to observe fn: ((...any) → ())?-- The function to call when the attribute changes ) → RBXScriptConnection | RBXScriptSignal -- A function to disconnect the observer or the signal Fetches the AttributeChanged signal for the attribute if no function is given. If a function is provided, it will connect the function to the attribute changed signal and return the connection  "},{"title":"GetScope​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetScope","content":"&lt;/&gt; BaseComponent:GetScope() → Scope&lt;any&gt; Returns a scope associated with the lifecycle of the component. Inherits methods from RailUtil.Fusion and Fusion.  "},{"title":"AddPromise​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AddPromise","content":"&lt;/&gt; BaseComponent:AddPromise(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Adds a promise to the component's janitor. Returns the same promise that was given.  "},{"title":"AddTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AddTask","content":"&lt;/&gt; BaseComponent:AddTask( task: T, cleanupMethod: (string | true)?, index: any? ) → T-- The same task that was given Adds a task to the component's janitor.  "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RemoveTaskNoClean","content":"&lt;/&gt; BaseComponent:RemoveTaskNoClean( index: any-- The index of the task to remove. ) → () Removes a task from the component's janitor without cleaning it.  "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RemoveTask","content":"&lt;/&gt; BaseComponent:RemoveTask( index: any,-- The id of the task to remove. dontClean: boolean?-- Optional flag to not clean the task. ) → () Removes a task from the component's janitor.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetTask","content":"&lt;/&gt; BaseComponent:GetTask( index: any-- The id of the task to get. ) → any-- The task that was retrieved. Gets a task from the janitor.  "},{"title":"ObserveProperty​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#ObserveProperty","content":"&lt;/&gt; BaseComponent:ObserveProperty( propertyName: string,-- The name of the property to observe callback: ((newValue: any) → ())-- The function to call when the property changes ) → function-- A function to disconnect the observer Watches for when the property changes and calls the callback. Also calls the callback initially with the current value  "},{"title":"OutProperty​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#OutProperty","content":"&lt;/&gt; BaseComponent:OutProperty( propertyName: string-- The name of the property to fetch ) → Value&lt;any&gt;-- The synchronized fusion value of the property Fetches an property and turns into into a synchronized usable value  "},{"title":"PropertyChanged​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#PropertyChanged","content":"&lt;/&gt; BaseComponent:PropertyChanged( propertyName: string,-- The name of the property to observe fn: ((...any) → ())?,-- The function to call when the property changes connectOnce: boolean?-- If true, the function will only be called the first time the property changes ) → RBXScriptConnection | RBXScriptSignal -- A connection or signal Fetches the PropertyChanged signal for the property if no function is given. If a function is provided, it will connect the function to the property changed signal and return the connection  "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RegisterSignal","content":"&lt;/&gt; BaseComponent:RegisterSignal( signalName: string-- The name of the signal to register. ) → Signal-- The signal that was registered. Registers a signal to the component.  "},{"title":"GetSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetSignal","content":"&lt;/&gt; BaseComponent:GetSignal( signalName: string-- The name of the signal to get. ) → Signal-- The signal that was retrieved. Gets a signal from the component.  "},{"title":"FireSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#FireSignal","content":"&lt;/&gt; BaseComponent:FireSignal( signalName: string,-- The name of the signal to fire. ...: any-- The arguments to pass to the signal. ) → () Fires a signal from the component. "},{"title":"PlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerDataManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#types","content":" "},{"title":"ServerPlayerDataManager​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#ServerPlayerDataManager","content":"&lt;/&gt; type ServerPlayerDataManager = ServerPlayerDataManager   "},{"title":"ClientPlayerDataManager​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#ClientPlayerDataManager","content":"&lt;/&gt; type ClientPlayerDataManager = ClientPlayerDataManager  "},{"title":"Properties​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#Server","content":"This item only works when running on the server. Server &lt;/&gt; PlayerDataManager.Server: ServerPlayerDataManager The ServerPlayerDataManager class.  "},{"title":"Client​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#Client","content":"This item only works when running on the client. Client &lt;/&gt; PlayerDataManager.Client: ClientPlayerDataManager The ClientPlayerDataManager class. "},{"title":"DropletServerManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletServerManager","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#new","content":"constructor &lt;/&gt; DropletServerManager.new() → DropletServerManager Creates a new DropletServerManager if one has not already been made, returns the existing one if one already exists.  "},{"title":"RegisterResourceType​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#RegisterResourceType","content":"&lt;/&gt; DropletServerManager:RegisterResourceType( resourceType: string, data: ResourceTypeData ) → () Registers a new resource type. Attempting to register a resource type with the same name as an existing one will error. local data = Import(&quot;ExampleResourceTypeData&quot;) -- This is an Example file included in the package you can check out. DropletServerManager:RegisterResourceType(&quot;Example&quot;, data)   "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#GetResourceTypeData","content":"&lt;/&gt; DropletServerManager:GetResourceTypeData(resourceType: string) → ResourceTypeData? Returns the resource type data for the given resource type.  "},{"title":"Spawn​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Spawn","content":"&lt;/&gt; DropletServerManager:Spawn( data: ResourceSpawnData-- The data used to spawn the droplet. ) → number-- The seed of the droplet request. Creates a new droplet request to create some defined number of droplets of a given ResourceType. The droplet request will be created on the server and replicated to the clients. A PlayerTargets array can be passed to specify which players the droplet request should be replicated to, if one isnt given it replicates to all connected players at the moment of the request. Caveats Some properties of the interface have special behaviors depending on their type. See 'ResourceSpawnData' for more info on important caveats and behavior. local Bounds = 35 local seed = DropletServerManager:Spawn({ ResourceType = &quot;Example&quot;; Value = NumberRange.new(0.6, 1.4); Count = NumberRange.new(2, 10); LifeTime = NumberRange.new(10, 20); SpawnLocation = Vector3.new( math.random(-Bounds,Bounds), 7, math.random(-Bounds,Bounds) ); CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector; })   "},{"title":"Claim​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Claim","content":"&lt;/&gt; DropletServerManager:Claim( collector: Player ,-- The player claiming the droplet. seed: number,-- The droplet request identifier. dropletNumber: number?-- The particular droplet number to claim. If nil, all remaining droplets will be claimed. ) → boolean-- Whether or not the claim was successful. Force claim a droplet(s) for a player.  "},{"title":"Collect​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Collect","content":"&lt;/&gt; DropletServerManager:Collect( collector: Player ,-- The player collecting the resource. seed: number,-- The droplet request identifier. dropletNumber: number?-- The particular droplet number to collect. If nil, all droplets will be collected. ) → boolean-- Whether or not the collection was successful. Force collects a droplet(s) resource and returns whether or not the collection was successful.  "},{"title":"GetCollectionRadius​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#GetCollectionRadius","content":"&lt;/&gt; DropletServerManager:GetCollectionRadius(player: Player ) → number Gets the collection radius for the given player.  "},{"title":"SetCollectionRadius​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#SetCollectionRadius","content":"&lt;/&gt; DropletServerManager:SetCollectionRadius( player: Player , radius: number ) → () Sets the collection radius for the given player. "},{"title":"[0.2.5]FusionUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/[0.2.5] FusionUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#functions","content":" "},{"title":"promiseStateChange​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#promiseStateChange","content":"&lt;/&gt; [0.2.5] FusionUtil.promiseStateChange( state: State&lt;any&gt;,-- The state to observe callback: ((value: any) → boolean)?-- An optional condition to check before resolving the promise ) → Promise-- The promise that will resolve when the state changes Creates a promise that resolves when the given state changes. If a callback is given then the callback must return true for the promise to resolve. local a = Value(10) FusionUtil.promiseStateChange(a, function(value) return value &gt; 10 end):andThen(function(value) print(&quot;Value is now greater than 10&quot;) end) a:set(5) -- Promise does not resolve a:set(15) -- Promise resolves   "},{"title":"defaultProps​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#defaultProps","content":"&lt;/&gt; [0.2.5] FusionUtil.defaultProps( explicitProps: Props,-- The props to use defaultProps: Props-- The default props that to fill in the gaps of explicit ) → table-- The reconciled props Similar to a shallow reconcile, but also moves any children at numeric indices  "},{"title":"ensureIsState​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#ensureIsState","content":"&lt;/&gt; [0.2.5] FusionUtil.ensureIsState( data: CanBeState&lt;T&gt;?,-- The potential state object defaultValue: T?,-- The default value to use if the data is nil datatype: (string | {string})?-- The type or types of the data expected in the state ) → StateObject&lt;T&gt;-- The existing or newly created state object Ensures a passed data is a StateObject. If it is not, it will be converted to one.  "},{"title":"ensureIsValue​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#ensureIsValue","content":"&lt;/&gt; [0.2.5] FusionUtil.ensureIsValue( data: T | Value&lt;T&gt;,-- The potential value defaultValue: T?,-- The default value to use if the data is nil or an invalid type datatype: (string | {string})?-- The type or types of the data expected in the value ) → Value&lt;T&gt;-- The existing or newly created value Ensures the given data is a settable Value. Allows for passing of a default value and a datatype to check against.  "},{"title":"syncValues​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#syncValues","content":"&lt;/&gt; [0.2.5] FusionUtil.syncValues( stateToWatch: State&lt;any&gt;,-- The state to watch for changes valueToSet: Value&lt;any&gt;-- The value to set when the state changes ) → () → ()-- A function that will disconnect the observer Syncronizes a StateObject to a Value. The Value will be set to the StateObject's value any time it changes. local a = Value(123) local b = Value(0) local disconnect = FusionUtil.syncValues(a, b) print( peek(b) ) -- 123 a:set(456) print( peek(b) ) -- 456 disconnect()   "},{"title":"ensureAssetId​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#ensureAssetId","content":"&lt;/&gt; [0.2.5] FusionUtil.ensureAssetId( id: CanBeState&lt;string | number&gt;,-- The AssetId to ensure default: (string | number)?-- The default AssetId to use if the id is nil ) → CanBeState&lt;string&gt;-- The State that is synced with the AssetId Takes an AssetId and ensures it to a valid State. local assetId = FusionUtil.ensureAssetId(&quot;rbxassetid://1234567890&quot;) print( peek(assetId) ) -- &quot;rbxassetid://1234567890&quot; local assetId = FusionUtil.ensureAssetId(1234567890) print( peek(assetId) ) -- &quot;rbxassetid://1234567890&quot;   "},{"title":"ratio​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#ratio","content":"&lt;/&gt; [0.2.5] FusionUtil.ratio( numerator: CanBeState&lt;number&gt;,-- The numerator of the ratio denominator: CanBeState&lt;number&gt;,-- The denominator of the ratio mutator: (CanBeState&lt;T&gt; | ( ratio: number, use: Use ) → T)?-- An optional State to scale by or a function to mutate the ratio ) → State&lt;T&gt;-- The ratio (Potentially mutated) Generates a computed that calculates the ratio of two numbers as a State. local numerator = Value(100) local denominator = Value(200) local ratio = FusionUtil.ratio(numerator, denominator) print( peek(ratio) ) -- 0.5   "},{"title":"ratioUDim2​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#ratioUDim2","content":"&lt;/&gt; [0.2.5] FusionUtil.ratioUDim2( numerator: CanBeState&lt;number&gt;,-- The numerator of the ratio denominator: CanBeState&lt;number&gt;,-- The denominator of the ratio v: CanBeState&lt;UDim2 &gt;-- The UDim2 to scale ) → State&lt;UDim2 &gt;-- The scaled UDim2 Wraps FusionUtil.ratio with a handler for UDim2s local numerator = Value(100) local denominator = Value(200) local size = Value(UDim2.new(0.2, 100, 0.2, 100)) local sizeAdjusted = FusionUtil.ratioUDim2(numerator, denominator, size) print( peek(sizeAdjusted) ) -- UDim2.new(0.1, 50, 0.1, 50)   "},{"title":"screenRatio​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#screenRatio","content":"This item only works when running on the client. Client &lt;/&gt; [0.2.5] FusionUtil.screenRatio( mutator: (CanBeState&lt;T&gt; | ( ratio: number, use: Use ) → T)?,-- An optional State to scale by or a function to mutate the ratio ratioFn: any-- An optional function to use for the ratio, defaults to FusionUtil.ratio, but could be given something like FusionUtil.ratioUDim2 ) → () This wraps FusionUtil.ratio with a handler for scaling states/functions with the Screen Height. local paddingOffset = Value(10) local paddingAdjusted = FusionUtil.screenRatio(paddingOffset) local size = Value(UDim2.new(0, 100, 0, 100)) local sizeAdjusted = FusionUtil.screenRatio(size, FusionUtil.ratioUDim2) local x = Value(10) local y = Value(20) local z = FusionUtil.screenRatio(function(ratio, use) return (use(x) + use(y)) * ratio end)   "},{"title":"lerpNumber​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#lerpNumber","content":"&lt;/&gt; [0.2.5] FusionUtil.lerpNumber( n1: CanBeState&lt;number&gt;,-- The first number state n2: CanBeState&lt;number&gt;,-- The second number state alpha: CanBeState&lt;number&gt;,-- The alpha state _use: ((any) → (any))?-- An optional function to use to get the values of the states ) → State&lt;number&gt; | number-- The resultant lerped number state Lerps between two number states. If no use function is given then it returns a state local a = Value(10) local b = Value(20) local alpha = Value(0.5) local z = FusionUtil.lerpNumber(a, b, alpha) print( peek(z) ) -- 15   "},{"title":"ifThenElse​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#ifThenElse","content":"&lt;/&gt; [0.2.5] FusionUtil.ifThenElse( stateToCheck: State&lt;boolean&gt;,-- The condition to check trueOutcome: CanBeState&lt;X&gt;,-- The value to return if the condition is true falseOutcome: CanBeState&lt;Y&gt;-- The value to return if the condition is false ) → State&lt;X | Y&gt;-- The value that was returned A simple swap function that returns the first value if the condition is true, otherwise returns the second value. Helps with simplifying lots of bulky computeds. local a = Value(10) local b = Value(20) local y = Value(false) local z = FusionUtil.ifThenElse(y, a, b) print( peek(z) ) -- 20 y:set(true) print( peek(z) ) -- 10   "},{"title":"eq​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#eq","content":"&lt;/&gt; [0.2.5] FusionUtil.eq( stateToCheck1: CanBeState&lt;any&gt;,-- The first potential state to check stateToCheck2: CanBeState&lt;any&gt;-- The second potential state to check ) → State&lt;boolean&gt;-- A state resolving to the equality of the two given arguments A simple equality function that returns true if the two states are equal. local a = Value(10) local b = Value(10) local c = FusionUtil.eq(a, b) print( peek(c) ) -- true a:set(20) print( peek(c) ) -- false   "},{"title":"ifExists​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#ifExists","content":"&lt;/&gt; [0.2.5] FusionUtil.ifExists( value: any?,-- Value to check existance. fn: (T...) → U...,-- Callback to run if 'value' exists. ...: any-- Args to be passed to the callback. ) → U...?-- The returned value of the callback if 'value' exists. Checks if a given value exists, if it does then this returns the returned value of the passed function.  "},{"title":"ifIsState​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#ifIsState","content":"&lt;/&gt; [0.2.5] FusionUtil.ifIsState( state: any?,-- State to check existence. fn: (T...) → U...,-- Callback to run if 'value' is a state. ...: any-- Args to be passed to the callback. ) → U...?-- The returned value of the callback if 'value' exists. Checks if a given value is a state, if it does then this returns the returned value of the passed function.  "},{"title":"observeState​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#observeState","content":"&lt;/&gt; [0.2.5] FusionUtil.observeState( fusionState: State&lt;any&gt;,-- The state object to observe callback: (stateValue: any) → ()-- The callback to call when the fusionState is updated ) → () → ()-- A function that will disconnect the observer Calls the provided callback immediately with the initial state and again anytime the state updates.  "},{"title":"watchAttribute​","type":1,"pageTitle":"[0.2.5]FusionUtil","url":"/ModulesOnRails/api/[0.2.5] FusionUtil#watchAttribute","content":"deprecated in v1.0.0 &lt;/&gt; This was deprecated in v1.0.0 Use Fusion's Attribute System instead [0.2.5] FusionUtil.watchAttribute( parent: Instance ,-- The parent instance to watch for attribute changes attribute: string,-- The name of the attribute to watch defaultValue: any?-- The default value to use if the attribute is nil ) → ( State,-- The state object that is synced with the value () → ()-- A function that will disconnect the observer ) Syncronizes an instances attribute to a Value. The value will be set to the attribute's value any time it changes. This is superceded by Fusion's Attribute System and should no longer be used. "},{"title":"PlayerUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#functions","content":" "},{"title":"getCharactersFolder​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#getCharactersFolder","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; PlayerUtil.getCharactersFolder() → Folder -- The characters folder Returns the characters folder, creating it if it doesn't exist. This folder is used to store all characters in the game. This folder is created on the server and waited for on the client.  "},{"title":"promiseCharacter​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#promiseCharacter","content":"&lt;/&gt; PlayerUtil.promiseCharacter( plr: Player ,-- The player to get the character of timeOut?: number?-- The amount of time to wait before rejecting the promise ) → Promise&lt;Character&gt;-- A promise that resolves when the character is retrieved Returns a promise that resolves with the character of the specified player once their character is within the proper folder.  "},{"title":"getPlayerFromCharacterDescendant​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#getPlayerFromCharacterDescendant","content":"&lt;/&gt; PlayerUtil.getPlayerFromCharacterDescendant( descendant: Instance -- The descendant to get the player of ) → Player? -- The player that owns the character Returns the player that owns the specified descendant of a character. Returns nil if the descendant is not a descendant of a character.  "},{"title":"getCharacterFromDescendant​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#getCharacterFromDescendant","content":"&lt;/&gt; PlayerUtil.getCharacterFromDescendant( descendant: Instance -- The descendant to get the character of ) → Character?-- The character that owns the descendant Returns the character that owns the specified descendant. Returns nil if the descendant is not a descendant of a character.  "},{"title":"getAllLoadedCharacters​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#getAllLoadedCharacters","content":"&lt;/&gt; PlayerUtil.getAllLoadedCharacters() → {Character}-- A table of all the fully loaded characters   "},{"title":"forEachCharacter​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#forEachCharacter","content":"&lt;/&gt; PlayerUtil.forEachCharacter( func: ( char: Character, janitor: Janitor ) → (),-- A passed function to be executed for each character, it is given the character as an argument. Also receives a Janitor object that can be used to clean up any connections made. player: Player? -- An optional player to only run the function for their character. ) → Connection-- A connection that can be Disconnected or Destroyed to stop method's activities. Takes a function that will be run for every player in the game as well as any future players until the returned connection is disconnected.  "},{"title":"forEachPlayer​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#forEachPlayer","content":"&lt;/&gt; PlayerUtil.forEachPlayer( func: ( player: Player , janitor: Janitor ) → ()-- A passed function to be executed for each player, it is given the player as an argument. ) → Connection-- A connection that can be Disconnected or Destroyed to stop method's activities. Takes a function that will be run for every player in the game as well as any future players until the returned connection is disconnected.  "},{"title":"onPlayerRemoving​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#onPlayerRemoving","content":"&lt;/&gt; PlayerUtil.onPlayerRemoving( player: Player , fn: (T...) → (),-- The function to be run when the player disconnects. ...: T... ) → Connection-- A connection that can be Disconnected or Destroyed to stop method's activities. Takes a function that will be run for a specified player when they leave.  "},{"title":"setupCharacterInitialization​","type":1,"pageTitle":"PlayerUtil","url":"/ModulesOnRails/api/PlayerUtil#setupCharacterInitialization","content":"&lt;/&gt; PlayerUtil.setupCharacterInitialization(func: (char: Character) → ()?) → any Sets up code to auto parent characters to the Characters folder when they spawn. Optionally, a function can be passed to run immediately prior to when a character is added to the folder. "},{"title":"ClientComm","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#types","content":" "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions.  "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#new","content":"&lt;/&gt; ClientComm.new( parent: Instance , usePromise: boolean, namespace: string? ) → ClientComm Constructs a ClientComm object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds. local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true) -- If using a unique namespace with ServerComm, include it as second argument: local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true, &quot;MyNamespace&quot;)   "},{"title":"new​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#new","content":"&lt;/&gt; ClientComm.new( parent: Instance , usePromise: boolean, namespace: string? ) → ClientComm Constructs a ClientComm object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds. local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true) -- If using a unique namespace with ServerComm, include it as second argument: local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true, &quot;MyNamespace&quot;)   "},{"title":"GetFunction​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetFunction","content":"&lt;/&gt; ClientComm:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerComm. The function can then be called to invoke the server. If this ClientComm object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverComm = ServerComm.new(someParent) serverComm:BindFunction(&quot;MyFunction&quot;, function(player, msg) return msg:upper() end) -- Client-side: local clientComm = ClientComm.new(someParent) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientComm = ClientComm.new(someParent, true) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetSignal","content":"&lt;/&gt; ClientComm:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerComm with the same matching name. local mySignal = clientComm:GetSignal(&quot;MySignal&quot;) -- Listen for data from the server: mySignal:Connect(function(message) print(&quot;Received message from server:&quot;, message) end) -- Send data to the server: mySignal:Fire(&quot;Hello!&quot;)   "},{"title":"GetProperty​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetProperty","content":"&lt;/&gt; ClientComm:GetProperty( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteProperty Returns a new ClientRemoteProperty that mirrors the matching RemoteProperty created by ServerComm with the same matching name. Take a look at the ClientRemoteProperty documentation for more info, such as understanding how to wait for data to be ready. local mapInfo = clientComm:GetProperty(&quot;MapInfo&quot;) -- Observe the initial value of mapInfo, and all subsequent changes: mapInfo:Observe(function(info) print(&quot;Current map info&quot;, info) end) -- Check to see if data is initially ready: if mapInfo:IsReady() then -- Get the data: local info = mapInfo:Get() end -- Get a promise that resolves once the data is ready (resolves immediately if already ready): mapInfo:OnReady():andThen(function(info) print(&quot;Map info is ready with info&quot;, info) end) -- Same as above, but yields thread: local success, info = mapInfo:OnReady():await()   "},{"title":"BuildObject​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#BuildObject","content":"&lt;/&gt; ClientComm:BuildObject( inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → table Returns an object which maps RemoteFunctions as methods and RemoteEvents as fields. -- Server-side: serverComm:BindFunction(&quot;Test&quot;, function(player) end) serverComm:CreateSignal(&quot;MySignal&quot;) serverComm:CreateProperty(&quot;MyProperty&quot;, 10) -- Client-side local obj = clientComm:BuildObject() obj:Test() obj.MySignal:Connect(function(data) end) obj.MyProperty:Observe(function(value) end)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#Destroy","content":"&lt;/&gt; ClientComm:Destroy() → () Destroys the ClientComm object. Sets the objects to be a table that errors if you attempt to access any property.  "},{"title":"GetFunction​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetFunction","content":"&lt;/&gt; ClientComm:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerComm. The function can then be called to invoke the server. If this ClientComm object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverComm = ServerComm.new(someParent) serverComm:BindFunction(&quot;MyFunction&quot;, function(player, msg) return msg:upper() end) -- Client-side: local clientComm = ClientComm.new(someParent) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientComm = ClientComm.new(someParent, true) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetSignal","content":"&lt;/&gt; ClientComm:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerComm with the same matching name. local mySignal = clientComm:GetSignal(&quot;MySignal&quot;) -- Listen for data from the server: mySignal:Connect(function(message) print(&quot;Received message from server:&quot;, message) end) -- Send data to the server: mySignal:Fire(&quot;Hello!&quot;)   "},{"title":"GetProperty​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetProperty","content":"&lt;/&gt; ClientComm:GetProperty( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteProperty Returns a new ClientRemoteProperty that mirrors the matching RemoteProperty created by ServerComm with the same matching name. Take a look at the ClientRemoteProperty documentation for more info, such as understanding how to wait for data to be ready. local mapInfo = clientComm:GetProperty(&quot;MapInfo&quot;) -- Observe the initial value of mapInfo, and all subsequent changes: mapInfo:Observe(function(info) print(&quot;Current map info&quot;, info) end) -- Check to see if data is initially ready: if mapInfo:IsReady() then -- Get the data: local info = mapInfo:Get() end -- Get a promise that resolves once the data is ready (resolves immediately if already ready): mapInfo:OnReady():andThen(function(info) print(&quot;Map info is ready with info&quot;, info) end) -- Same as above, but yields thread: local success, info = mapInfo:OnReady():await()   "},{"title":"BuildObject​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#BuildObject","content":"&lt;/&gt; ClientComm:BuildObject( inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → table Returns an object which maps RemoteFunctions as methods and RemoteEvents as fields. -- Server-side: serverComm:BindFunction(&quot;Test&quot;, function(player) end) serverComm:CreateSignal(&quot;MySignal&quot;) serverComm:CreateProperty(&quot;MyProperty&quot;, 10) -- Client-side local obj = clientComm:BuildObject() obj:Test() obj.MySignal:Connect(function(data) end) obj.MyProperty:Observe(function(value) end)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#Destroy","content":"&lt;/&gt; ClientComm:Destroy() → () Destroys the ClientComm object. "},{"title":"BaseTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#types","content":" "},{"title":"Id​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Id","content":"&lt;/&gt; type Id = number The id of a replicator.  "},{"title":"SearchCondition​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#SearchCondition","content":"&lt;/&gt; type SearchCondition = string | ClassToken | Tags | ( replicator: BaseTableReplicator, manager: TableManager? ) → (boolean) A condition that can be used to filter replicators. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If the condition is a function then it should return a boolean to indicate success. If the condition is a ClassToken then it will check if the replicator's class token matches the given token. If the condition is a string then it will check if the replicator's class token name matches the given string. If the condition is a Tags dictionary then it will check if the replicator's tags are a superset of the given tags.  "},{"title":"Tags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Tags","content":"&lt;/&gt; type Tags = {[string]: any} The valid tag format that can be given to a TableReplicator. This table will become locked once given to a TableReplicator. Do not attempt to modify it after the fact. local tags = table.freeze { OwnerId = Player.UserId; ToolType = &quot;Sword&quot;; }  "},{"title":"Properties​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#properties","content":" "},{"title":"ReplicatorCreated​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#ReplicatorCreated","content":"&lt;/&gt; BaseTableReplicator.ReplicatorCreated: Signal&lt;BaseTableReplicator&gt; A signal that fires whenever a new replicator is created. "},{"title":"Functions​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#functions","content":" "},{"title":"iterating over BaseTableReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#__iter","content":"Metamethod &lt;/&gt; for in BaseTableReplicator do Iterates over all replicators that are currently in memory. for _, replicator in TableReplicator do print(replicator:GetServerId()) end   "},{"title":"getFromServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getFromServerId","content":"Static &lt;/&gt; BaseTableReplicator.getFromServerId(id: Id) → BaseTableReplicator? Returns the replicator with the given id if one exists.  "},{"title":"forEach​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#forEach","content":"Static &lt;/&gt; BaseTableReplicator.forEach( condition: SearchCondition, fn: ( replicator: BaseTableReplicator, manager: TableManager? ) → (), allowDestroyedReplicators: boolean? ) → () forEach is a special function that allows you to run a function on all replicators that currently exist or will exist that match the given condition. caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned.  "},{"title":"promiseFirstReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#promiseFirstReplicator","content":"Static &lt;/&gt; BaseTableReplicator.promiseFirstReplicator( condition: SearchCondition, allowDestroyedReplicators: boolean? ) → Promise&lt;BaseTableReplicator,TableManager?&gt; promiseFirstReplicator is a special function that allows you to run a function on the first replicator to satisfy the given condition. If no replicator currently exists that satisfies the condition then it will wait for one to be created. BaseTableReplicator.promiseFirstReplicator(&quot;Test&quot;) caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned.  "},{"title":"getAll​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getAll","content":"Static &lt;/&gt; BaseTableReplicator.getAll(classTokenName: string?) → {BaseTableReplicator} Fetches all replicators that are currently in memory. This is very slow and should be used sparingly.  "},{"title":"onNew​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#onNew","content":"Static &lt;/&gt; BaseTableReplicator.onNew( classToken: CanBeArray&lt;string | ClassToken&gt;, fn: (replicator: BaseTableReplicator) → () ) → () → () Listens for new replicators that are created with the given class token.  "},{"title":"GetTableManager​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTableManager","content":"&lt;/&gt; BaseTableReplicator:GetTableManager() → TableManager Gets the TableManager that is being replicated.  "},{"title":"GetServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetServerId","content":"&lt;/&gt; BaseTableReplicator:GetServerId() → Id Returns the server id for this replicator. On the Server this is equivalent to :GetId()  "},{"title":"GetTokenName​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTokenName","content":"&lt;/&gt; BaseTableReplicator:GetTokenName() → string Fetches the name of the class token that this replicator is using.  "},{"title":"IsTopLevel​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsTopLevel","content":"&lt;/&gt; BaseTableReplicator:IsTopLevel() → boolean Returns whether or not this replicator is a top level replicator. A top level replicator is a replicator that has no parent. Only top level replicators can have their ReplicationTargets set.  "},{"title":"GetParent​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetParent","content":"&lt;/&gt; BaseTableReplicator:GetParent() → BaseTableReplicator? Returns the parent of this replicator if it has one. If this replicator is a top level replicator then this will return nil.  "},{"title":"GetChildren​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetChildren","content":"&lt;/&gt; BaseTableReplicator:GetChildren() → {BaseTableReplicator} Returns the immediate children of this replicator.  "},{"title":"GetDescendants​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetDescendants","content":"&lt;/&gt; BaseTableReplicator:GetDescendants() → {BaseTableReplicator} Returns the descendants of this replicator.  "},{"title":"FindFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#FindFirstChild","content":"&lt;/&gt; BaseTableReplicator:FindFirstChild( condition: SearchCondition, recursive: boolean? ) → BaseTableReplicator? Finds the first child that satisfies the given condition. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If recursive is true then it will search through all descendants. local child = tr:FindFirstChild(function(child) local manager = child:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 })   "},{"title":"PromiseFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#PromiseFirstChild","content":"&lt;/&gt; BaseTableReplicator:PromiseFirstChild(condition: SearchCondition) → Promise&lt;BaseTableReplicator&gt; Returns a promise that resolves when the first child that satisfies the given function is found. tr:PromiseFirstChild(function(replicator) local manager = replicator:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 }):andThen(function(replicator) print(&quot;Found child with data key 'Test' equal to 1!&quot;) end) tr:PromiseFirstChild(&quot;Test&quot;):andThen(function(replicator) print(&quot;Found child with classtoken 'Test'!&quot;) end) tr:PromiseFirstChild({UserId == 12345}):andThen(function(replicator) print(&quot;Found child with UserId Tag matching 12345!&quot;) end)   "},{"title":"GetTag​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTag","content":"&lt;/&gt; BaseTableReplicator:GetTag(tagKey: string) → any Returns the value of the given tag for this replicator.  "},{"title":"GetTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTags","content":"&lt;/&gt; BaseTableReplicator:GetTags() → Tags Returns the tags dictionary for this replicator.  "},{"title":"IsSupersetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSupersetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSupersetOfTags(tags: Tags) → boolean Checks whether or not the given tags are a subset of this replicator's tags. ELI5: Are all the given tags also on this replicator? Aliased as :ContainsAllTags(tags) ```lua local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSupersetOfTags({ Test1 = 1, }) -- true tr:IsSupersetOfTags({ Test2 = 2, }) -- true  "},{"title":"IsSubsetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSubsetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSubsetOfTags(tags: Tags) → boolean Checks whether or not this replicator's tags are a subset of the given tags. ELI5: Are all the tags on this replicator also on the given tags? Aliased as :IsWithinTags(tags) local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSubsetOfTags({ Test1 = 1, Test2 = 2, Test3 = 3, }) -- true tr:IsSubsetOfTags({ Test1 = 1, }) -- false  "},{"title":"ProbabilityDistributor","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ProbabilityDistributor","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#types","content":" "},{"title":"Weight​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Weight","content":"&lt;/&gt; type Weight = number | NumberRange | () → (number | NumberRange ) A valid input for the weight of an item in the WeightsTable. Allows for functions to be passed in to generate a weight on the fly. If a NumberRange is given in, it will generate a random INTEGER between the min and max values of the Range.  "},{"title":"WeightedItem<T>​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#WeightedItem<T>","content":"&lt;/&gt; interface WeightedItem&lt;T&gt; { Weight: Weight Value: T } The format weights and an associated value must be in.  "},{"title":"WeightedArray<T>​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#WeightedArray<T>","content":"&lt;/&gt; type WeightedArray&lt;T&gt; = {WeightedItem&lt;T&gt;} A valid input for the WeightsTable. "},{"title":"Functions​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#new","content":"&lt;/&gt; ProbabilityDistributor.new( weights: {WeightedItem&lt;T&gt;},-- A table of weights to distribute. randomOrSeed: (Random | number)?-- An optional random number generator to use for the rolls. If a number is passed, it will be used as the seed for a new random number generator. If nothing is passed, it will create a new Random and use the current time as the seed. ) → ProbabilityDistributor&lt;T&gt;-- A new probability distributor of type T. Where T is the type of the value of the weighted item. Constructs a new ProbabilityDistributor  "},{"title":"Roll​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Roll","content":"&lt;/&gt; ProbabilityDistributor:Roll( luck: number?-- [Optional] A number between 0 and 1 that determines how lucky the roll is. The number acts as a chance that it rerolls the item for a better version. 'Better'ness is determined by the initial order of the weights table. ) → T-- The value of the item that was rolled. Rolls the probability distributor for a weighted item.  "},{"title":"Clone​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Clone","content":"&lt;/&gt; ProbabilityDistributor:Clone() → ProbabilityDistributor&lt;T&gt;-- A new probability distributor of type T. Where T is the type of the value of the weighted item. Clones the probability distributor.  "},{"title":"Sample​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Sample","content":"&lt;/&gt; ProbabilityDistributor:Sample( numOfSamples: number?,-- The number of samples to take. Defaults to 10,000. luck: number?-- The luck to use for the rolls. Defaults to 0. ) → {[T]: number}-- A table of the items that were rolled and how many times they were rolled. Samples the probability distributor to show the distribution of the rolls. "},{"title":"RailUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RailUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#properties","content":" "},{"title":"Math​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#Math","content":"&lt;/&gt; RailUtil.Math: MathUtil The MathUtil module.  "},{"title":"Vector​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#Vector","content":"&lt;/&gt; RailUtil.Vector: VectorUtil The VectorUtil module.  "},{"title":"Table​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#Table","content":"&lt;/&gt; RailUtil.Table: TableUtil The TableUtil module.  "},{"title":"Signal​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#Signal","content":"&lt;/&gt; RailUtil.Signal: SignalUtil The SignalUtil module.  "},{"title":"Player​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#Player","content":"&lt;/&gt; RailUtil.Player: PlayerUtil The PlayerUtil module.  "},{"title":"Instance​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#Instance","content":"&lt;/&gt; RailUtil.Instance: InstanceUtil The InstanceUtil module.  "},{"title":"Fusion​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#Fusion","content":"&lt;/&gt; RailUtil.Fusion: FusionUtil The FusionUtil module.  "},{"title":"String​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#String","content":"&lt;/&gt; RailUtil.String: StringUtil The StringUtil module.  "},{"title":"Camera​","type":1,"pageTitle":"RailUtil","url":"/ModulesOnRails/api/RailUtil#Camera","content":"&lt;/&gt; RailUtil.Camera: CameraUtil The CameraUtil module. "},{"title":"PromValue","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PromValue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#ClassName","content":"&lt;/&gt; PromValue.ClassName: &quot;PromValue&quot; The name of the class.  "},{"title":"Changed​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Changed","content":"&lt;/&gt; PromValue.Changed: Signal&lt;new: any,old: any&gt; A signal that fires when the value of the PromValue changes. "},{"title":"Functions​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#new","content":"Static &lt;/&gt; PromValue.new( initialValue: any?-- an optional initial value to set the PromValue to. ) → PromValue Creates a new PromValue  "},{"title":"Set​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Set","content":"&lt;/&gt; PromValue:Set(newValue: any) → () Sets the value of the PromValue and fires the Changed signal.  "},{"title":"Get​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Get","content":"&lt;/&gt; PromValue:Get() → any Immediately returns the stored value.  "},{"title":"IsReady​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#IsReady","content":"&lt;/&gt; PromValue:IsReady() → boolean Returns whether or not the value has been set yet  "},{"title":"OnReady​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#OnReady","content":"&lt;/&gt; PromValue:OnReady( fn: ((value: any) → ...any)?-- an optional function to call when the value is set. ) → Promise&lt;any&gt; Returns a promise that resolves with the value when it has been set atleast once. If given a function then it will run it the first time it is set, this is equivalent to just chaining :andThen(). Alias for :Promise()  "},{"title":"Promise​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Promise","content":"&lt;/&gt; PromValue:Promise( fn: ((value: any) → ...any)?-- an optional function to call when the value is set. ) → Promise&lt;any&gt; Alias for :OnReady() "},{"title":"DropletUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#types","content":" "},{"title":"WeightedArray<T>​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#WeightedArray<T>","content":"&lt;/&gt; type WeightedArray&lt;T&gt; = {{ Weight: number, Value: T }} A table of values with weights. The weights are used to calculate the probability of a value being chosen. The weights do not need to add up to 1. See ProbabilityDistributor for more information.  "},{"title":"NumOrRange​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#NumOrRange","content":"&lt;/&gt; type NumOrRange = number | NumberRange    "},{"title":"NumOrRangeOrWeightedArray​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#NumOrRangeOrWeightedArray","content":"&lt;/&gt; type NumOrRangeOrWeightedArray = NumOrRange | WeightedArray&lt;NumOrRange&gt;   "},{"title":"ResourceTypeData​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#ResourceTypeData","content":"&lt;/&gt; interface ResourceTypeData { Defaults: table SetupDroplet: (droplet: Droplet) → any? OnRenderUpdate: (( droplet: Droplet, renderTime: number ) → (CFrame? ))? OnDropletTimeout: ((droplet: Droplet) → ())? OnClientClaim: (( playerWhoCollected: Player , droplet: Droplet ) → ())? OnClientCollect: (( playerWhoCollected: Player , droplet: Droplet ) → ())? OnServerCollect: (( playerWhoCollected: Player , value: any, metadata: any ) → ())? }  [Defaults] is a table of default values for the droplet. This can be left empty. The values in this table are used to fill in any missing values in the ResourceSpawnData when a droplet is spawned as well as overriding certain behaviors internall for things like magnetization. [SetupDroplet] is called when a new droplet is created. Use this to setup your visuals and any variables you need to keep track of. All parts within this should be Anchored = false, CanCollide = false, and Massless = true. The return value of this function can be accessed via Droplet:GetSetupData() [OnRenderUpdate] is called every frame that the droplet is within render range of the LocalPlayer's Camera. Use this to update the visuals of your droplet. The return value, if one is given, must be a CFrame and is used for offsetting the droplet. [OnDropletTimeout] is called when the droplet times out. Use this to perform/cleanup any visual effects you may have. [OnClientClaim] is called when the server acknowledges that the droplet has been claimed. [OnClientCollect] is called when the droplet hits the player and is considered collected. It should be used for collection effects and other client side things. [OnServerCollect] is called once the server is informed by a client that the droplet has been collected. This is where you should perform any server side logic like actually giving things like Money or Exp.   "},{"title":"ResourceSpawnData​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#ResourceSpawnData","content":"&lt;/&gt; interface ResourceSpawnData { ResourceType: string-- The registered name of the resource type Value: any | NumOrRangeOrWeightedArray-- The value of the droplet Metadata: any?-- The metadata of the droplet SpawnLocation: Vector3 | CFrame | PVInstance -- The location to spawn the droplet CollectorMode: CollectorMode?-- The behavior of how the droplet is claimed PlayerTargets: Player | {Player }?-- The players that can collect the droplet LifeTime: NumOrRange?-- The time before the droplet dissapears Count: NumOrRangeOrWeightedArray?-- The number of droplets to spawn EjectionDuration: NumOrRangeOrWeightedArray?-- The time it takes to spew out all the droplets EjectionHorizontalVelocity: NumOrRangeOrWeightedArray?-- The horizontal velocity of the droplets when they are ejected EjectionVerticalVelocity: NumOrRangeOrWeightedArray?-- The vertical velocity of the droplets when they are ejected }  Special Behaviors Any index that takes a NumOrRangeOrWeightedArray will be parsed and calculated ahead of time internally so that the client and server are synced. For example, if you pass in a NumberRange for Value, the server will calculate a random decimal number between the min and max, this number would then be accessed by Droplet:GetValue() on the client.  "},{"title":"CollectorMode​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#CollectorMode","content":"&lt;/&gt; type CollectorMode = &quot;MultiCollector&quot; | &quot;SingleCollector&quot; The behavior of how the droplet is claimed. MultiCollector - Many players can collect this droplet, each has their own individual instance SingleCollector - Only one player can collect this droplet  "},{"title":"Properties​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#Enums","content":"&lt;/&gt; DropletUtil.Enums: {CollectorMode: { MultiCollector: CollectorMode, SingleCollector: CollectorMode }}  "},{"title":"NetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/NetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#properties","content":" "},{"title":"Client​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Client","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.Client: ClientNetWire   "},{"title":"Server​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Server","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.Server: ServerNetWire   "},{"title":"Client​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Client","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.Client: ClientNetWire   "},{"title":"Server​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Server","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.Server: ServerNetWire  "},{"title":"Functions​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#functions","content":" "},{"title":"createEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createEvent","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createEvent( inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyEvent = NetWire.createEvent() MyWire.MyEvent:Connect(function(plr: Player, msg: string) print(plr, &quot;said:&quot;, msg) end)   "},{"title":"createUnreliableEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createUnreliableEvent","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createUnreliableEvent( inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyEvent = NetWire.createUnreliableEvent() MyWire.MyEvent:FireAll(&quot;Hello, world!&quot;)   "},{"title":"createProperty​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createProperty","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createProperty( initialValue: any?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteProperty Returns an PropertyMarker that is used to mark where a remoteProperty should be created. Calls ServerNetWire:RegisterProperty() when set to the index of a ServerNetWire. See ServerNetWire:RegisterProperty for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyProperty = NetWire.createProperty(0) print(MyWire.MyProperty:Get()) -- 0   "},{"title":"createEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createEvent","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createEvent( inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyEvent = NetWire.createEvent() MyWire.MyEvent:Connect(function(plr: Player, msg: string) print(plr, &quot;said:&quot;, msg) end)   "},{"title":"createUnreliableEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createUnreliableEvent","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createUnreliableEvent( inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyEvent = NetWire.createUnreliableEvent() MyWire.MyEvent:FireAll(&quot;Hello, world!&quot;)   "},{"title":"createProperty​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createProperty","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createProperty( initialValue: any?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteProperty Returns an PropertyMarker that is used to mark where a remoteProperty should be created. Calls ServerNetWire:RegisterProperty() when set to the index of a ServerNetWire. See ServerNetWire:RegisterProperty for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyProperty = NetWire.createProperty(0) print(MyWire.MyProperty:Get()) -- 0  "},{"title":"Component","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? Extensions: {Extension}? Methods: {[string]: function}? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end In this forked version of component, extensions can also add methods to the component class and extend other extensions via giving an extension a Methods table. For example: local ExtendedComponentMethods = {} function ExtendedComponentMethods.DoSomething(component) print(&quot;Hello World!&quot;) end local MyComponentExtension = {} MyComponentExtension.Methods = ExtendedComponentMethods This will add a method called DoSomething to the component class. Be careful when using with ShouldExtend It is important to note that these methods are added to the Component Class and not the Component Instance. This means that these methods will be availible regardless of whether the extension passes its shouldExtend function or not. If your code is dependent on extension methods existing only when they pass their shouldExtend function, you may want to avoid using this feature. If you want to utilize other extensions within your extension or guarantee that the given extension is loaded onto the component before your extension, you can use the Extensions table. For example: local SomeOtherExtension = require(somewhere.SomeOtherExtension) local MyComponentExtension = {} MyComponentExtension.Extensions = {SomeOtherExtension} This will guarantee that SomeOtherExtension is added to the component and loaded before MyComponentExtension. info The ShouldExtend function of SomeOtherExtension will still be called independently of the ShouldExtend function of MyExtension. Under the hood this just adds the extension to the components original extension array.  "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#properties","content":" "},{"title":"Started​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#new","content":"Component &lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:Construct() self.MyData = &quot;Hello&quot; end function MyComponent:Start() local another = self:GetComponent(AnotherComponent) another:DoSomething() end function MyComponent:Stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:HeartbeatUpdate(dt) end function MyComponent:SteppedUpdate(dt) end function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"HeartbeatUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#HeartbeatUpdate","content":"Component Class &lt;/&gt; Component.HeartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:HeartbeatUpdate(dt) end   "},{"title":"SteppedUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#SteppedUpdate","content":"Component Class &lt;/&gt; Component.SteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:SteppedUpdate(dt) end   "},{"title":"RenderSteppedUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#RenderSteppedUpdate","content":"This item only works when running on the client. Client Component Class &lt;/&gt; Component.RenderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:RenderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetAll","content":"Component Class &lt;/&gt; Component:GetAll() → {Component} Gets a table array of all existing component objects. For example, if there was a component class linked to the &quot;MyComponent&quot; tag, and three Roblox instances in your game had that same tag, then calling GetAll would return the three component instances. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- ... local components = MyComponent:GetAll() for _,component in ipairs(components) do component:DoSomethingHere() end   "},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#FromInstance","content":"Component Class &lt;/&gt; Component:FromInstance(instance: Instance ) → Component? Gets an instance of a component class from the given Roblox instance. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = MyComponent:FromInstance(workspace.SomeInstance)   "},{"title":"WaitForInstance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#WaitForInstance","content":"Component Class &lt;/&gt; Component:WaitForInstance( instance: Instance , timeout: number? ) → Promise&lt;ComponentInstance&gt; Resolves a promise once the component instance is present on a given Roblox instance. An optional timeout can be provided to reject the promise if it takes more than timeout seconds to resolve. If no timeout is supplied, timeout defaults to 60 seconds. local MyComponent = require(somewhere.MyComponent) MyComponent:WaitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance) -- Do something with the component class end)   "},{"title":"UpdateAncestors​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#UpdateAncestors","content":"Component Class &lt;/&gt; Component:UpdateAncestors(newAncestors: {Instance }) → () Allows for you to update the valid ancestors of a component class. This is useful if you want to give a valid ancestor that may not exist when the component is first created. local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, }) task.defer(function() local newAncestors = {workspace:WaitForChild(&quot;SomeFolder&quot;)} MyComponent:UpdateAncestors(newAncestors) end)   "},{"title":"Construct​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Construct","content":"Component Class &lt;/&gt; Component:Construct() → () Construct is called before the component is started, and should be used to construct the component instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"Start​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Start","content":"Component Class &lt;/&gt; Component:Start() → () Start is called when the component is started. At this point in time, it is safe to grab other components also bound to the same instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() -- e.g., grab another component: local another = self:GetComponent(AnotherComponent) end   "},{"title":"Stop​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Stop","content":"Component Class &lt;/&gt; Component:Stop() → () Stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.Instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Stop() self.SomeStuff:Destroy() end   "},{"title":"GetComponent​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetComponent","content":"Component Instance &lt;/&gt; Component:GetComponent(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() local another = self:GetComponent(AnotherComponent) end   "},{"title":"ForEachSibling​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ForEachSibling","content":"Component Instance &lt;/&gt; Component:ForEachSibling( componentClass: ComponentClass, fn: ( component: Component, jani: Janitor ) → () ) → Connection Ties a function to the lifecycle of the calling component and the equivalent component of the givencomponentClass. The function is run whenever a component of the given class is started. The given function passes the sibling component of the given class and a janitor to handle any connections you may make within it. The Janitor is cleaned up whenever either compenent is stopped. local AnotherComponent = require(somewhere.AnotherComponent) local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Start() self:ForEachSibling(AnotherComponent, function(sibling, jani) print(sibling.SomeProperty) jani:Add(function() print(&quot;Sibling component stopped&quot;) end) end) end  "},{"title":"ExampleResourceTypeData","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ExampleResourceTypeData","content":"On this page ExampleResourceTypeData An Example ResourceTypeData file. This is used to define the general behavior of a droplet type. local GenericPart = Instance.new(&quot;Part&quot;) GenericPart.Name = &quot;GenericPart&quot; GenericPart.Transparency = 1 GenericPart.Size = Vector3.one GenericPart.Anchored = true GenericPart.CanCollide = false GenericPart.CanTouch = false GenericPart.CanQuery = false GenericPart.Massless = true -------------------------------------------------------------------------------- --// Data //-- -------------------------------------------------------------------------------- return { Defaults = { Value = NumberRange.new(0.6, 1.4); -- The value you want the droplet to have. This can be anything. -- Metadata = {}; -- You typically shouldnt default metadata. Count = NumberRange.new(2, 5); -- Number of droplets to spawn LifeTime = NumberRange.new(50, 60); -- Time before the droplet dissapears EjectionDuration = 1; -- Time it takes to spew out all the droplets EjectionHorizontalVelocity = NumberRange.new(0, 25); EjectionVerticalVelocity = NumberRange.new(25, 50); CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector; Mass = 1; -- Mass of the droplet (Used in magnitization calculations) MaxForce = math.huge; -- Maximum steering force applied to the droplet when magnitized to a player MaxVelocity = 150; -- Maxiumum velocity of the droplet when magnitized to a player CollectionRadius = 1.5; -- Radius from center of player the droplet must be to be considered 'collected' }; --[[ Called when a new droplet is created. Use this to setup your visuals and any variables you need to keep track of. All parts within this should be Anchored = false, CanCollide = false, and Massless = true. The return value of this function can be accessed via Droplet:GetSetupData() ]] SetupDroplet = function(droplet: Droplet) local Value = droplet:GetValue() :: number local VisualModel = Instance.new(&quot;Model&quot;) VisualModel.Name = &quot;VisualModel&quot; local OuterPart = GenericPart:Clone() OuterPart.Name = &quot;Outer&quot; OuterPart.Material = Enum.Material.Glass OuterPart.Transparency = 0.5 OuterPart.Color = Color3.fromRGB(16, 206, 16) OuterPart.Size = Vector3.one * Value OuterPart.Anchored = false OuterPart.Parent = VisualModel VisualModel.PrimaryPart = OuterPart local NumGen = Random.new() local InnerPart = OuterPart:Clone() InnerPart.Material = Enum.Material.Neon InnerPart.Name = &quot;Inner&quot; InnerPart.Color = Color3.fromRGB(219, 189, 18) InnerPart.Transparency = 0 InnerPart.CastShadow = false InnerPart.Size *= 0.6 + NumGen:NextNumber(-0.1, 0.1) InnerPart.CFrame = OuterPart.CFrame + Vector3.new( NumGen:NextNumber(-0.1, 0.1), NumGen:NextNumber(-0.1, 0.1), NumGen:NextNumber(-0.1, 0.1) ) InnerPart.Parent = VisualModel local Weld = Instance.new(&quot;WeldConstraint&quot;) Weld.Part0 = OuterPart Weld.Part1 = InnerPart Weld.Parent = VisualModel droplet:AddTask(task.spawn(function() for i = 0.025, 1, 0.025 do VisualModel:ScaleTo(i) task.wait() end VisualModel:ScaleTo(1) end), nil, &quot;GrowThread&quot;) droplet:AttachModel(VisualModel) return { VisualModel = VisualModel; SpinDirection = if math.random() &gt; 0.5 then 1 else -1; } end; -- Ran when the droplet is within render range of the LocalPlayer's Camera OnRenderUpdate = function(droplet: Droplet, rendertimeElapsed: number) local SetupData = droplet:GetSetupData() local OffsetCFrame = CFrame.new() do -- Bobbing local AMPLITUDE = 1 -- Studs of vertical movement (+- half of this) local FREQUENCY = 0.25 -- Cycles per second local Y = (AMPLITUDE * 0.5) * -math.cos((rendertimeElapsed*math.pi) * (FREQUENCY)) OffsetCFrame *= CFrame.new(0, AMPLITUDE + Y, 0) end do -- Rotating local TimeToMakeOneRotation = 4 local RotationsPerSecond = 1/TimeToMakeOneRotation OffsetCFrame *= CFrame.Angles(0, (rendertimeElapsed*math.pi) * RotationsPerSecond * SetupData.SpinDirection , 0) end return OffsetCFrame end; OnDropletTimeout = function(droplet: Droplet) local VisualModel = droplet:GetSetupData().VisualModel droplet:RemoveTask(&quot;GrowThread&quot;) for i = 1, 0.025, -0.025 do VisualModel:ScaleTo(i) task.wait() end end; OnClientClaim = function(playerWhoClaimed: Player, droplet: Droplet) -- droplet:Collect(playerWhoClaimed) end; --[[ Called when the droplet hits the player and is considered collected. This is ran on the client only. It should be used for collection effects and other client side things. ]] OnClientCollect = function(playerWhoCollected: Player, droplet: Droplet) local Value = droplet:GetValue() :: number local Part = GenericPart:Clone() Part.CFrame = droplet:GetPivot() task.delay(2, function() Part:Destroy() end) local CollectionSound = Instance.new(&quot;Sound&quot;) CollectionSound.SoundId = &quot;rbxassetid://402143943&quot; CollectionSound.Volume = 0.25 local PitchShift = Instance.new(&quot;PitchShiftSoundEffect&quot;) PitchShift.Octave = 2 - Value/1.5 PitchShift.Parent = CollectionSound CollectionSound.Parent = Part Part.Parent = workspace CollectionSound:Play() end; --[[ Called once the client informs the server that it has collected the droplet. ]] OnServerCollect = function(playerWhoCollected: Player, value: any, metadata: any) local ExpValue: number = value local leaderstats = playerWhoCollected:FindFirstChild(&quot;leaderstats&quot;) if not leaderstats then leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; leaderstats.Parent = playerWhoCollected end local expStat = leaderstats:FindFirstChild(&quot;Exp&quot;) if not expStat then expStat = Instance.new(&quot;NumberValue&quot;) expStat.Name = &quot;Exp&quot; expStat.Parent = leaderstats end expStat.Value += ExpValue -- Add the value to the player's &quot;exp&quot;. This is just an example. end; } ","keywords":""},{"title":"MathUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/MathUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#types","content":" "},{"title":"MathOperation​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#MathOperation","content":"&lt;/&gt; type MathOperation = (&quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;^&quot; | &quot;%&quot;) A type consisting of all the valid math operations in string format. "},{"title":"Functions​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#functions","content":" "},{"title":"snap​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#snap","content":"&lt;/&gt; MathUtil.snap( v: number,-- The value to snap. ...: number | {number}-- The array or variadic of number values to snap to. ) → number-- The closest value to the given value. Takes a value and snaps it to the closest one of the following values.  "},{"title":"random​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#random","content":"&lt;/&gt; MathUtil.random( min: number,-- The minimum value. max: number-- The maximum value. ) → number-- The random float. Returns a random float between the given min and max.  "},{"title":"randomFromNumberRange​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#randomFromNumberRange","content":"&lt;/&gt; MathUtil.randomFromNumberRange( numberRange: NumberRange -- The number range to generate a random number from. ) → number-- The generated random number. Returns a random float in the given number range.  "},{"title":"randomFromArray​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#randomFromArray","content":"&lt;/&gt; MathUtil.randomFromArray( tbl: {number}-- The array to get a random number from. ) → number-- The random number. Gets a random number within the given array.  "},{"title":"randomFromRanges​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#randomFromRanges","content":"&lt;/&gt; MathUtil.randomFromRanges(...: {number} | NumberRange ) → number Gets a random number within the given ranges. By default the numbers within the ranges have an equal chance of being selected (unless the given table has a Weight index) local n = MathUtil.randomFromRanges({1, 10}, {20, 40}) -- Returns a random number between 1 and 10 or 20 and 40.   "},{"title":"tryRandom​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#tryRandom","content":"&lt;/&gt; MathUtil.tryRandom( data: number | NumberRange | NumberSequence | {number},-- The data to try and generate a random number from. ...: any-- The optional arguments to pass to the random function. ) → number Trys to return a random number from the given data. It parses the data to try and figure out which random methodology to use.  "},{"title":"round​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#round","content":"&lt;/&gt; MathUtil.round( numToRound: number,-- The number to round. multiple: number?-- The multiple to round to. If not specified, will round to the nearest integer. ) → Theroundednumber. Rounds a number to the nearest specified multiple.  "},{"title":"lerp​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#lerp","content":"&lt;/&gt; MathUtil.lerp( a: number,-- The first number. b: number,-- The second number. t: number-- The alpha to lerp between the two numbers. ) → Thelerpednumber. Lerps a number between two other numbers based on a given alpha.  "},{"title":"isBetween​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#isBetween","content":"&lt;/&gt; MathUtil.isBetween( numToCheck: number,-- The number to check. bound1: number,-- The first bound. bound2: number-- The second bound. ) → boolean-- Whether or not the number is between the two bounds. Checks if a number is between two other numbers.  "},{"title":"isClose​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#isClose","content":"&lt;/&gt; MathUtil.isClose( num1: number,-- The first number. num2: number,-- The second number. epsilon: number?-- The epsilon to check between the two numbers. Defaults to 0.0001. ) → boolean-- Whether or not the two numbers are close to each other. Checks if two numbers are close to each other within a given epsilon.  "},{"title":"numbersToSequence​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#numbersToSequence","content":"&lt;/&gt; MathUtil.numbersToSequence( values: {number} | number,-- The values to convert to a NumberSequence. splitPoints: ({number} | number)?-- The points along the line at which the values are split. Optional only if there is one value. ) → NumberSequence -- The generated NumberSequence. Converts a table of numbers to a NumberSequence grouped by split points. This is very useful when working with UI Gradient's transparency. local values = {4, 8} local sequence = MathUtil.numbersToSequence(values, 0.5) -- The sequence will be 4 at 0, 4 at 0.5, 8 at 0.5 + EPSILON, and 8 at 1.   "},{"title":"operate​","type":1,"pageTitle":"MathUtil","url":"/ModulesOnRails/api/MathUtil#operate","content":"&lt;/&gt; MathUtil.operate( a: number, operator: string, b: number ) → number Performs a math operation on two numbers. "},{"title":"ObjectCache","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ObjectCache","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#functions","content":" "},{"title":"setupModelForCacheMovement​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#setupModelForCacheMovement","content":"&lt;/&gt; ObjectCache.setupModelForCacheMovement(model: Model ) → () Sets up a model for cache movement by welding all of its descendant BaseParts to its PrimaryPart.  "},{"title":"isModelSetupForCacheMovement​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#isModelSetupForCacheMovement","content":"&lt;/&gt; ObjectCache.isModelSetupForCacheMovement(model: Model ) → boolean Checks if a model is setup for cache movement.  "},{"title":"new​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#new","content":"&lt;/&gt; ObjectCache.new(config: CacheConfig) → () "},{"title":"Types","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache##","content":""},{"title":"​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#CacheConfig","content":"interface CacheConfig { Template: T | () → T-- The template object to use for the cache. Must be a PVInstance or a function that returns a PVInstance. InitialSize: number?-- The initial size of the cache. Defaults to 10. ExpansionSize: number?-- The amount to expand the cache by. Defaults to 50. ObjectsParent: Instance? -- The parent to put the objects in. CacheParent: Instance? -- The parent to put the cache in. Name: string?-- The name of the cache. }  Creates a new ObjectCache. local myCache: ObjectCache&lt;Part&gt; = ObjectCache.new({ Template = function() local part = Instance.new(&quot;Part&quot;) part.Anchored = true return part end, }) Anchored Parts Make sure that your template object is anchored. Otherwise when it returns to the cache it will fall out of existence. info Luau LSP type inference for the template is not yet robust enough to properly infer the type of the template object. As a result, you should properly assign the right type to your cache object.  "},{"title":"Get​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Get","content":"&lt;/&gt; ObjectCache:Get(moveTo: CFrame? ) → T Gets an object from the cache, moving it to the specified CFrame if provided. Moving the returned object If you provide a CFrame, the movement is deferred so it can be bulk moved. Keep this in mind if you need to do other operations on the object immediately after moving it.  "},{"title":"Return​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Return","content":"&lt;/&gt; ObjectCache:Return(obj: T) → () Returns an object to the cache.  "},{"title":"ExpandCache​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#ExpandCache","content":"&lt;/&gt; ObjectCache:ExpandCache( Amount: number-- The amount to expand the cache by. ) → () Expands the cache by the specified amount.  "},{"title":"SetExpandAmount​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#SetExpandAmount","content":"&lt;/&gt; ObjectCache:SetExpandAmount( Amount: number-- The amount to expand the cache by. ) → () Sets the default amount to expand the cache by.  "},{"title":"IsInUse​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#IsInUse","content":"&lt;/&gt; ObjectCache:IsInUse(obj: PVInstance ) → boolean Returns whether the specified object is currently in use.  "},{"title":"BelongsTo​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#BelongsTo","content":"&lt;/&gt; ObjectCache:BelongsTo(obj: PVInstance ) → boolean Checks if an object belongs to this cache.  "},{"title":"Update​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Update","content":"&lt;/&gt; ObjectCache:Update() → () Forces an immediate position update for all objects in the cache.  "},{"title":"Destroy​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Destroy","content":"&lt;/&gt; ObjectCache:Destroy() → () Destroys the cache and all objects within it.  "},{"title":"ConnectOnReturn​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#ConnectOnReturn","content":"&lt;/&gt; ObjectCache:ConnectOnReturn( fn: (obj: T) → ()-- The function to run. ) → () → boolean-- A cleaner function to disconnect the connection. Sets a function to run when an object is returned to the cache. Passes the object that was returned as an argument. "},{"title":"RemoteComponent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RemoteComponent","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#types","content":" "},{"title":"RemoteComponent​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#RemoteComponent","content":"&lt;/&gt; interface RemoteComponent { Client: table?-- Only available on the server. Set this to a table to expose it to the client. Server: table?-- Only available on the client. The indices of this are inferred from the server. }  "},{"title":"Functions​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#functions","content":" "},{"title":"createEvent () -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createEvent () -> MARKER","content":"&lt;/&gt; RemoteComponent.createEvent () -&gt; MARKER() → () Redirects to NetWire.createEvent  "},{"title":"createUnreliableEvent () -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createUnreliableEvent () -> MARKER","content":"&lt;/&gt; RemoteComponent.createUnreliableEvent () -&gt; MARKER() → () Redirects to NetWire.createUnreliableEvent  "},{"title":"createProperty (initialValue: any) -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createProperty (initialValue: any) -> MARKER","content":"&lt;/&gt; RemoteComponent.createProperty (initialValue: any) -&gt; MARKER() → () Redirects to NetWire.createProperty "},{"title":"Option","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Option","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#properties","content":" "},{"title":"None​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#None","content":"&lt;/&gt; Option.None: Option&lt;None&gt; Represents no value. "},{"title":"Functions​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#functions","content":" "},{"title":"Some​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Some","content":"&lt;/&gt; Option.Some(value: T) → Option&lt;T&gt; Creates an Option instance with the given value. Throws an error if the given value is nil.  "},{"title":"Wrap​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Wrap","content":"&lt;/&gt; Option.Wrap(value: T) → Option&lt;T&gt; | Option&lt;None&gt; Safely wraps the given value as an option. If the value is nil, returns Option.None, otherwise returns Option.Some(value).  "},{"title":"Is​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Is","content":"&lt;/&gt; Option.Is(obj: any) → boolean Returns true if obj is an Option.  "},{"title":"Assert​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Assert","content":"&lt;/&gt; Option.Assert(obj: any) → () Throws an error if obj is not an Option.  "},{"title":"Deserialize​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Deserialize","content":"&lt;/&gt; Option.Deserialize(data: table) → Option Deserializes the data into an Option. This data should have come from the option:Serialize() method.  "},{"title":"Serialize​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Serialize","content":"&lt;/&gt; Option:Serialize() → table Returns a serialized version of the option.  "},{"title":"Match​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Match","content":"&lt;/&gt; Option:Match(matches: { Some: (value: any) → any, None: () → any }) → any Matches against the option. local opt = Option.Some(32) opt:Match { Some = function(num) print(&quot;Number&quot;, num) end, None = function() print(&quot;No value&quot;) end, }   "},{"title":"IsSome​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#IsSome","content":"&lt;/&gt; Option:IsSome() → boolean Returns true if the option has a value.  "},{"title":"IsNone​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#IsNone","content":"&lt;/&gt; Option:IsNone() → boolean Returns true if the option is None.  "},{"title":"Expect​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Expect","content":"&lt;/&gt; Option:Expect(msg: string) → value: any Unwraps the value in the option, otherwise throws an error with msg as the error message. local opt = Option.Some(10) print(opt:Expect(&quot;No number&quot;)) -&gt; 10 print(Option.None:Expect(&quot;No number&quot;)) -- Throws an error &quot;No number&quot;   "},{"title":"ExpectNone​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#ExpectNone","content":"&lt;/&gt; Option:ExpectNone(msg: string) → () Throws an error with msg as the error message if the value is not None.  "},{"title":"Unwrap​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Unwrap","content":"&lt;/&gt; Option:Unwrap() → value: any Returns the value in the option, or throws an error if the option is None.  "},{"title":"UnwrapOr​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#UnwrapOr","content":"&lt;/&gt; Option:UnwrapOr(default: any) → value: any If the option holds a value, returns the value. Otherwise, returns default.  "},{"title":"UnwrapOrElse​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#UnwrapOrElse","content":"&lt;/&gt; Option:UnwrapOrElse(defaultFn: () → any) → value: any If the option holds a value, returns the value. Otherwise, returns the result of the defaultFn function.  "},{"title":"And​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#And","content":"&lt;/&gt; Option:And(optionB: Option) → Option Returns optionB if the calling option has a value, otherwise returns None. local optionA = Option.Some(32) local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == optionB local optionA = Option.None local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == Option.None   "},{"title":"AndThen​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#AndThen","content":"&lt;/&gt; Option:AndThen(andThenFn: (value: any) → Option) → value: Option If the option holds a value, then the andThenFn function is called with the held value of the option, and then the resultant Option returned by the andThenFn is returned. Otherwise, None is returned. local optA = Option.Some(32) local optB = optA:AndThen(function(num) return Option.Some(num * 2) end) print(optB:Expect(&quot;Expected number&quot;)) --&gt; 64   "},{"title":"Or​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Or","content":"&lt;/&gt; Option:Or(optionB: Option) → Option If caller has a value, returns itself. Otherwise, returns optionB.  "},{"title":"OrElse​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#OrElse","content":"&lt;/&gt; Option:OrElse(orElseFn: () → Option) → Option If caller has a value, returns itself. Otherwise, returns the option generated by the orElseFn function.  "},{"title":"XOr​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#XOr","content":"&lt;/&gt; Option:XOr(optionB: Option) → Option If both self and optionB have values or both don't have a value, then this returns None. Otherwise, it returns the option that does have a value.  "},{"title":"Filter​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Filter","content":"&lt;/&gt; Option:Filter(predicate: (value: any) → boolean) → Option Returns self if this option has a value and the predicate returns `true. Otherwise, returns None.  "},{"title":"Contains​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Contains","content":"&lt;/&gt; Option:Contains(value: any) → boolean Returns true if this option contains value.  "},{"title":"__tostring​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#__tostring","content":"&lt;/&gt; Option:__tostring() → string Metamethod to transform the option into a string. local optA = Option.Some(64) local optB = Option.None print(optA) --&gt; Option&lt;number&gt; print(optB) --&gt; Option&lt;None&gt;   "},{"title":"__eq​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#__eq","content":"&lt;/&gt; Option:__eq(opt: Option) → boolean Metamethod to check equality between two options. Returns true if both options hold the same value or both options are None. local o1 = Option.Some(32) local o2 = Option.Some(32) local o3 = Option.Some(64) local o4 = Option.None local o5 = Option.None print(o1 == o2) --&gt; true print(o1 == o3) --&gt; false print(o1 == o4) --&gt; false print(o4 == o5) --&gt; true  "},{"title":"PlayerProfileManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerProfileManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#types","content":" "},{"title":"DataMigrator​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#DataMigrator","content":"&lt;/&gt; interface DataMigrator { FromVersion: string ToVersion: string Migrate: ( profileData: table, profileOwner: Player ) → (table) } Used to Transform data from one version to another -- Turn all the deprecated currency 'Candy' into the new currency 'Gems' at a 1:10 rate local migrator = { FromVersion = &quot;0.0.1&quot;, ToVersion = &quot;0.0.2&quot; Migrate = function(data: table, plr: Player) if not data.Gems then data.Gems = 0 end local candy = data.Candy or 0 data.Gems += candy * 10 data.Candy = nil return data end }   "},{"title":"PPM_Config​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PPM_Config","content":"&lt;/&gt; interface PPM_Config { DataStoreKey: string DefaultDataSchema: table UseMock: boolean? Migrator: {DataMigrator} GetPlayerKeyCallback: ((player: Player ) → (string))? ReconcileCallback: (( player: Player , profile: Profile ) → ())? OnProfileLoadFailureCallback: (( player: Player , err: string ) → ())? }  DataStoreKey is the internal Key used for the PlayerData's DataStore. DefaultDataSchema is a template table that is used for reconciling the player's profile with. It is what new players are given if they dont have existing data. UseMock determines whether or not a Mock ProfileStore will be used. Migrator is a table of DataMigrators that are used to transform data from one version to another. GetPlayerKeyCallback is a callback that is used to fetch the Key that each player's data is mapped to. ReconcileCallback is a callback that is called when the system attempts to reconcile the players profile. It will default to calling Profile:Reconcile if not provided. OnProfileLoadFailureCallback is a callback that is called if the player's data fails to load. It will default to kicking the player if not provided.  "},{"title":"Functions​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#new","content":"&lt;/&gt; PlayerProfileManager.new(config: PPM_Config) → PlayerProfileManager Creates a new PlayerProfileManager. This is a singleton class, so calling this function multiple times will return the same instance. Takes a config table, see PPM_Config for more info on the individual fields it supports. PlayerProfileManager.new({ DataStoreKey = &quot;PlayerData&quot;; DefaultDataSchema = { __VERSION = &quot;0.0.0&quot;; Currency = 0; }; })   "},{"title":"IsLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#IsLoaded","content":"&lt;/&gt; PlayerProfileManager:IsLoaded(player: Player ) → boolean Returns whether or not the player's profile is currently loaded. local isLoaded = PlayerProfileManager:IsLoaded(player)   "},{"title":"OnLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#OnLoaded","content":"&lt;/&gt; PlayerProfileManager:OnLoaded(player: Player ) → Promise&lt;()&gt; Returns a promise that will resolve when the player's profile is loaded. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:OnLoaded(player):andThen(function() print(&quot;Profile loaded for &quot; .. player.Name) end)   "},{"title":"GetProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#GetProfile","content":"&lt;/&gt; PlayerProfileManager:GetProfile(player: Player ) → Profile? Returns the player's profile, if it exists. May return nil if this players profile is not loaded. local profile: Profile? = PlayerProfileManager:GetProfile(player)   "},{"title":"PromiseProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PromiseProfile","content":"&lt;/&gt; PlayerProfileManager:PromiseProfile(player: Player ) → Promise&lt;Profile&gt; Returns a promise that resolves with the player's profile when it is ready. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:PromiseProfile(player):andThen(function(profile: Profile) print(&quot;Profile loaded for &quot; .. player.Name) end)  "},{"title":"ScriptConnection","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ScriptConnection","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#properties","content":" "},{"title":"Connected​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#Connected","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ScriptConnection.Connected: boolean A boolean which determines if a ScriptConnection is active or not.  "},{"title":"Connected​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#Connected","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ScriptConnection.Connected: boolean A boolean which determines if a ScriptConnection is active or not.  "},{"title":"Connected​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#Connected","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ScriptConnection.Connected: boolean A boolean which determines if a ScriptConnection is active or not. "},{"title":"Functions​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#functions","content":" "},{"title":"Disconnect​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#Disconnect","content":"&lt;/&gt; ScriptConnection:Disconnect() → () Disconnects a connection, any :Fire calls from now on will not invoke this connection's handler. local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; true connection:Disconnect() connection.Connected -&gt; false   "},{"title":"Disconnect​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#Disconnect","content":"&lt;/&gt; ScriptConnection:Disconnect() → () Disconnects a connection, any :Fire calls from now on will not invoke this connection's handler. local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; true connection:Disconnect() connection.Connected -&gt; false   "},{"title":"Disconnect​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#Disconnect","content":"&lt;/&gt; ScriptConnection:Disconnect() → () Disconnects a connection, any :Fire calls from now on will not invoke this connection's handler. local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; true connection:Disconnect() connection.Connected -&gt; false  "},{"title":"SignalUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/SignalUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SignalUtil","url":"/ModulesOnRails/api/SignalUtil#functions","content":" "},{"title":"combine​","type":1,"pageTitle":"SignalUtil","url":"/ModulesOnRails/api/SignalUtil#combine","content":"&lt;/&gt; SignalUtil.combine(signalTbl: Thetableofsignalstocombine.) → ASignalProxyobjectthatactsasaproxyforthesignals. Combines a bunch of signals into one signal. "},{"title":"ServerPlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerPlayerDataManager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#properties","content":" "},{"title":"DEFAULT_MANAGER_NAME​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#DEFAULT_MANAGER_NAME","content":"&lt;/&gt; ServerPlayerDataManager.DEFAULT_MANAGER_NAME: string The default internal manager name.  "},{"title":"PlayerDataReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#PlayerDataReady","content":"&lt;/&gt; ServerPlayerDataManager.PlayerDataReady: Signal&lt;Player &gt; A signal that fires when a Player's data is ready to be used. "},{"title":"Functions​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#new","content":"Constructor Singleton Static &lt;/&gt; ServerPlayerDataManager.new(ppm: PlayerProfileManager?) → ServerPlayerDataManager Constructs a new ServerPlayerDataManager instance. local PPM = PlayerProfileManager.new() local PlayerDataManager = PlayerDataManager.Server.new(PPM) PlayerProfileManager The ServerPlayerDataManager requires a PlayerProfileManager instance in order to properly function. You must provide a PlayerProfileManager instance before you call the :Start method. Optimally you should provide it during the constructor phase.  "},{"title":"OnReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#OnReady","content":"&lt;/&gt; ServerPlayerDataManager:OnReady(player: Player ) → Promise Promise that resolves when the player's data is ready to be used.  "},{"title":"IsReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#IsReady","content":"&lt;/&gt; ServerPlayerDataManager:IsReady(player: Player ) → boolean Checks whether or not a given player's data is ready  "},{"title":"IsManagerRegistered​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#IsManagerRegistered","content":"&lt;/&gt; ServerPlayerDataManager:IsManagerRegistered(managerName: string?) → boolean Checks whether or not a given manager is registered. If one is not specified then it will assume the default one.  "},{"title":"GetManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#GetManager","content":"&lt;/&gt; ServerPlayerDataManager:GetManager( player: Player , managerName: string? ) → TableManager? Fetches one of the given Player's DataManagers. If one is not specified then it will assume the default one.  "},{"title":"PromiseManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#PromiseManager","content":"&lt;/&gt; ServerPlayerDataManager:PromiseManager( player: Player , managerName: string? ) → Promise Promises a TableManager for a given player. If a managerName is not specified then it will assume the default one. ServerPlayerDataManager:PromiseManager(Players.Raildex, &quot;Settings&quot;):andThen(function(manager) manager:Set(&quot;Volume&quot;, 0.5) end)   "},{"title":"ForEachPlayer​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#ForEachPlayer","content":"&lt;/&gt; ServerPlayerDataManager:ForEachPlayer(fn: ( player: Player , data: any ) → ()) → Connection Runs a function for all existing loaded player data and all future player data. ServerPlayerDataManager:ForEachPlayer(function(player) local defaultManager = ServerPlayerDataManager:GetManager(player) defaultManager:Set(&quot;Volume&quot;, 0.5) end)   "},{"title":"GetReplicator​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#GetReplicator","content":"&lt;/&gt; ServerPlayerDataManager:GetReplicator( player: Player , replicatorName: string? ) → TableReplicator? Returns the TableReplicator for a given player. If a replicatorName is not specified then it will assume the default one. local replicator = ServerPlayerDataManager:GetReplicator(Players.Raildex, &quot;Settings&quot;)   "},{"title":"RegisterManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#RegisterManager","content":"&lt;/&gt; ServerPlayerDataManager:RegisterManager(config: { Name: string, GetData: ( player: Player , profile: Profile ) → table, ReplicationTargets: (&quot;All&quot; | &quot;Self&quot; | Player | {Player })?, Tags: table?, Parent: table?, Client: table?, } | string) → () Registers a config table for new managers to use for construction. ServerPlayerDataManager:RegisterManager({ Name = &quot;Settings&quot;, GetData = function(player, profile) return profile.Data.Settings end, ReplicationTargets = &quot;Self&quot;, Tags = {UserId = player.UserId}, }) Modifying the given table DO NOT MODIFY THE TABLE AFTER PASSING IT. Treat it as frozen. Doing so can cause potential desyncs between players.  "},{"title":"Start​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#Start","content":"&lt;/&gt; ServerPlayerDataManager:Start(ppm: PlayerProfileManager?) → () Starts the service and sets up all the Player's data managers. local PlayerDataManager = PlayerDataManager.Server.new() local PPM = PlayerProfileManager.new() PlayerDataManager:Start(PPM)  "},{"title":"[0.3.0]FusionUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/[0.3.0] FusionUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#properties","content":" "},{"title":"scope​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#scope","content":"&lt;/&gt; [0.3.0] FusionUtil.scope: Scope&lt;Fusion,FusionUtil&gt; The global scope for FusionUtil.  "},{"title":"scopeless​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#scopeless","content":"&lt;/&gt; [0.3.0] FusionUtil.scopeless: table A table of convenience functions for creating Fusion objects. These functions do not require the use of a scope, they by default use the FusionUtil scope. These are meant to be used in places where you want to create persistent Fusion objects without needing to pass a scope. local Value = FusionUtil.scopeless.Value local a = Value(10)  "},{"title":"Functions​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#functions","content":" "},{"title":"isState​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#isState","content":"&lt;/&gt; [0.3.0] FusionUtil.isState(arg: any) → boolean Checks if the arg is a Fusion StateObject.  "},{"title":"removeTask​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#removeTask","content":"&lt;/&gt; [0.3.0] FusionUtil.removeTask( scope: Scope&lt;any&gt;,-- The scope to remove the task from taskId: any,-- The taskId of the task to remove dontCleanup: boolean?-- Whether or not to run the cleanup function on the task ) → Task?-- The task that was removed Removes a task from a scope by its taskId. local s = scoped(Fusion, FusionUtil) local id = &quot;Greeting&quot; local task = s:addTask(function() print(&quot;Hello, World!&quot;) end, nil, id) s:removeTask(id) -- Hello, World!   "},{"title":"addTask​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#addTask","content":"&lt;/&gt; [0.3.0] FusionUtil.addTask( scope: Scope&lt;any&gt;,-- The scope to add the task to task: Task&amp;T,-- The task to add methodName: any?,-- The method to call when the task is removed taskId: any?-- The taskId of the task ) → Task-- The task that was added Adds a task to a scope. If a taskId is provided, it will remove any existing task with that taskId. local s = scoped(Fusion, FusionUtil) local id = &quot;Greeting&quot; local task = s:addTask(function() print(&quot;Hello, World!&quot;) end, nil, id) Fusion.doCleanup(s) -- Hello, World!   "},{"title":"getTask​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#getTask","content":"&lt;/&gt; [0.3.0] FusionUtil.getTask( scope: Scope&lt;any&gt;,-- The scope to search for the task taskId: any-- The taskId of the task to find ) → Task?-- The task if found, nil otherwise Gets a task from a scope by its taskId. local s = scoped(Fusion, FusionUtil) local id = &quot;Greeting&quot; local task = s:addTask(function() print(&quot;Hello, World!&quot;) end, nil, id) local foundTask = s:getTask(id) foundTask() -- Hello, World!   "},{"title":"promiseState​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#promiseState","content":"&lt;/&gt; [0.3.0] FusionUtil.promiseState( scope: Scope&lt;any&gt;, state: State&lt;T&gt;, predicate: ((value: T) → boolean)?, canResolveImmediately: boolean? ) → Promise Creates a promise that resolves when the given state changes. If a predicate is given then the promise will only resolve if the predicate returns true. If the third argument canResolveImmediately is true, the promise will will check the predicate immediately. local a = s:Value(10) s:promiseState(a):andThen(function(value) print(&quot;Value is now&quot;, value) end) a:set(20) -- &quot;Value is now 20&quot; a:set(30) -- Promise has already resolved so no print   "},{"title":"bindTo​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#bindTo","content":"&lt;/&gt; [0.3.0] FusionUtil.bindTo( scope: Scope&lt;any&gt;, obj: Instance ) → Instance  Binds a scope to the lifecycle of an instance. When the instance is destroyed, the scope will be cleaned up. Also applies vice versa; when the scope is cleaned up, the instance will be destroyed. local s = scoped(Fusion, FusionUtil) s:bindTo(s:New &quot;Part&quot; { Anchored = true; })   "},{"title":"ensureIsState​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#ensureIsState","content":"&lt;/&gt; [0.3.0] FusionUtil.ensureIsState( scope: Scope&lt;any&gt;,-- The scope in which to create the new state object data: UsedAs&lt;T&gt;?,-- The potential state object defaultValue: T?,-- The default value to use if the data is nil datatype: (string | {string})?-- The type or types of the data expected in the state ) → StateObject&lt;T&gt;-- The existing or newly created state object Ensures a passed data is a StateObject. If it is not, it will be converted to one.  "},{"title":"formatAssetId​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#formatAssetId","content":"&lt;/&gt; [0.3.0] FusionUtil.formatAssetId( scope: Scope&lt;any&gt;, id: UsedAs&lt;string | number&gt;,-- The AssetId to ensure default: (string | number)?-- The default AssetId to use if the id is nil ) → CanBeState&lt;string&gt;-- The State that is synced with the AssetId Takes an AssetId and formats it to a valid string. local s = scoped(Fusion, FusionUtil) local assetId = s:formatAssetId(&quot;rbxefsefawsetid://1234567890&quot;) print( peek(assetId) ) -- &quot;rbxassetid://1234567890&quot; local assetId = s:formatAssetId(1234567890) print( peek(assetId) ) -- &quot;rbxassetid://1234567890&quot;   "},{"title":"ratio​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#ratio","content":"&lt;/&gt; [0.3.0] FusionUtil.ratio( scope: Scope&lt;any&gt;,-- The scope to create the State in numerator: UsedAs&lt;number&gt;,-- The numerator of the ratio denominator: UsedAs&lt;number&gt;,-- The denominator of the ratio mutator: (UsedAs&lt;T&gt; | ( ratio: number, use: Use ) → T)?-- An optional State to scale by or a function to mutate the ratio ) → State&lt;T&gt;-- The ratio (Potentially mutated) Generates a computed that calculates the ratio of two numbers as a State. local s = scoped(Fusion, FusionUtil) local numerator = s:Value(100) local denominator = s:Value(200) local ratio = s:ratio(numerator, denominator) print( peek(ratio) ) -- 0.5   "},{"title":"lerpNumber​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#lerpNumber","content":"&lt;/&gt; [0.3.0] FusionUtil.lerpNumber( scope: Scope&lt;any&gt;, n1: UsedAs&lt;number&gt;,-- The first number state n2: UsedAs&lt;number&gt;,-- The second number state alpha: UsedAs&lt;number&gt;,-- The alpha state _use: ((any) → (any))?-- An optional function to use to get the values of the states ) → UsedAs&lt;number&gt;-- The resultant lerped number state/value Lerps between two number states. If no use function is given then it returns a state local a = Value(10) local b = Value(20) local alpha = Value(0.5) local z = FusionUtil.lerpNumber(a, b, alpha) print( peek(z) ) -- 15   "},{"title":"eq​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#eq","content":"&lt;/&gt; [0.3.0] FusionUtil.eq( scope: Scope&lt;any&gt;, stateToCheck1: UsedAs&lt;any&gt;,-- The first potential state to check stateToCheck2: UsedAs&lt;any&gt;-- The second potential state to check ) → State&lt;boolean&gt;-- A state resolving to the equality of the two given arguments A simple equality function that returns true if the two states are equal. local s = scoped(Fusion, FusionUtil) local a = s:Value(10) local b = s:Value(10) local c = s:eq(a, b) print( peek(c) ) -- true a:set(20) print( peek(c) ) -- false   "},{"title":"observeState​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#observeState","content":"&lt;/&gt; [0.3.0] FusionUtil.observeState( scope: Scope&lt;any&gt;, fusionState: UsedAs&lt;T&gt;,-- The state object to observe callback: (stateValue: T) → ()-- The callback to call when the fusionState is updated ) → () → ()-- A function that will disconnect the observer Calls the provided callback immediately with the initial state and then again anytime the state updates.  "},{"title":"copyState​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#copyState","content":"&lt;/&gt; [0.3.0] FusionUtil.copyState( scope: Scope&lt;any&gt;, state: UsedAs&lt;T&gt;-- The state object to copy ) → ( State&lt;T&gt;,-- The new state object copied from the original state object () → ()-- A function to disconnect the syncronization of the two states ) Copies the state of a state object to a new state object. If the state object is updated, the new state object will be updated as well. local s = scoped(Fusion, FusionUtil) local a = s:Value(10) local b, disconnect = s:copyState(a) print( peek(b) ) -- 10 a:set(20) print( peek(b) ) -- 20   "},{"title":"syncValues​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#syncValues","content":"&lt;/&gt; [0.3.0] FusionUtil.syncValues( scope: Scope&lt;any&gt;, stateToWatch: State&lt;any&gt;,-- The state to watch for changes valueToSet: Value&lt;any,any&gt;-- The value to set when the state changes ) → () → ()-- A function that will disconnect the observer Syncronizes a StateObject to a Value. The Value will be set to the StateObject's value any time it changes. local s = scoped(Fusion, FusionUtil) local a = s:Value(123) local b = s:Value(0) local disconnect = s:syncValues(a, b) print( peek(b) ) -- 123 a:set(456) print( peek(b) ) -- 456 disconnect()   "},{"title":"arrayInsert​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#arrayInsert","content":"&lt;/&gt; [0.3.0] FusionUtil.arrayInsert( valueState: Value&lt;{any},any&gt;,-- The container state object ...: ( number, any ) | (any) ) → () Inserts a value into a container state object. Follows the structure of table.insert so giving an extra arg for the index will insert the value at that index. local myArr = s:Value({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) FusionUtil.arrayInsert(myArr, 2, &quot;X&quot;) print( peek(myArr) ) -- {&quot;A&quot;, &quot;X&quot;, &quot;B&quot;, &quot;C&quot;} FusionUtil.arrayInsert(myArr, &quot;Z&quot;) print( peek(myArr) ) -- {&quot;A&quot;, &quot;X&quot;, &quot;B&quot;, &quot;C&quot;, &quot;Z&quot;}   "},{"title":"arrayRemove​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#arrayRemove","content":"&lt;/&gt; [0.3.0] FusionUtil.arrayRemove( valueState: Value&lt;{any},any&gt;,-- The container state object index: number?,-- The index of the value to remove swapRemove: boolean?-- Whether to swap the value with the last value before removing it. This is faster than a regular remove but does not maintain the order of the array. ) → any Removes a value from a container state object. local myArr = s:Value({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) local removedValue = FusionUtil.arrayRemove(myArr, 2) print( peek(myArr) ) -- {&quot;A&quot;, &quot;C&quot;} print( removedValue ) -- &quot;B&quot;   "},{"title":"arraySwapRemove​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#arraySwapRemove","content":"&lt;/&gt; [0.3.0] FusionUtil.arraySwapRemove( valueState: Value&lt;{any},any&gt;,-- The container state object index: number-- the index of the value to swap out ) → any Swaps two values in a container state object. local myArr = s:Value({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) local removedValue = FusionUtil.arraySwapRemove(myArr, 1) print( peek(myArr) ) -- {&quot;C&quot;, &quot;B&quot;} print( removedValue ) -- &quot;A&quot;   "},{"title":"arrayRemoveFirstValue​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#arrayRemoveFirstValue","content":"&lt;/&gt; [0.3.0] FusionUtil.arrayRemoveFirstValue( valueState: Value&lt;{any},any&gt;,-- The container state object value: any,-- The value to remove swapRemove: boolean?-- Whether to swap the value with the last value before removing it. This is faster than a regular remove but does not maintain the order of the array. ) → any Removes the first instance of a value from a container state object. local myArr = s:Value({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) local indexOfRemovedValue = FusionUtil.arrayRemoveFirstValue(myArr, &quot;A&quot;) print( peek(myArr) ) -- {&quot;B&quot;, &quot;C&quot;} print( indexOfRemovedValue ) -- 1   "},{"title":"arraySwapRemoveFirstValue​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#arraySwapRemoveFirstValue","content":"&lt;/&gt; [0.3.0] FusionUtil.arraySwapRemoveFirstValue( valueState: Value&lt;{any},any&gt;,-- The container state object value: any-- The value to remove ) → any Removes the first instance of a value from a container state object via swap replacement. Faster than normal removal but does not maintain order. local myArr = s:Value({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) FusionUtil.arraySwapRemoveFirstValue(myArr, &quot;A&quot;) print( peek(myArr) ) -- {&quot;C&quot;, &quot;B&quot;}   "},{"title":"arraySet​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#arraySet","content":"&lt;/&gt; [0.3.0] FusionUtil.arraySet( valueState: Value&lt;{any},any&gt;,-- The container state object index: number,-- The index of the value to change newValue: any,-- The new value to change index to updateInsteadOfReplace: boolean?-- Whether to update the value at the index if it is a ValueState instead of overwriting it ) → () Sets a value in a container state object. local myArr = s:Value({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) FusionUtil.arraySet(myArr, 2, &quot;X&quot;) print( peek(myArr) ) -- {&quot;A&quot;, &quot;X&quot;, &quot;C&quot;}   "},{"title":"arraySetFirstValue​","type":1,"pageTitle":"[0.3.0]FusionUtil","url":"/ModulesOnRails/api/[0.3.0] FusionUtil#arraySetFirstValue","content":"&lt;/&gt; [0.3.0] FusionUtil.arraySetFirstValue( valueState: Value&lt;{any},any&gt;,-- The container state object valueToFind: any,-- The value to find valueToReplaceWith: any,-- The value to replace the found value with updateInsteadOfReplace: boolean?-- Whether to update the value at the index if it is a ValueState instead of overwriting it ) → () Sets the first instance of a value in a container state object. local myArr = s:Value({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) FusionUtil.arraySetFirstValue(myArr, &quot;B&quot;, &quot;X&quot;) print( peek(myArr) ) -- {&quot;A&quot;, &quot;X&quot;, &quot;C&quot;}  "},{"title":"Symbol","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Symbol","content":"On this page Symbol Represents a unique object. Symbols are often used as unique keys in tables. This is useful to avoid possible collisions with a key in a table, since the symbol will always be unique and cannot be reconstructed. All Unique Every creation of a symbol is unique, even if the given names are the same. local Symbol = require(packages.Symbol) -- Create a symbol: local symbol = Symbol(&quot;MySymbol&quot;) -- The name is optional: local anotherSymbol = Symbol() -- Comparison: print(symbol == symbol) --&gt; true -- All symbol constructions are unique, regardless of the name: print(Symbol(&quot;Hello&quot;) == Symbol(&quot;Hello&quot;)) --&gt; false -- Commonly used as unique keys in a table: local DATA_KEY = Symbol(&quot;Data&quot;) local t = { -- Can only be accessed using the DATA_KEY symbol: [DATA_KEY] = {} } print(t[DATA_KEY]) --&gt; {} ","keywords":""},{"title":"Signal","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil Connected: boolean }   "},{"title":"Connection​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil Connected: boolean } Represents a connection. "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player , ...: any ) → nil-- The function to connect ) → Connection Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireExcept","content":"&lt;/&gt; RemoteSignal:FireExcept( ignorePlayer: Player ,-- The client to ignore ...: any-- Arguments passed to the other clients ) → () Fires the signal to all clients except the specified client. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireFor","content":"&lt;/&gt; RemoteSignal:FireFor( players: {Player }, ...: any ) → () Fires a signal at the clients within the players table. This is useful when signals need to fire for a specific set of players. For more complex firing, see FireFilter. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. local players = {somePlayer1, somePlayer2, somePlayer3} remoteSignal:FireFor(players, &quot;Hello, players!&quot;)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object.  "},{"title":"IsUnreliable​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#IsUnreliable","content":"&lt;/&gt; RemoteSignal:IsUnreliable() → boolean Returns true if the underlying RemoteSignal is bound to an UnreliableRemoteEvent object.  "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player , ...: any ) → nil-- The function to connect ) → Connection Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireExcept","content":"&lt;/&gt; RemoteSignal:FireExcept( ignorePlayer: Player ,-- The client to ignore ...: any-- Arguments passed to the other clients ) → () Fires the signal to all clients except the specified client. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireFor","content":"&lt;/&gt; RemoteSignal:FireFor( players: {Player }, ...: any ) → () Fires a signal at the clients within the players table. This is useful when signals need to fire for a specific set of players. For more complex firing, see FireFilter. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. local players = {somePlayer1, somePlayer2, somePlayer3} remoteSignal:FireFor(players, &quot;Hello, players!&quot;)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object. "},{"title":"TableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableReplicator","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#properties","content":" "},{"title":"Client​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#Client","content":"This item only works when running on the client. Client &lt;/&gt; TableReplicator.Client: ClientTableReplicator   "},{"title":"Server​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#Server","content":"This item only works when running on the server. Server &lt;/&gt; TableReplicator.Server: ServerTableReplicator  "},{"title":"Roam","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Roam","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#types","content":" "},{"title":"ServiceConfig​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#ServiceConfig","content":"&lt;/&gt; interface ServiceConfig { Name: string-- Name of the Service. Must be unique. Used when accessing via .getService RequiredServices: {Service}?-- The Services that this Service depends on. Roam will ensure that these Services are initialized before this Service. StartMethodName: string?-- Overrides default StartMethodName of &quot;RoamStart&quot; InitMethodName: string?-- Overrides default InitMethodName of &quot;RoamInit&quot; } local myOtherService = require(ReplicatedStorage.MyOtherService) local MyService = Roam.createService { Name = &quot;MyService&quot;, RequiredServices = {myOtherService}, } Deffering RequiredServices Do NOT add services to the RequiredServices after you have created or registered the service. This will cause undefined behavior. "},{"title":"Properties​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#ClassName","content":"&lt;/&gt; Roam.ClassName: &quot;Roam&quot; The ClassName of the Roam module.  "},{"title":"Debug​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#Debug","content":"&lt;/&gt; Roam.Debug: boolean Whether or not to print debug messages. Default is false.  "},{"title":"Bootstrappers​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#Bootstrappers","content":"&lt;/&gt; Roam.Bootstrappers: { Server: (script: Script ) → (), Client: (script: Script ) → () } A table of generic bootstrappers for Roam / Orion. "},{"title":"Functions​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#functions","content":" "},{"title":"createService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#createService","content":"&lt;/&gt; Roam.createService(serviceDef: ServiceConfig) → Service Creates a Service/Table with Roam to be Initialized and Started when Roam starts. Cannot be called after Roam has been started. local Roam = require(ReplicatedStorage.Roam) local MyService = Roam.createService { Name = &quot;MyService&quot; } function MyService:DoSomething() print(&quot;yeee haw!&quot;) end -- Default StartMethodName is &quot;RoamStart&quot; (Can be overriden in service creation config) function MyService:RoamStart() print(&quot;MyService started!&quot;) self:DoSomething() end -- Default InitMethodName is &quot;RoamInit&quot; (Can be overriden in service creation config) function MyService:RoamInit() print(&quot;MyService initialized!&quot;) end return MyService   "},{"title":"registerService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#registerService","content":"&lt;/&gt; Roam.registerService( service: Service, serviceConfig: (ServiceConfig | string)? ) → Service Registers a Service/Table with Roam to be Initialized and Started when Roam starts. Cannot be called after Roam has been started. This method was added to allow for easy backporting of existing services to Roam. This is an alternative method to setting up services over using createService. local MyRegisteredService = {} function MyRegisteredService:Start() print(&quot;MyRegisteredService started!&quot;) end function MyRegisteredService:Init() print(&quot;MyRegisteredService initialized!&quot;) end local Roam = require(Packages.Roam) Roam.registerService(MyRegisteredService, &quot;MyRegisteredService&quot;) return MyRegisteredService   "},{"title":"requireModules​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#requireModules","content":"&lt;/&gt; Roam.requireModules( parents: Instance | {Instance }, config: { DeepSearch: boolean?, RequirePredicate: ((obj: ModuleScript ) → boolean)?, IgnoreDescendantsPredicate: ((obj: Instance ) → boolean)?, }? ) → {Service} Requires all the modules that are children of the given parent. This is an easy way to quickly load all services that might be in a folder. Takes an optional predicate function to filter which modules are loaded. Services collected this way must not yield. DeepSearch -&gt; whether it checks descendants or just children RequirePredicate -&gt; a predicate function that determines whether a module should be required IgnoreDescendantsPredicate -&gt; A Predicate for whether the Descendants of the Module should be Searched (Only matters if DeepSearch is true) local pred = function(obj: ModuleScript): boolean return obj.Name:match(&quot;Service$&quot;) ~= nil end Roam.requireModules(ReplicatedStorage.Shared, { DeepSearch = true, RequirePredicate = pred, IgnoreDescendantsPredicate = function(obj: Instance): boolean return obj.Name == &quot;Ignore&quot; end, })   "},{"title":"getNameFromService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#getNameFromService","content":"&lt;/&gt; Roam.getNameFromService(service: Service) → string Fetches the name of a registered Service.  "},{"title":"getService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#getService","content":"&lt;/&gt; Roam.getService(serviceName: string) → Service Fetches a registered Service by name. Cannot be called until Roam has been started.  "},{"title":"start​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#start","content":"&lt;/&gt; Roam.start(postInitPreStart: (() → (Promise?))?) → Promise Starts Roam. Should only be called once. Optional argument postInitPreStart is a function that is called after all services have been initialized, but before they are started. caution Be sure that all services have been created before calling Start. Services cannot be added later. Roam.start() :andThenCall(print, &quot;Roam started!&quot;) :catch(warn)   "},{"title":"onStart​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#onStart","content":"&lt;/&gt; Roam.onStart() → Promise Returns a promise that is resolved once Roam has started. This is useful for any code that needs to tie into Roam services but is not the script that called Start. Roam.onStart():andThen(function() local MyService = Roam.Services.MyService MyService:DoSomething() end):catch(warn)   "},{"title":"isReady​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#isReady","content":"&lt;/&gt; Roam.isReady() → boolean Returns whether or not Roam has been successfully started and is ready for external access. "},{"title":"ServerTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#types","content":" "},{"title":"ReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicationTargets","content":"&lt;/&gt; type ReplicationTargets = &quot;All&quot; | Player | {Player } The Player(s) that the STR should replicate to. If &quot;All&quot; is given then the STR will replicate to all current and future players.  "},{"title":"ReplicationToken​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicationToken","content":"&lt;/&gt; type ReplicationToken = {Name: string} A unique symbol that identifies the STR Class. This is used to identify the STR Class when it is replicated to the client. Use .Token to generate an object of this type. Do NOT manually create the table. "},{"title":"Properties​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#properties","content":" "},{"title":"AddedActivePlayer​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#AddedActivePlayer","content":"&lt;/&gt; ServerTableReplicator.AddedActivePlayer: Signal&lt;Player &gt; A signal that fires whenever a player starts being replicated to. This happens when their client requests the current data from the server.  "},{"title":"All​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#All","content":"&lt;/&gt; ServerTableReplicator.All: ServerTableReplicator A STR that replicates to all current and future players. Used as a global parent for child STRs that need a home and should be replicated to all current and future players. Do not modify anything about this STR, only use it as a Parent.  "},{"title":"None​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#None","content":"&lt;/&gt; ServerTableReplicator.None: ServerTableReplicator A STR that doesnt replicate to anyone. Used as a global parent for child STRs that shouldnt be replicated. Do not modify anything about this STR, only use it as a Parent. "},{"title":"Functions​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#functions","content":" "},{"title":"Token​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Token","content":"&lt;/&gt; ServerTableReplicator.Token(tokenName: string) → ReplicationToken Returns a Token Symbol that is used for identifying the ServerTableReplicator Class. We use unique symbols instead of strings to prevent accidental collisions. warning This may only be called once per unique string. The returned symbol should be used repeatedly instead of calling this function again. Calling this function again with the same string will result in an error.  "},{"title":"new​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#new","content":"&lt;/&gt; ServerTableReplicator.new(config: { Token: ReplicationToken, TableManager: TableManager, ReplicationTargets: ReplicationTargets?, Parent: ServerTableReplicator?, Tags: {[string]: any}?, Client: {[string]: any}?, }) → () Creates a new ServerTableReplicator instance. The config must be given a TableManager instance and a Token Symbol. A list of replication targets can be provided to specify which players the STR should replicate to immediately. If no replication targets are specified, the STR will not replicate to any players. You can specify a Parent STR instead of giving ReplicationTargets and it will inherit the replication targets of the top level STR. Optionally, a list of tags can be provided to help identify the STR. The tags list will become immutable internally after the STR is created. EXAMPLE: -- Some Server Script local token = ServerTableReplicator.Token(&quot;PlayerData&quot;) Players.PlayerAdded:Connect(function(player) local manager = TableManager.new({ Money = math.random(1, 100); }) local replicator = ServerTableReplicator.new({ TableManager = manager, Token = token, ReplicationTargets = &quot;All&quot;, Tags = {UserId = player.UserId}, }) end) -- Some Client Script ClientTableReplicator.onNew(&quot;PlayerData&quot;, function(replicator) print(&quot;New PlayerData STR: &quot;, replicator:GetTag(&quot;UserId&quot;)) print(&quot;Money: &quot;, replicator:GetTableManager():Get(&quot;Money&quot;)) end) Top Level Replicators A replicator must be given either a Parent Replicator or a list of ReplicationTargets. If both are given then it will produce an error. If you give ReplicationTargets then that Replicator will be known as TopLevel. Only TopLevel Replicators can have their ReplicationTargets manually changed. If a Parent Replicator is given, the Child Replicator will inherit the replication targets of the Ancestor TopLevel Replicator.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Destroy","content":"&lt;/&gt; ServerTableReplicator:Destroy() → () Destroys the Replicator on both the Server and any replicated Clients  "},{"title":"Subscribe​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Subscribe","content":"&lt;/&gt; ServerTableReplicator:Subscribe(targets: ReplicationTargets) → () Adds a player or list of players to the replication targets.  "},{"title":"Unsubscribe​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Unsubscribe","content":"&lt;/&gt; ServerTableReplicator:Unsubscribe(targets: ReplicationTargets) → () Removes a player or list of players from the replication targets.  "},{"title":"SetSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetSubscribers","content":"&lt;/&gt; ServerTableReplicator:SetSubscribers(targets: ReplicationTargets) → () Overwrites the current replication targets with the new targets.  "},{"title":"IsSubscribed​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsSubscribed","content":"&lt;/&gt; ServerTableReplicator:IsSubscribed(player: Player ) → boolean Checks whether the player is a valid target for replication. Not whether the player is currently being replicated to.  "},{"title":"IsSubscribedToAll​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsSubscribedToAll","content":"&lt;/&gt; ServerTableReplicator:IsSubscribedToAll() → boolean Returns whether or not this STR is replicating to all current and future players.  "},{"title":"GetSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetSubscribers","content":"&lt;/&gt; ServerTableReplicator:GetSubscribers() → {Player } Gets the list of Players that this Replicator is attempting to replicate to.  "},{"title":"GetActiveSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetActiveSubscribers","content":"&lt;/&gt; ServerTableReplicator:GetActiveSubscribers() → {Player } Gets the list of Players that this Replicator is currently replicating to. This is different from GetReplicationTargets as it does not include pending replication targets.  "},{"title":"SetParent​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetParent","content":"&lt;/&gt; ServerTableReplicator:SetParent(newParent: ServerTableReplicator) → () Sets the Parent of this STR to the given STR. "},{"title":"StringUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/StringUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#types","content":" "},{"title":"StrokeData​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#StrokeData","content":"&lt;/&gt; interface StrokeData { Color: Color3? -- The color of the stroke. Joins: (&quot;miter&quot; | &quot;round&quot; | &quot;bevel&quot;)? | Enum.LineJoinMode?-- The type of joins the stroke has. Thickness: number?-- The thickness Transparency: number?-- The transparency of the stroke. }  "},{"title":"Functions​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#functions","content":" "},{"title":"color​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#color","content":"&lt;/&gt; StringUtil.color( text: string,-- The text to apply the color to. color: Color3 -- The color to apply to the text. ) → string-- The new string with the color applied. Returns a string with the given color applied to it.  "},{"title":"stroke​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#stroke","content":"&lt;/&gt; StringUtil.stroke( text: string,-- The text to apply the stroke to. data: StrokeData-- The stroke data to apply to the text. ) → string-- The new string with the stroke applied. Returns a string with the given stroke applied to it.  "},{"title":"rich​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#rich","content":"&lt;/&gt; StringUtil.rich( text: string,-- The text to apply the options to. options: { Color: Color3? , Stroke: StrokeData?, Bold: boolean?, Italic: boolean?, Underline: boolean?, }-- The options to apply to the text. ) → string-- The new string with the options applied. Returns a string with the given options applied to it.  "},{"title":"formatAssetId​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#formatAssetId","content":"&lt;/&gt; StringUtil.formatAssetId( id: string | number-- The asset id to format. ) → string-- The formatted asset id. Ensures a given number or string is formatted as an asset id. StringUtil.formatAssetId(123456) -- &quot;rbxassetid://123456&quot; StringUtil.formatAssetId(&quot;123456&quot;) -- &quot;rbxassetid://123456&quot; StringUtil.formatAssetId(&quot;rbxassetid://123456&quot;) -- &quot;rbxassetid://123456&quot;   "},{"title":"formatNumberWithCommas​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#formatNumberWithCommas","content":"&lt;/&gt; StringUtil.formatNumberWithCommas(num: number | string) → string Formats a number with commas. StringUtil.formatNumberWithCommas(&quot;12&quot;) -- &quot;12&quot; StringUtil.formatNumberWithCommas(1234) -- &quot;1,234&quot; StringUtil.formatNumberWithCommas(123456) -- &quot;123,456&quot; StringUtil.formatNumberWithCommas(&quot;1234567&quot;) -- &quot;1,234,567&quot; StringUtil.formatNumberWithCommas(12345.6789) -- &quot;12,345.6789&quot;   "},{"title":"truncateNumberWithSuffix​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#truncateNumberWithSuffix","content":"&lt;/&gt; StringUtil.truncateNumberWithSuffix( num: number | string, config: { MaxDecimals: number?, ShowZeroes: boolean?, AddSpace: boolean?, }? ) → string Truncates a number to its nearest factor of 1000 and replaces the chopped off numbers with an appropriate suffix to enable easier reading. MaxDecimals: The maximum number of decimals to show. [Default: 1] ShowZeroes: Whether to always show zeroes after the decimal point. AddSpace: Whether to add a space between the number and the suffix StringUtil.truncateNumberWithSuffix(1.234) -- 1.2 StringUtil.truncateNumberWithSuffix(123) -- 123 StringUtil.truncateNumberWithSuffix(123, {MaxDecimals = 2, ShowZeroes = true}) -- 123.00 StringUtil.truncateNumberWithSuffix(1234) -- 1.2K StringUtil.truncateNumberWithSuffix(123456) -- 123.5K StringUtil.truncateNumberWithSuffix(123456, {MaxDecimals = 1}) -- 123.4K StringUtil.truncateNumberWithSuffix(&quot;123456&quot;, {MaxDecimals = 2}) -- 123.45K StringUtil.truncateNumberWithSuffix(123456, {MaxDecimals = 3}) -- 123.456K StringUtil.truncateNumberWithSuffix(123456789) -- 123.4M StringUtil.truncateNumberWithSuffix(1234567890) -- 1.2B   "},{"title":"formatTime​","type":1,"pageTitle":"StringUtil","url":"/ModulesOnRails/api/StringUtil#formatTime","content":"&lt;/&gt; StringUtil.formatTime( inputTime: number,-- The time to format. inputTimeType: string?,-- The type of time that is being given to format. (d, h, m, s, ds, cs, ms) outputStringFormat: string?,-- The format of the output string. Must separated by colons, if you put a number before the timetype it will make sure the number has atleast that length, adding zeroes before it as needed. By default it will be (2h:2m:2s) config: { HideParentZeroValues: boolean?, Delimeter: string?, }? ) → string-- The formatted time string. Takes a number, a string defining the type of time given, and an output format and formats it to a pleasing structure ideal for displaying time. Examples: StringUtil.formatTime(3600, &quot;s&quot;, &quot;2h:2m:2s&quot;) -- &quot;01:00:00&quot; StringUtil.formatTime(125, &quot;s&quot;, &quot;2h:2m:2s&quot;) -- &quot;00:02:05&quot; StringUtil.formatTime(125, &quot;s&quot;, &quot;1h:1m:1s&quot;) -- &quot;0:2:5&quot; StringUtil.formatTime(125, &quot;s&quot;, &quot;h:m:s&quot;) -- &quot;0:2:5&quot; StringUtil.formatTime(125, &quot;s&quot;, &quot;2h:2m:2s&quot;, {HideParentZeroValues = true}) -- &quot;02:05&quot; StringUtil.formatTime(125, &quot;s&quot;, &quot;h:m:s:ds&quot;) -- &quot;0:2:5:0&quot; StringUtil.formatTime(125, &quot;s&quot;, &quot;h:m:s:ds&quot;, {HideParentZeroValues = true}) -- &quot;2:5:0&quot; StringUtil.formatTime(3725, &quot;s&quot;, &quot;h:s&quot;) -- &quot;1:125&quot; StringUtil.formatTime(1000, &quot;ms&quot;, &quot;s&quot;) -- &quot;1&quot;  "},{"title":"TableReplicatorSingleton","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableReplicatorSingleton","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#new","content":"&lt;/&gt; TableReplicatorSingleton.new(config: Config) → () "},{"title":"Types","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton##","content":""},{"title":"​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Config","content":"interface Config { ClassTokenName: string-- The name of the class token to listen for. DefaultDataSchema: table?-- The default schema to use if the replicator is not ready yet. ConditionFn: ((replicator: ClientTableReplicator) → boolean)?-- A function that returns whether or not the replicator is valid and should be bound. }  Creates a new TableReplicatorSingleton. local ClientPlayerData = TableReplicatorSingleton.new { ClassTokenName = &quot;PlayerData&quot;; DefaultDataSchema = Import(&quot;PlayerDataSchema&quot;); ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end; } return ClientPlayerData   "},{"title":"Get​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Get","content":"&lt;/&gt; TableReplicatorSingleton:Get( path: Path, index: number? ) → any? Fetches the value at the path. An index can be provided to fetch the value at that index. If the value is not ready yet, it will return the value rom the default schema if one was given. If the path is untraversable, it will return nil. local coins = ClientPlayerData:Get(&quot;Coins&quot;) local thirdItem = ClientPlayerData:Get(&quot;Inventory&quot;, 3) -- Equivalent to `ClientPlayerData:Get(&quot;Inventory&quot;)[3]`   "},{"title":"Observe​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Observe","content":"&lt;/&gt; TableReplicatorSingleton:Observe( path: Path, callback: (newValue: any?) → () ) → () → () Called immediately and then whenever the value at the path changes. The callback will be called with the new value. ClientPlayerData:Observe(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToValueChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToValueChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToValueChange( path: Path, callback: (...any) → () ) → function-- A function that, when called, will disconnect the listener. Called when the value at the path is changed. The callback will be called with the new value. ClientPlayerData:ListenToValueChange(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToAnyChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToAnyChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToAnyChange( path: Path, callback: (...any) → () ) → () → () Called when the value at the path is changed through any means. This includes if the value is an array and a value in the array is changed, inserted, or removed.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ToFusionState","content":"&lt;/&gt; TableReplicatorSingleton:ToFusionState(path: Path) → State&lt;any&gt; Returns a Fusion State object that will automatically update when the value at the path changes. This is useful for when you want to use Fusion dependents to respond to changes in the value. local coinsState = ClientPlayerData:ToFusionState(&quot;Coins&quot;) New &quot;TextLabel&quot; { Text = coinsState; }   "},{"title":"GetTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableManager","content":"&lt;/&gt; TableReplicatorSingleton:GetTableManager() → TableManager Gets the TableManager for the TableReplicatorSingleton. This will error if the TableManager is not ready yet. local TM = ClientPlayerData:GetTableManager()   "},{"title":"GetTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:GetTableReplicator() → ClientTableReplicator Gets the TableReplicator for the TableReplicatorSingleton. This will error if the TableReplicator is not ready yet. local TR = ClientPlayerData:GetTableReplicator()   "},{"title":"PromiseTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableManager","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableManager() → Promise&lt;TableManager&gt; Returns a promise that resolves with the TableManager when it is ready. ClientPlayerData:PromiseTableManager():andThen(function(TM: TableManager) print(&quot;TableManager is ready!&quot;) end)   "},{"title":"PromiseTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableReplicator() → Promise&lt;ClientTableReplicator&gt; Returns a promise that resolves with the TableReplicator when it is ready. ClientPlayerData:PromiseTableReplicator():andThen(function(TR: ClientTableReplicator) print(&quot;TableReplicator is ready!&quot;) end)   "},{"title":"IsReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#IsReady","content":"&lt;/&gt; TableReplicatorSingleton:IsReady() → boolean Returns whether or not a valid Replicator has been found and hooked into. if ClientPlayerData:IsReady() then print(&quot;We have a valid Replicator!&quot;) end   "},{"title":"OnReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#OnReady","content":"&lt;/&gt; TableReplicatorSingleton:OnReady() → Promise&lt;()&gt; Returns a promise that resolves when the TableReplicatorSingleton is ready. ClientPlayerData:OnReady():andThen(function() print(&quot;Found a valid Replicator!&quot;) end)  "},{"title":"ServerComm","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#types","content":" "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions.  "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#new","content":"&lt;/&gt; ServerComm.new( parent: Instance , namespace: string? ) → ServerComm Constructs a ServerComm object. The namespace parameter is used in cases where more than one ServerComm object may be bound to the same object. Otherwise, a default namespace is used. local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) -- If many might exist in the given parent, use a unique namespace: local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;), &quot;MyNamespace&quot;)   "},{"title":"new​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#new","content":"&lt;/&gt; ServerComm.new( parent: Instance , namespace: string? ) → ServerComm Constructs a ServerComm object. The namespace parameter is used in cases where more than one ServerComm object may be bound to the same object. Otherwise, a default namespace is used. local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) -- If many might exist in the given parent, use a unique namespace: local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;), &quot;MyNamespace&quot;)   "},{"title":"BindFunction​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#BindFunction","content":"&lt;/&gt; ServerComm:BindFunction( name: string, fn: ( player: Player , ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired. local function GetSomething(player: Player) return &quot;Something&quot; end serverComm:BindFunction(&quot;GetSomething&quot;, GetSomething)   "},{"title":"WrapMethod​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#WrapMethod","content":"&lt;/&gt; ServerComm:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Binds a function to a table method. The name must match the name of the method in the table. The same name will be used on the client to access the given function. local MyObject = { _Data = 10, } function MyObject:GetData(player: Player) return self._Data end serverComm:WrapMethod(MyObject, &quot;GetData&quot;)   "},{"title":"CreateSignal​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#CreateSignal","content":"&lt;/&gt; ServerComm:CreateSignal( name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal Creates a signal that can be used to fire data to the clients or receive data from the clients. local mySignal = serverComm:CreateSignal(&quot;MySignal&quot;) -- Examples of firing in different ways (see docs for RemoteSignal for further info): mySignal:Fire(somePlayer, &quot;Hello world&quot;) mySignal:FireAll(&quot;Hi there&quot;) mySignal:FireExcept(somePlayer, &quot;Hello everyone except &quot; .. somePlayer.Name) mySignal:FireFilter(function(player) return player.Team == someCoolTeam end, &quot;Hello cool team&quot;) -- Example of listening for clients to send data: mySignal:Connect(function(player, message) print(&quot;Got a message from &quot; .. player.Name .. &quot;:&quot;, message) end)   "},{"title":"CreateProperty​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#CreateProperty","content":"&lt;/&gt; ServerComm:CreateProperty( name: string, initialValue: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteProperty Create a property object which will replicate its property value to the clients. Optionally, specific clients can be targeted with different property values. local comm = Comm.ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) local mapInfo = comm:CreateProperty(&quot;MapInfo&quot;, { MapName = &quot;TheAwesomeMap&quot;, MapDuration = 60, }) -- Change the data: mapInfo:Set({ MapName = &quot;AnotherMap&quot;, MapDuration = 30, }) -- Change the data for one player: mapInfo:SetFor(somePlayer, { MapName = &quot;ASpecialMapForYou&quot;, MapDuration = 90, }) -- Change data based on a predicate function: mapInfo:SetFilter(function(player) return player.Team == game.Teams.SomeSpecialTeam end, { MapName = &quot;TeamMap&quot;, MapDuration = 20, })   "},{"title":"Destroy​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#Destroy","content":"&lt;/&gt; ServerComm:Destroy() → () Destroy the ServerComm object.  "},{"title":"BindFunction​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#BindFunction","content":"&lt;/&gt; ServerComm:BindFunction( name: string, fn: ( player: Player , ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired. local function GetSomething(player: Player) return &quot;Something&quot; end serverComm:BindFunction(&quot;GetSomething&quot;, GetSomething)   "},{"title":"WrapMethod​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#WrapMethod","content":"&lt;/&gt; ServerComm:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Binds a function to a table method. The name must match the name of the method in the table. The same name will be used on the client to access the given function. local MyObject = { _Data = 10, } function MyObject:GetData(player: Player) return self._Data end serverComm:WrapMethod(MyObject, &quot;GetData&quot;)   "},{"title":"CreateSignal​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#CreateSignal","content":"&lt;/&gt; ServerComm:CreateSignal( name: string, unreliable: boolean?, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal Creates a signal that can be used to fire data to the clients or receive data from the clients. By default, signals use RemoteEvents internally. However, if the unreliable argument is set to true, then an UnreliableRemoteEvent will be used instead. local mySignal = serverComm:CreateSignal(&quot;MySignal&quot;) -- Examples of firing in different ways (see docs for RemoteSignal for further info): mySignal:Fire(somePlayer, &quot;Hello world&quot;) mySignal:FireAll(&quot;Hi there&quot;) mySignal:FireExcept(somePlayer, &quot;Hello everyone except &quot; .. somePlayer.Name) mySignal:FireFilter(function(player) return player.Team == someCoolTeam end, &quot;Hello cool team&quot;) -- Example of listening for clients to send data: mySignal:Connect(function(player, message) print(&quot;Got a message from &quot; .. player.Name .. &quot;:&quot;, message) end)   "},{"title":"CreateProperty​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#CreateProperty","content":"&lt;/&gt; ServerComm:CreateProperty( name: string, initialValue: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteProperty Create a property object which will replicate its property value to the clients. Optionally, specific clients can be targeted with different property values. local comm = Comm.ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) local mapInfo = comm:CreateProperty(&quot;MapInfo&quot;, { MapName = &quot;TheAwesomeMap&quot;, MapDuration = 60, }) -- Change the data: mapInfo:Set({ MapName = &quot;AnotherMap&quot;, MapDuration = 30, }) -- Change the data for one player: mapInfo:SetFor(somePlayer, { MapName = &quot;ASpecialMapForYou&quot;, MapDuration = 90, }) -- Change data based on a predicate function: mapInfo:SetFilter(function(player) return player.Team == game.Teams.SomeSpecialTeam end, { MapName = &quot;TeamMap&quot;, MapDuration = 20, })   "},{"title":"Destroy​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#Destroy","content":"&lt;/&gt; ServerComm:Destroy() → () Destroy the ServerComm object. "},{"title":"ScriptSignal","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ScriptSignal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#new","content":"&lt;/&gt; ScriptSignal.new() → ScriptSignal Creates a ScriptSignal object.  "},{"title":"Is​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Is","content":"&lt;/&gt; ScriptSignal.Is(object: any) → boolean Returns a boolean determining if the object is a ScriptSignal. local janitor = Janitor.new() local signal = ScriptSignal.new() ScriptSignal.Is(signal) -&gt; true ScriptSignal.Is(janitor) -&gt; false   "},{"title":"new​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#new","content":"&lt;/&gt; ScriptSignal.new() → ScriptSignal Creates a ScriptSignal object.  "},{"title":"Is​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Is","content":"&lt;/&gt; ScriptSignal.Is(object: any) → boolean Returns a boolean determining if the object is a ScriptSignal. local janitor = Janitor.new() local signal = ScriptSignal.new() ScriptSignal.Is(signal) -&gt; true ScriptSignal.Is(janitor) -&gt; false   "},{"title":"new​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#new","content":"&lt;/&gt; ScriptSignal.new() → ScriptSignal Creates a ScriptSignal object.  "},{"title":"Is​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Is","content":"&lt;/&gt; ScriptSignal.Is(object: any) → boolean Returns a boolean determining if the object is a ScriptSignal. local janitor = Janitor.new() local signal = ScriptSignal.new() ScriptSignal.Is(signal) -&gt; true ScriptSignal.Is(janitor) -&gt; false   "},{"title":"IsActive​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#IsActive","content":"&lt;/&gt; ScriptSignal:IsActive() → boolean Returns a boolean which determines if a ScriptSignal object is active. ScriptSignal:IsActive() -&gt; true ScriptSignal:Destroy() ScriptSignal:IsActive() -&gt; false   "},{"title":"Connect​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Connect","content":"&lt;/&gt; ScriptSignal:Connect(handler: (...: any) → ()) → ScriptConnection Connects a handler to a ScriptSignal object. ScriptSignal:Connect(function(text) print(text) end) ScriptSignal:Fire(&quot;Something&quot;) ScriptSignal:Fire(&quot;Something else&quot;) -- &quot;Something&quot; and then &quot;Something else&quot; are printed   "},{"title":"Once​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Once","content":"&lt;/&gt; ScriptSignal:Once(handler: (...: any) → ()) → ScriptConnection Connects a handler to a ScriptSignal object, but only allows that connection to run once. Any :Fire calls called afterwards won't trigger anything. ScriptSignal:Once(function() print(&quot;Connection fired&quot;) end) ScriptSignal:Fire() ScriptSignal:Fire() -- &quot;Connection fired&quot; is only fired once   "},{"title":"Wait​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; ScriptSignal:Wait() → ...any Yields the thread until a :Fire call occurs, returns what the signal was fired with. task.spawn(function() print( ScriptSignal:Wait() ) end) ScriptSignal:Fire(&quot;Arg&quot;, nil, 1, 2, 3, nil) -- &quot;Arg&quot;, nil, 1, 2, 3, nil are printed   "},{"title":"Fire​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Fire","content":"&lt;/&gt; ScriptSignal:Fire(...: any) → () Fires a ScriptSignal object with the arguments passed. ScriptSignal:Connect(function(text) print(text) end) ScriptSignal:Fire(&quot;Some Text...&quot;) -- &quot;Some Text...&quot; is printed twice   "},{"title":"DisconnectAll​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#DisconnectAll","content":"&lt;/&gt; ScriptSignal:DisconnectAll() → () Disconnects all connections from a ScriptSignal object without making it unusable. local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; true ScriptSignal:DisconnectAll() connection.Connected -&gt; false   "},{"title":"Destroy​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Destroy","content":"&lt;/&gt; ScriptSignal:Destroy() → () Destroys a ScriptSignal object, disconnecting all connections and making it unusable. ScriptSignal:Destroy() local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; false   "},{"title":"IsActive​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#IsActive","content":"&lt;/&gt; ScriptSignal:IsActive() → boolean Returns a boolean which determines if a ScriptSignal object is active. ScriptSignal:IsActive() -&gt; true ScriptSignal:Destroy() ScriptSignal:IsActive() -&gt; false   "},{"title":"Connect​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Connect","content":"&lt;/&gt; ScriptSignal:Connect(handler: (...: any) → ()) → ScriptConnection Connects a handler to a ScriptSignal object. ScriptSignal:Connect(function(text) print(text) end) ScriptSignal:Fire(&quot;Something&quot;) ScriptSignal:Fire(&quot;Something else&quot;) -- &quot;Something&quot; and then &quot;Something else&quot; are printed   "},{"title":"Once​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Once","content":"&lt;/&gt; ScriptSignal:Once(handler: (...: any) → ()) → ScriptConnection Connects a handler to a ScriptSignal object, but only allows that connection to run once. Any :Fire calls called afterwards won't trigger anything. ScriptSignal:Once(function() print(&quot;Connection fired&quot;) end) ScriptSignal:Fire() ScriptSignal:Fire() -- &quot;Connection fired&quot; is only fired once   "},{"title":"Wait​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; ScriptSignal:Wait() → ...any Yields the thread until a :Fire call occurs, returns what the signal was fired with. task.spawn(function() print( ScriptSignal:Wait() ) end) ScriptSignal:Fire(&quot;Arg&quot;, nil, 1, 2, 3, nil) -- &quot;Arg&quot;, nil, 1, 2, 3, nil are printed   "},{"title":"Fire​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Fire","content":"&lt;/&gt; ScriptSignal:Fire(...: any) → () Fires a ScriptSignal object with the arguments passed. ScriptSignal:Connect(function(text) print(text) end) ScriptSignal:Fire(&quot;Some Text...&quot;) -- &quot;Some Text...&quot; is printed twice   "},{"title":"DisconnectAll​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#DisconnectAll","content":"&lt;/&gt; ScriptSignal:DisconnectAll() → () Disconnects all connections from a ScriptSignal object without making it unusable. local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; true ScriptSignal:DisconnectAll() connection.Connected -&gt; false   "},{"title":"Destroy​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Destroy","content":"&lt;/&gt; ScriptSignal:Destroy() → () Destroys a ScriptSignal object, disconnecting all connections and making it unusable. ScriptSignal:Destroy() local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; false   "},{"title":"IsActive​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#IsActive","content":"&lt;/&gt; ScriptSignal:IsActive() → boolean Returns a boolean which determines if a ScriptSignal object is active. ScriptSignal:IsActive() -&gt; true ScriptSignal:Destroy() ScriptSignal:IsActive() -&gt; false   "},{"title":"Connect​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Connect","content":"&lt;/&gt; ScriptSignal:Connect(handler: (...: any) → ()) → ScriptConnection Connects a handler to a ScriptSignal object. ScriptSignal:Connect(function(text) print(text) end) ScriptSignal:Fire(&quot;Something&quot;) ScriptSignal:Fire(&quot;Something else&quot;) -- &quot;Something&quot; and then &quot;Something else&quot; are printed   "},{"title":"Once​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Once","content":"&lt;/&gt; ScriptSignal:Once(handler: (...: any) → ()) → ScriptConnection Connects a handler to a ScriptSignal object, but only allows that connection to run once. Any :Fire calls called afterwards won't trigger anything. ScriptSignal:Once(function() print(&quot;Connection fired&quot;) end) ScriptSignal:Fire() ScriptSignal:Fire() -- &quot;Connection fired&quot; is only fired once   "},{"title":"Wait​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; ScriptSignal:Wait() → ...any Yields the thread until a :Fire call occurs, returns what the signal was fired with. task.spawn(function() print( ScriptSignal:Wait() ) end) ScriptSignal:Fire(&quot;Arg&quot;, nil, 1, 2, 3, nil) -- &quot;Arg&quot;, nil, 1, 2, 3, nil are printed   "},{"title":"Fire​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Fire","content":"&lt;/&gt; ScriptSignal:Fire(...: any) → () Fires a ScriptSignal object with the arguments passed. ScriptSignal:Connect(function(text) print(text) end) ScriptSignal:Fire(&quot;Some Text...&quot;) -- &quot;Some Text...&quot; is printed twice   "},{"title":"DisconnectAll​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#DisconnectAll","content":"&lt;/&gt; ScriptSignal:DisconnectAll() → () Disconnects all connections from a ScriptSignal object without making it unusable. local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; true ScriptSignal:DisconnectAll() connection.Connected -&gt; false   "},{"title":"Destroy​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Destroy","content":"&lt;/&gt; ScriptSignal:Destroy() → () Destroys a ScriptSignal object, disconnecting all connections and making it unusable. ScriptSignal:Destroy() local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; false  "},{"title":"ServerNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerNetWire","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#types","content":" "},{"title":"ServerRemoteEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerRemoteEvent","content":"&lt;/&gt; type ServerRemoteEvent = RemoteSignal https://sleitnick.github.io/RbxUtil/api/RemoteSignal  "},{"title":"ServerRemoteProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerRemoteProperty","content":"&lt;/&gt; type ServerRemoteProperty = RemoteProperty https://sleitnick.github.io/RbxUtil/api/RemoteProperty  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...any )   "},{"title":"ServerRemoteEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerRemoteEvent","content":"&lt;/&gt; type ServerRemoteEvent = RemoteSignal https://sleitnick.github.io/RbxUtil/api/RemoteSignal  "},{"title":"ServerRemoteProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerRemoteProperty","content":"&lt;/&gt; type ServerRemoteProperty = RemoteProperty https://sleitnick.github.io/RbxUtil/api/RemoteProperty  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...any )  "},{"title":"Properties​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ServerNetWire.ClassName: &quot;ServerNetWire&quot;   "},{"title":"ClassName​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ServerNetWire.ClassName: &quot;ServerNetWire&quot;  "},{"title":"Functions​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#new","content":"constructor static &lt;/&gt; ServerNetWire.new(nameSpace: string | Service) → () Constructs a new ServerNetWire. If a ServerNetWire with the same nameSpace already exists, it will be returned instead.  "},{"title":"setupServiceNetworking​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#setupServiceNetworking","content":"constructor static &lt;/&gt; ServerNetWire.setupServiceNetworking(service: Service) → ServerNetWire Creates a ServerNetWire from a Roam Service. This method will read the service's Name and Client table to create the NetWire. The goal of this function is to recreate the simplicity of Knit's networking features without the systems being coupled together. In order to access the service on the client, use NetWire.Client(&quot;SERVICE_NAME&quot;). local ExampleService = Roam.createService { Name = &quot;ExampleService&quot; } ExampleService.Client = { TestEvent = NetWire.createEvent() } function ExampleService.Client:Greeting(plr: Player, msg: string) print(plr.Name, &quot;said&quot;, msg) end ---------------------------------------------------------------- function ExampleService:RoamInit() NetWire.Server.setupServiceNetworking(self) end function ExampleService:RoamStart() self.Client.TestEvent:FireAll(&quot;Hello from ExampleService!&quot;) -- send a message to all clients end Client Table Overwrite Calling this function will overwrite the service's Client table with the NetWire. You should not store anything aside from supported NetWire objects in the Client table. Where to call This function should be called within the init method of the service. This is to prevent netwires from being created outside of a running game.  "},{"title":"new​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#new","content":"constructor static &lt;/&gt; ServerNetWire.new(nameSpace: string | Service) → () Constructs a new ServerNetWire. If a ServerNetWire with the same nameSpace already exists, it will be returned instead.  "},{"title":"setupServiceNetworking​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#setupServiceNetworking","content":"constructor static &lt;/&gt; ServerNetWire.setupServiceNetworking(service: Service) → ServerNetWire Creates a ServerNetWire from a Roam Service. This method will read the service's Name and Client table to create the NetWire. The goal of this function is to recreate the simplicity of Knit's networking features without the systems being coupled together. In order to access the service on the client, use NetWire.Client(&quot;SERVICE_NAME&quot;). local ExampleService = Roam.createService { Name = &quot;ExampleService&quot; } ExampleService.Client = { TestEvent = NetWire.createEvent() } function ExampleService.Client:Greeting(plr: Player, msg: string) print(plr.Name, &quot;said&quot;, msg) end ---------------------------------------------------------------- function ExampleService:RoamInit() NetWire.Server.setupServiceNetworking(self) end function ExampleService:RoamStart() self.Client.TestEvent:FireAll(&quot;Hello from ExampleService!&quot;) -- send a message to all clients end Client Table Overwrite Calling this function will overwrite the service's Client table with the NetWire. You should not store anything aside from supported NetWire objects in the Client table. Where to call This function should be called within the init method of the service. This is to prevent netwires from being created outside of a running game.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#Destroy","content":"destructor &lt;/&gt; ServerNetWire:Destroy() → () Destroys the NetWire and removes it from the internal cache.  "},{"title":"RegisterEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterEvent","content":"&lt;/&gt; ServerNetWire:RegisterEvent( eventName: string, isUnreliable: boolean?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote event with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteSignal Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteSignal -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestEvent = NetWire.createEvent() myWire.TestEvent:Connect(function(plr: Player, someArg) print(someArg) end) myWire.TestEvent:FireAll(&quot;Hello from the server!&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire.TestEvent:Connect(function(someArg) print(someArg) end) myWire.TestEvent:Fire(&quot;Hello from the client!&quot;)   "},{"title":"RegisterProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterProperty","content":"&lt;/&gt; ServerNetWire:RegisterProperty( propertyName: string, initialValue: any?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote property with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteProperty Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteProperty -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestProperty = NetWire.createProperty(&quot;Hello&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) if myWire.TestProperty:IsReady() then -- Check if its ready first print( myWire.TestProperty:Get() ) -- &quot;Hello&quot; end   "},{"title":"RegisterMethod​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterMethod","content":"&lt;/&gt; ServerNetWire:RegisterMethod( functionName: string, callback: ( self: any, plr: Player , ...any ) → (...any), tbl: {}?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote function with the given name. This is not suggested to be used by end users; instead you should just append a function to a netwire object and it will properly wrap it for you. -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) function myWire:TestMethod(plr: Player, arg: number) return arg * 2 end --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire:TestMethod(5):andThen(function(result) print(result) -- 10 end)   "},{"title":"Destroy​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#Destroy","content":"destructor &lt;/&gt; ServerNetWire:Destroy() → () Destroys the NetWire and removes it from the internal cache.  "},{"title":"RegisterEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterEvent","content":"&lt;/&gt; ServerNetWire:RegisterEvent( eventName: string, isUnreliable: boolean?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote event with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteSignal Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteSignal -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestEvent = NetWire.createEvent() myWire.TestEvent:Connect(function(plr: Player, someArg) print(someArg) end) myWire.TestEvent:FireAll(&quot;Hello from the server!&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire.TestEvent:Connect(function(someArg) print(someArg) end) myWire.TestEvent:Fire(&quot;Hello from the client!&quot;)   "},{"title":"RegisterProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterProperty","content":"&lt;/&gt; ServerNetWire:RegisterProperty( propertyName: string, initialValue: any?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote property with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteProperty Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteProperty -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestProperty = NetWire.createProperty(&quot;Hello&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) if myWire.TestProperty:IsReady() then -- Check if its ready first print( myWire.TestProperty:Get() ) -- &quot;Hello&quot; end   "},{"title":"RegisterMethod​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterMethod","content":"&lt;/&gt; ServerNetWire:RegisterMethod( functionName: string, callback: ( self: any, plr: Player , ...any ) → (...any), tbl: {}?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote function with the given name. This is not suggested to be used by end users; instead you should just append a function to a netwire object and it will properly wrap it for you. -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) function myWire:TestMethod(plr: Player, arg: number) return arg * 2 end --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire:TestMethod(5):andThen(function(result) print(result) -- 10 end)  "},{"title":"TableState","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableState","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#new","content":"&lt;/&gt; TableState.new( manager: TableManager, Path: Path ) → TableState Creates a new TableState. This is used to observe and modify values in a TableManager easier. Equivalent to tblMngr:ToState(Path) local tbl = { Coins = 0; Inventory = { &quot;Sword&quot;; &quot;Shield&quot;; }; } local tblMngr = TableManager.new(tbl) local coinsState = TableState.new(tblMngr, &quot;Coins&quot;) print( coinsState == tblMngr:ToTableState(&quot;Coins&quot;) ) -- true coinsState:Set(100) -- equivalent to `tblMngr:SetValue(&quot;Coins&quot;, 100)` local inventoryState = TableState.new(tblMngr, &quot;Inventory&quot;) inventoryState:Insert(&quot;Potion&quot;) -- equivalent to `tblMngr:ArrayInsert(&quot;Inventory&quot;, &quot;Potion&quot;)` States with array values You should avoid setting states to be a particular index in array because if the array is shifted then the state can potentially be pointing to the wrong value.  "},{"title":"new​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#new","content":"&lt;/&gt; TableState.new( manager: TableManager, Path: Path ) → TableState Creates a new TableState. This is used to observe and modify values in a TableManager easier. Equivalent to tblMngr:ToState(Path) local tbl = { Coins = 0; Inventory = { &quot;Sword&quot;; &quot;Shield&quot;; }; } local tblMngr = TableManager.new(tbl) local coinsState = TableState.new(tblMngr, &quot;Coins&quot;) print( coinsState == tblMngr:ToTableState(&quot;Coins&quot;) ) -- true coinsState:Set(100) -- equivalent to `tblMngr:SetValue(&quot;Coins&quot;, 100)` local inventoryState = TableState.new(tblMngr, &quot;Inventory&quot;) inventoryState:Insert(&quot;Potion&quot;) -- equivalent to `tblMngr:ArrayInsert(&quot;Inventory&quot;, &quot;Potion&quot;)` States with array values You should avoid setting states to be a particular index in array because if the array is shifted then the state can potentially be pointing to the wrong value.  "},{"title":"Set​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Set","content":"&lt;/&gt; TableState:Set(...: any) → () Sets the value this state is associated with. :Set(999) -- Sets the value itself to 999 :Set(1, 999) -- Sets the value at index 1 to 999 (State must be an array)   "},{"title":"Get​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Get","content":"&lt;/&gt; TableState:Get(index: number?) → any Gets the value this state is associated with. Takes an optional argument to specify the index of the array to get. :Get() -- Gets the value itself :Get(1) -- Gets the value at index 1 of the state (State must be an array) (Equivalent to :Get()[1])   "},{"title":"Increment​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Increment","content":"&lt;/&gt; TableState:Increment(...: any) → any Increments the value this state is associated with. :Increment(999) -- Increments the value itself by 999 :Increment(1, 999) -- Increments the value at index 1 by 999 (State must be an array)   "},{"title":"Insert​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Insert","content":"&lt;/&gt; TableState:Insert(...: any) → () Inserts a value into the array this state is associated with. :Insert(999) -- Appends 999 onto the array :Insert(5, 999) -- Inserts 999 at index 5 of the array   "},{"title":"Remove​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Remove","content":"&lt;/&gt; TableState:Remove(index: number) → any-- The removed value. Removes the value at the given index from the array this state is associated with.  "},{"title":"RemoveFirstValue​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#RemoveFirstValue","content":"&lt;/&gt; TableState:RemoveFirstValue(valueToFind: any) → number-- The index of the removed value. Removes the first value that matches the given value from the array this state is associated with.  "},{"title":"Observe​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Observe","content":"&lt;/&gt; TableState:Observe(fn: (new: any) → ()) → () → () Observes changes to the value this state is associated with. Also fires immediately. See TableManager:Observe for more information.  "},{"title":"Set​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Set","content":"&lt;/&gt; TableState:Set(...: any) → () Sets the value this state is associated with. :Set(999) -- Sets the value itself to 999 :Set(1, 999) -- Sets the value at index 1 to 999 (State must be an array)   "},{"title":"Get​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Get","content":"&lt;/&gt; TableState:Get(index: number?) → any Gets the value this state is associated with. Takes an optional argument to specify the index of the array to get. :Get() -- Gets the value itself :Get(1) -- Gets the value at index 1 of the state (State must be an array) (Equivalent to :Get()[1])   "},{"title":"Increment​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Increment","content":"&lt;/&gt; TableState:Increment(...: any) → any Increments the value this state is associated with. :Increment(999) -- Increments the value itself by 999 :Increment(1, 999) -- Increments the value at index 1 by 999 (State must be an array)   "},{"title":"Insert​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Insert","content":"&lt;/&gt; TableState:Insert(...: any) → () Inserts a value into the array this state is associated with. :Insert(999) -- Appends 999 onto the array :Insert(5, 999) -- Inserts 999 at index 5 of the array   "},{"title":"Remove​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Remove","content":"&lt;/&gt; TableState:Remove(index: number) → any-- The removed value. Removes the value at the given index from the array this state is associated with.  "},{"title":"RemoveFirstValue​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#RemoveFirstValue","content":"&lt;/&gt; TableState:RemoveFirstValue(valueToFind: any) → number-- The index of the removed value. Removes the first value that matches the given value from the array this state is associated with.  "},{"title":"Observe​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Observe","content":"&lt;/&gt; TableState:Observe(fn: (new: any) → ()) → () → () Observes changes to the value this state is associated with. Also fires immediately. See TableManager:Observe for more information. "},{"title":"InstanceUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/InstanceUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#types","content":" "},{"title":"AnimPlayInfo​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#AnimPlayInfo","content":"&lt;/&gt; interface AnimPlayInfo { FadeInTime: number? Weight: number?, Speed: number?, FadeOutTime: number?, } A table of info for generating tweens for playing animations. "},{"title":"Functions​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#functions","content":" "},{"title":"promiseChild​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#promiseChild","content":"&lt;/&gt; InstanceUtil.promiseChild( parent: Instance ,-- The Instance to take the children of childName: string,-- The Instance name to look for timeout: number?-- The number of seconds to wait before timing out ) → Promise-- A Promise that resolves when the child is found or rejects if the timeout is reached. Promisifys the WaitForChild method on an Instance and adds in more robust error handling. InstanceUtil.promiseChild(workspace, &quot;ModelA&quot;, 10):andThen(function(model) print(&quot;Found ModelA:&quot;, model) end)   "},{"title":"findFirstChildFromPredicate​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#findFirstChildFromPredicate","content":"&lt;/&gt; InstanceUtil.findFirstChildFromPredicate( parent: Instance ,-- The Instance to search the children of. predicate: (child: Instance ) → boolean,-- The predicate which determines whether the child was found. recurse: boolean?-- Whether or not to search the parent's descendants instead of just its children. ) → Instance? -- The first child whose name matches the given string. Searches the parent for the first child which evaluates the given predicate to be true. local part = InstanceUtil.findFirstChildFromPredicate(workspace, function(child) return child:IsA(&quot;Part&quot;) end)   "},{"title":"findFirstChildThatMatches​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#findFirstChildThatMatches","content":"&lt;/&gt; InstanceUtil.findFirstChildThatMatches( parent: Instance ,-- The Instance to search the children of. matchString: string,-- The string to match the child's name to. Uses Lua's string.match function. Can take patterns. recurse: boolean?-- Whether or not to search the parent's descendants instead of just its children. ) → Instance -- The first child whose name matches the given string. Searches the parent for the first child whose name matches the given string. local model = InstanceUtil.findFirstChildThatMatches(workspace, &quot;^Part&quot;, true)   "},{"title":"findFirstChildOfAncestor​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#findFirstChildOfAncestor","content":"&lt;/&gt; InstanceUtil.findFirstChildOfAncestor( descendant: Instance ,-- The Instance to find the ancestor of. ancestor: Instance -- The Instance to find the descendant's ancestor of. ) → Instance -- The first child of the ancestor that is an ancestor of the descendant. Finds the first child of the given ancestor that is an ancestor of the given descendant. This is useful when you have a bunch of models in a folder and you have a reference to a part in one of these models. It allows you to quickly find which of those immediate children models the part is in. local character = InstanceUtil.findFirstChildOfAncestor(someDescendant, workspace.Characters) if character then print(&quot;Found character:&quot;, character) end   "},{"title":"getDescendantsWhichAre​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#getDescendantsWhichAre","content":"&lt;/&gt; InstanceUtil.getDescendantsWhichAre( Parent: Instance ,-- Instance to perform the search on. ClassName: string | {string}-- The class name or names the descendant must match or inherit. ) → {Instance? }-- Table with valid descendants of passed ClassName. Iterates through Parent descendants and returns a table which only contains descendants of passed ClassName. local partsAndTextures = InstanceUtil.getDescendantsWhichAre(workspace, {&quot;Part&quot;, &quot;Texture&quot;})   "},{"title":"waitForChildFromPredicate​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#waitForChildFromPredicate","content":"&lt;/&gt; InstanceUtil.waitForChildFromPredicate( parent: Instance ,-- The Instance to search the children of. predicate: (child: Instance ) → boolean,-- The predicate which determines whether the child was found. timeout: number?,-- The maximum amount of time to wait for the child to be added. Defaults to 10 seconds. recurse: boolean?-- Whether or not to search the parent's descendants instead of just its children. ) → Promise&lt;Instance &gt;-- A Promise resolving with the first child who satisfies the predicate. Waits for the first child which evaluates the given predicate to be true. InstanceUtil.waitForChildFromPredicate(workspace, function(child) return child:IsA(&quot;Part&quot;) and child.Name == &quot;MyPart&quot; end):andThen(function(part) print(&quot;Found part:&quot;, part) end)   "},{"title":"waitForChildWhichIsA​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#waitForChildWhichIsA","content":"&lt;/&gt; InstanceUtil.waitForChildWhichIsA( ancestor: Instance ,-- The Instance to search the children of. className: string,-- The class of the child to wait for. timeout?: number?-- The maximum amount of time to wait for the child to be added. Defaults to 10 seconds. ) → Promise&lt;Instance &gt;-- A promise that resolves with the child when it is added. Waits for a child of the given class in the given ancestor to be added. InstanceUtil.waitForChildWhichIsA(workspace, &quot;Part&quot;):andThen(function(part) print(&quot;Found part:&quot;, part) end)   "},{"title":"waitForChildThatMatches​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#waitForChildThatMatches","content":"&lt;/&gt; InstanceUtil.waitForChildThatMatches( ancestor: Instance ,-- The Instance to search the children of. matchString: string,-- The string to match the child's name to. Uses Lua's string.match function. Can take patterns. timeout: number?,-- The maximum amount of time to wait for the child to be added. Defaults ot 10 seconds. recurse: boolean?-- Whether or not to search the parent's descendants instead of just its children. ) → Promise&lt;Instance &gt;-- The first child whose name matches the given string. Waits for the first child whose name matches the given string. InstanceUtil.waitForChildThatMatches(workspace, &quot;^Part&quot;):andThen(function(part) print(&quot;Found part:&quot;, part) end)   "},{"title":"ensureInstance​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#ensureInstance","content":"&lt;/&gt; InstanceUtil.ensureInstance( parent: Instance ,-- The Instance to check. template: Instance ,-- The Instance to use as a template. name: string?-- The name of the child to find. Uses the template's name if not given. ) → Instance -- The existing or new child. Ensures that the given parent has a child with the given name. If not then it uses the given template to create a new child. local template = Instance.new(&quot;Part&quot;) template.BrickColor = BrickColor.new(&quot;Bright red&quot;) local myPart = InstanceUtil.ensureInstance(workspace, template, &quot;MyPart&quot;)   "},{"title":"destroyFirstChild​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#destroyFirstChild","content":"&lt;/&gt; InstanceUtil.destroyFirstChild( parent: Instance ,-- The Instance to search the children of. descendantName: string,-- The name of the descendant to destroy. recurse: boolean?-- Whether or not to search the parent's descendants instead of just its children. ) → () Attempts to destroy a named descendant of the given parent. InstanceUtil.destroyFirstChild(workspace, &quot;MyPart&quot;)   "},{"title":"safeDestroy​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#safeDestroy","content":"&lt;/&gt; InstanceUtil.safeDestroy( instance: Instance -- The Instance to destroy. ) → ( boolean,-- Whether or not the instance was destroyed. False is the instance was already destroyed. string-- The error message if the instance could not be destroyed. ) Attempts to destroy the given instance. local success, err = InstanceUtil.safeDestroy(myPart)   "},{"title":"weld​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#weld","content":"&lt;/&gt; InstanceUtil.weld( part1: BasePart ,-- The first part to weld. part2: BasePart -- The second part to weld. ) → WeldConstraint -- The WeldConstraint created. Creates a WeldConstraint between two parts. local weld = InstanceUtil.weld(part1, part2)   "},{"title":"weldAssembly​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#weldAssembly","content":"&lt;/&gt; InstanceUtil.weldAssembly( model: Model ,-- The Model to weld the parts of. primaryPart: BasePart? -- The Part to weld the parts to. Defaults to Model.PrimaryPart ) → {WeldConstraint }-- The WeldConstraints created. Weld each individual part to the Model Model .PrimaryPart; local welds = InstanceUtil.weldAssembly(model, model:FindFirstChild(&quot;Core&quot;))   "},{"title":"getAttachmentsAlignedCFrame​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#getAttachmentsAlignedCFrame","content":"&lt;/&gt; InstanceUtil.getAttachmentsAlignedCFrame( partAttachment: Attachment , targetAttachment: Attachment ) → CFrame  Gets the CFrame of the given partAttachment's parent needed to align with the targetAttachment. This is useful for aligning two parts such that their attachments are equivalent in CFrame. info This is effectively the same as using a RigidConstraint with the attachments if the parent part is unanchored. local partAttachment = part:FindFirstChild(&quot;Attachment&quot;) local targetAttachment = target:FindFirstChild(&quot;Attachment&quot;) local cframe = InstanceUtil.getAttachmentsAlignedCFrame(partAttachment, targetAttachment) part.CFrame = cframe   "},{"title":"getModelFitDistance​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#getModelFitDistance","content":"&lt;/&gt; InstanceUtil.getModelFitDistance( model: Model | BasePart ,-- The Model to get the distance for. vpf: ViewportFrame ,-- The ViewportFrame to fit the model into. camera: Camera? -- The Camera to use. Defaults to the ViewportFrame's CurrentCamera. ) → number-- The distance from the model the camera should be. Gets the distance from the camera to the model that would fit the model in the viewport frame. This method is not finished and may not return perfect values. local distance = InstanceUtil.getModelFitDistance(model, viewportFrame)   "},{"title":"cloneChildren​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#cloneChildren","content":"&lt;/&gt; InstanceUtil.cloneChildren( parent: Instance ,-- The Instance to take the children of newParent: Instance ,-- The Instance to parent the cloned children to predicate: ((object: Instance ) → boolean)?-- A function to filter which children it should clone ) → {Instance }-- The cloned children Takes an Instance and Clones all of its children into a new Instance. local modelA = workspace.ModelA local modelB = workspace.ModelB local newChildren = InstanceUtil.cloneChildren(modelA, modelB, function(child) return child:IsA(&quot;Part&quot;) end)   "},{"title":"isClass​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#isClass","content":"&lt;/&gt; InstanceUtil.isClass( instance: Instance ,-- The Instance to check the type of. classNames: string | {string}-- The ClassName or ClassNames to check against. ) → boolean-- Whether or not the instance is any of the given classes. Checks to see if the given instance is any of the given classes. local part = Instance.new(&quot;Part&quot;) local potentialClasses = {&quot;BasePart&quot;, &quot;Decal&quot;, &quot;Texture&quot;} local isOneOfTheClasses = InstanceUtil.isClass(part, potentialClasses) -- true   "},{"title":"fetchModule​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#fetchModule","content":"&lt;/&gt; InstanceUtil.fetchModule( parent: Instance ,-- The Instance that has it and its descendants checked against. moduleName: string,-- The name of the ModuleScript to search for. defaultValue: any?-- The default value to return if the ModuleScript could not be found. ) → any Searches for a ModuleScript in the given parent with the given name. If a descendant is found with the given name and is an ObjectValue, this value will be assumed to be the ModuleScript. If the ModuleScript could not be found it will return the defaultValue if it is provided. Otherwise it will error. local module = InstanceUtil.fetchModule(workspace, &quot;MyModule&quot;)   "},{"title":"hasProperty​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#hasProperty","content":"&lt;/&gt; InstanceUtil.hasProperty( object: Instance ,-- The Instance to check the property of. property: string-- The property to check for. ) → ( boolean,-- Whether or not the instance has the property. any-- The value of the property if it exists. ) Checks to see if a given instance has a property. If it does, it will return true and the value of the property. If it does not, it will return false and a message. local part = Instance.new(&quot;Part&quot;) local subPart = Instance.new(&quot;Part&quot;) subPart.Name = &quot;Size&quot; subPart.Parent = part local hasProperty, value = InstanceUtil.hasProperty(part, &quot;Size&quot;) if hasProperty then print(&quot;Part has Size property:&quot;, value) end   "},{"title":"playTween​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#playTween","content":"&lt;/&gt; InstanceUtil.playTween( obj: Tween | Instance ,-- The Tween to play or the instance to play on. info: TweenInfo? , goals: {[string]: any}? ) → Promise-- A Promise that resolves when the tween has finished. Plays a tween as a promise. If a tween is not given then standard tween parameters are used to create a new tween. local part = Instance.new(&quot;Part&quot;) local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut) local goals = { Size = Vector3.new(10, 10, 10), Position = Vector3.new(0, 10, 0), } InstanceUtil.playTween(part, tweenInfo, goals):andThen(function() print(&quot;Tween has finished playing.&quot;) end)   "},{"title":"playTracksAsync​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#playTracksAsync","content":"&lt;/&gt; InstanceUtil.playTracksAsync( tracks: AnimationTrack | {AnimationTrack },-- The AnimationTrack or array of AnimationTracks to play. animInfo: AnimPlayInfo?,-- The AnimPlayInfo to use when playing the tracks. keyframeMarkerToResolveAt: string?-- The Keyframe marker to resolve at instead of the animations ending ) → Promise-- A Promise that resolves when all tracks have stopped playing. Takes a track or array of AnimationTracks and plays them all asynchronously. local track = Instance.new(&quot;Animation&quot;) local animInfo = { FadeInTime = 0.5, Weight = 1, Speed = 1, FadeOutTime = 0.5, } InstanceUtil.playTracksAsync(track, animInfo):andThen(function() print(&quot;Animation has finished playing.&quot;) end)   "},{"title":"emitParticles​","type":1,"pageTitle":"InstanceUtil","url":"/ModulesOnRails/api/InstanceUtil#emitParticles","content":"&lt;/&gt; InstanceUtil.emitParticles( parent: Instance ,-- The Instance to search Particles for emitCount: number?-- The number of particles to emit ) → () Takes an Instance and Emits it and any descendants it has. Optional Attributes that any of the descendant ParticleEmitters could have: EmitDelay: number? -- The delay before emitting EmitCount: number? -- The number of particles to emit at the start EmitDuration: number? -- The duration to emit particles for InstanceUtil.emitParticles(workspace.Effect)  "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RemoteProperty","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the top-level value of all clients to the same value. Override Per-Player Data This will override any per-player data that was set usingSetFor or SetFilter. To avoid overriding this data, SetTop can be used instead. -- Examples remoteProperty:Set(10) remoteProperty:Set({SomeData = 32}) remoteProperty:Set(&quot;HelloWorld&quot;)   "},{"title":"SetTop​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetTop","content":"&lt;/&gt; RemoteProperty:SetTop(value: any) → () Set the top-level value of the property, but does not override any per-player data (e.g. set with SetFor or SetFilter). Any player without custom-set data will receive this new data. This is useful if certain players have specific values that should not be changed, but all other players should receive the same new value. -- Using just 'Set' overrides per-player data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Using 'SetTop' does not override: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot;   "},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetFilter","content":"&lt;/&gt; RemoteProperty:SetFilter( predicate: ( Player , any ) → boolean, value: any-- Value to set for the clients (and to the predicate) ) → () Sets the value for specific clients that pass the predicate function test. This can be used to finely set the values based on more control logic (e.g. setting certain values per team). -- Set the value of &quot;NewValue&quot; to players with a name longer than 10 characters: remoteProperty:SetFilter(function(player) return #player.Name &gt; 10 end, &quot;NewValue&quot;)   "},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetFor","content":"&lt;/&gt; RemoteProperty:SetFor( player: Player , value: any ) → () Set the value of the property for a specific player. This will override the value used by Set (and the initial value set for the property when created). This value can be nil. In order to reset the value for a given player and let the player use the top-level value held by this property, either use Set to set all players' data, or use ClearFor. remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;)   "},{"title":"SetForList​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetForList","content":"&lt;/&gt; RemoteProperty:SetForList( players: {Player }, value: any ) → () Set the value of the property for specific players. This just loops through the players given and calls SetFor. local players = {player1, player2, player3} remoteProperty:SetForList(players, &quot;CustomData&quot;)   "},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearFor","content":"&lt;/&gt; RemoteProperty:ClearFor(player: Player ) → () Clears the custom property value for the given player. When this occurs, the player will reset to use the top-level value held by this property (either the value set when the property was created, or the last value set by Set). remoteProperty:Set(&quot;DATA&quot;) remoteProperty:SetFor(somePlayer, &quot;CUSTOM_DATA&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CUSTOM_DATA&quot; -- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL: remoteProperty:SetFor(somePlayer, nil) print(remoteProperty:GetFor(somePlayer)) --&gt; nil -- CLEAR: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;DATA&quot;   "},{"title":"ClearForList​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearForList","content":"&lt;/&gt; RemoteProperty:ClearForList(players: {Player }) → () Clears the custom value for the given players. This just loops through the list of players and calls the ClearFor method for each player.  "},{"title":"ClearFilter​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearFilter","content":"&lt;/&gt; RemoteProperty:ClearFilter(predicate: (Player ) → boolean) → () The same as SetFiler, except clears the custom value for any player that passes the predicate.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → any Returns the top-level value held by the property. This will either be the initial value set, or the last value set with Set(). remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:Get()) --&gt; &quot;Data&quot;   "},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#GetFor","content":"&lt;/&gt; RemoteProperty:GetFor(player: Player ) → any Returns the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). -- Set top level data: remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Set custom data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Set top level again, overriding custom data: remoteProperty:Set(&quot;NewData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;NewData&quot; -- Set custom data again, and set top level without overriding: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Clear custom data to use top level data: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot;   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the RemoteProperty object.  "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the top-level value of all clients to the same value. Override Per-Player Data This will override any per-player data that was set usingSetFor or SetFilter. To avoid overriding this data, SetTop can be used instead. -- Examples remoteProperty:Set(10) remoteProperty:Set({SomeData = 32}) remoteProperty:Set(&quot;HelloWorld&quot;)   "},{"title":"SetTop​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetTop","content":"&lt;/&gt; RemoteProperty:SetTop(value: any) → () Set the top-level value of the property, but does not override any per-player data (e.g. set with SetFor or SetFilter). Any player without custom-set data will receive this new data. This is useful if certain players have specific values that should not be changed, but all other players should receive the same new value. -- Using just 'Set' overrides per-player data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Using 'SetTop' does not override: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot;   "},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetFilter","content":"&lt;/&gt; RemoteProperty:SetFilter( predicate: ( Player , any ) → boolean, value: any-- Value to set for the clients (and to the predicate) ) → () Sets the value for specific clients that pass the predicate function test. This can be used to finely set the values based on more control logic (e.g. setting certain values per team). -- Set the value of &quot;NewValue&quot; to players with a name longer than 10 characters: remoteProperty:SetFilter(function(player) return #player.Name &gt; 10 end, &quot;NewValue&quot;)   "},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetFor","content":"&lt;/&gt; RemoteProperty:SetFor( player: Player , value: any ) → () Set the value of the property for a specific player. This will override the value used by Set (and the initial value set for the property when created). This value can be nil. In order to reset the value for a given player and let the player use the top-level value held by this property, either use Set to set all players' data, or use ClearFor. remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;)   "},{"title":"SetForList​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetForList","content":"&lt;/&gt; RemoteProperty:SetForList( players: {Player }, value: any ) → () Set the value of the property for specific players. This just loops through the players given and calls SetFor. local players = {player1, player2, player3} remoteProperty:SetForList(players, &quot;CustomData&quot;)   "},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearFor","content":"&lt;/&gt; RemoteProperty:ClearFor(player: Player ) → () Clears the custom property value for the given player. When this occurs, the player will reset to use the top-level value held by this property (either the value set when the property was created, or the last value set by Set). remoteProperty:Set(&quot;DATA&quot;) remoteProperty:SetFor(somePlayer, &quot;CUSTOM_DATA&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CUSTOM_DATA&quot; -- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL: remoteProperty:SetFor(somePlayer, nil) print(remoteProperty:GetFor(somePlayer)) --&gt; nil -- CLEAR: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;DATA&quot;   "},{"title":"ClearForList​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearForList","content":"&lt;/&gt; RemoteProperty:ClearForList(players: {Player }) → () Clears the custom value for the given players. This just loops through the list of players and calls the ClearFor method for each player.  "},{"title":"ClearFilter​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearFilter","content":"&lt;/&gt; RemoteProperty:ClearFilter(predicate: (Player ) → boolean) → () The same as SetFiler, except clears the custom value for any player that passes the predicate.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → any Returns the top-level value held by the property. This will either be the initial value set, or the last value set with Set(). remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:Get()) --&gt; &quot;Data&quot;   "},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#GetFor","content":"&lt;/&gt; RemoteProperty:GetFor(player: Player ) → any Returns the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). -- Set top level data: remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Set custom data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Set top level again, overriding custom data: remoteProperty:Set(&quot;NewData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;NewData&quot; -- Set custom data again, and set top level without overriding: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Clear custom data to use top level data: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot;   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the RemoteProperty object. "},{"title":"BaseObject","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseObject","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#types","content":" "},{"title":"BaseObject​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BaseObject","content":"&lt;/&gt; type BaseObject = BaseObject   "},{"title":"BaseObject​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BaseObject","content":"&lt;/&gt; type BaseObject = BaseObject   "},{"title":"BaseObject​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BaseObject","content":"&lt;/&gt; type BaseObject = BaseObject  "},{"title":"Properties​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; BaseObject.ClassName: string   "},{"title":"ClassName​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; BaseObject.ClassName: string   "},{"title":"ClassName​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; BaseObject.ClassName: string  "},{"title":"Functions​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#functions","content":" "},{"title":"getObjectFromId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#getObjectFromId","content":"static &lt;/&gt; BaseObject.getObjectFromId(id: number) → BaseObject? Fetches the object with the given ID if it exists. local obj = BaseObject.new() local id = obj:GetId() print(BaseObject.getObjectFromId(id) == obj) -- true   "},{"title":"isDestroyed​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#isDestroyed","content":"static &lt;/&gt; BaseObject.isDestroyed(self: BaseObject) → boolean Checks whether or not the object is destroyed. local obj = BaseObject.new() print(BaseObject.isDestroyed(obj)) -- false obj:Destroy() print(BaseObject.isDestroyed(obj)) -- true   "},{"title":"new​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#new","content":"static &lt;/&gt; BaseObject.new( tbl: {[any]: any}?-- Table to construct the BaseObject with ) → BaseObject Constructs a new BaseObject local obj = BaseObject.new({ X = 1, Y = 2, }) obj.Z = 3 print(obj.X, obj.Y, obj.Z) -- 1, 2, 3 local SuperClass = BaseObject local MyClass = setmetatable({}, SuperClass) MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() local self = setmetatable(SuperClass.new(), MyClass) -- Custom logic here return self end function MyClass:Destroy() -- Overwrite the BaseObject Destroy method SuperClass.Destroy(self) -- If you overwrite the BaseObject Destroy method you need to have this line to call the original. end function MyClass:Print() print(&quot;Hello, World!&quot;) end return MyClass   "},{"title":"getObjectFromId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#getObjectFromId","content":"static &lt;/&gt; BaseObject.getObjectFromId(id: number) → BaseObject? Fetches the object with the given ID if it exists. local obj = BaseObject.new() local id = obj:GetId() print(BaseObject.getObjectFromId(id) == obj) -- true   "},{"title":"isDestroyed​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#isDestroyed","content":"static &lt;/&gt; BaseObject.isDestroyed(self: BaseObject) → boolean Checks whether or not the object is destroyed. local obj = BaseObject.new() print(BaseObject.isDestroyed(obj)) -- false obj:Destroy() print(BaseObject.isDestroyed(obj)) -- true   "},{"title":"new​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#new","content":"static &lt;/&gt; BaseObject.new( tbl: {[any]: any}?-- Table to construct the BaseObject with ) → BaseObject Constructs a new BaseObject local obj = BaseObject.new({ X = 1, Y = 2, }) obj.Z = 3 print(obj.X, obj.Y, obj.Z) -- 1, 2, 3 local SuperClass = BaseObject local MyClass = setmetatable({}, SuperClass) MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() local self = setmetatable(SuperClass.new(), MyClass) -- Custom logic here return self end function MyClass:Destroy() -- Overwrite the BaseObject Destroy method SuperClass.Destroy(self) -- If you overwrite the BaseObject Destroy method you need to have this line to call the original. end function MyClass:Print() print(&quot;Hello, World!&quot;) end return MyClass   "},{"title":"getObjectFromId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#getObjectFromId","content":"static &lt;/&gt; BaseObject.getObjectFromId(id: number) → BaseObject? Fetches the object with the given ID if it exists. local obj = BaseObject.new() local id = obj:GetId() print(BaseObject.getObjectFromId(id) == obj) -- true   "},{"title":"isDestroyed​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#isDestroyed","content":"static &lt;/&gt; BaseObject.isDestroyed(self: BaseObject) → boolean Checks whether or not the object is destroyed. local obj = BaseObject.new() print(BaseObject.isDestroyed(obj)) -- false obj:Destroy() print(BaseObject.isDestroyed(obj)) -- true   "},{"title":"new​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#new","content":"static &lt;/&gt; BaseObject.new( tbl: {[any]: any}?-- Table to construct the BaseObject with ) → BaseObject Constructs a new BaseObject local obj = BaseObject.new({ X = 1, Y = 2, }) obj.Z = 3 print(obj.X, obj.Y, obj.Z) -- 1, 2, 3 local SuperClass = BaseObject local MyClass = setmetatable({}, SuperClass) MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() local self = setmetatable(SuperClass.new(), MyClass) -- Custom logic here return self end function MyClass:Destroy() -- Overwrite the BaseObject Destroy method SuperClass.Destroy(self) -- If you overwrite the BaseObject Destroy method you need to have this line to call the original. end function MyClass:Print() print(&quot;Hello, World!&quot;) end return MyClass   "},{"title":"Destroy​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#Destroy","content":"&lt;/&gt; BaseObject:Destroy() → () Marks the Object as Destroyed, fires the Destroyed Signal, cleans up the BaseObject, and sets the metatable to nil/a special locked MT. Overriding If you override this method, you need to make sure you callSuperClass.Destroy(self) to call the superclass methods. function MyCustomClass:Destroy() SuperClass.Destroy(self) -- calls the superclass method to clean up events, tasks, etc.. end   "},{"title":"GetId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetId","content":"&lt;/&gt; BaseObject:GetId() → number Returns the ID of the BaseObject Can be used to fetch the object with BaseObject.getObjectFromId(id)  "},{"title":"IsA​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#IsA","content":"&lt;/&gt; BaseObject:IsA(classOrClassName: {[any]: any} | string) → boolean Returns true if the given object is of a given class. Takes a class name or class object.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetTask","content":"&lt;/&gt; BaseObject:GetTask(taskId: any) → Task? Fetches the task with the given ID if it exists. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:AddTask(part, nil, &quot;Test&quot;) print(obj:GetTask(&quot;Test&quot;) == part) -- true   "},{"title":"AddTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddTask","content":"&lt;/&gt; BaseObject:AddTask( task: Task, taskCleanupMethod: (string | true | nil)?,-- (if none is given it will try to infer; Passing true tells it to call it as a function) taskId: any? ) → Task-- The task that was given Adds a task to the janitor. If a taskId is provided, it will be used as the key for the task in the janitor and can then be fetched later with :GetTask(). If an ID is provided and there already exists a task with that ID, it will clean up the existing task and then replace the index with the new one. It will return the task that was added/given. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end) obj:Destroy() -- Prints &quot;Hello, World!&quot;   "},{"title":"AddPromise​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddPromise","content":"&lt;/&gt; BaseObject:AddPromise(prom: Promise) → Promise Adds a promise to the janitor. Similar to :AddTask(). Returns the same Promise that was given to it. local prom = Promise.delay(math.random(10)) local obj = BaseObject.new() obj:AddPromise(prom) task.wait(math.random(10)) obj:Destroy() -- Cancels the promise if it hasn't resolved yet   "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTask","content":"&lt;/&gt; BaseObject:RemoveTask( taskId: any, dontClean: boolean? ) → () Removes a task from the janitor. Cleans the task as if :DoCleaning was called. If dontClean is true, it will not clean up the task, it will just remove it from the janitor. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTask(&quot;Test&quot;) -- Prints &quot;Hello, World!&quot;   "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTaskNoClean","content":"&lt;/&gt; BaseObject:RemoveTaskNoClean(taskId: any) → () Removes a task from the janitor without cleaning it. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTaskNoClean(&quot;Test&quot;) -- Does NOT print &quot;Hello, World!&quot;   "},{"title":"FireSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#FireSignal","content":"&lt;/&gt; BaseObject:FireSignal( signalName: string,-- The name of the signal to fire ...: any-- Arguments to pass to the signal ) → () Fires the signal with the given name, if it exists. Equivalent to calling :GetSignal(signalName):Fire(...) except this does not require the signal to exist first. local obj = BaseObject.new() local SignalName = &quot;Test&quot; obj:RegisterSignal(SignalName) obj:GetSignal(SignalName):Connect(print) obj:FireSignal(SignalName, &quot;Hello, World!&quot;) -- Fires the signal with the argument &quot;Hello, World!&quot;   "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RegisterSignal","content":"&lt;/&gt; BaseObject:RegisterSignal( signalName: string-- Name of signal to register ) → () Marks a signal with the given name as registered. Does not actually build a new signal, it sets the index to a SignalMarker to identify it as registered so that it can be fetched later.  "},{"title":"HasSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#HasSignal","content":"&lt;/&gt; BaseObject:HasSignal(signalName: string) → boolean Checks whether or not a signal with the given name is registered. local obj = BaseObject.new() local SignalName = &quot;Test&quot; print(obj:HasSignal(SignalName)) -- false obj:RegisterSignal(SignalName) print(obj:HasSignal(SignalName)) -- true   "},{"title":"GetSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetSignal","content":"&lt;/&gt; BaseObject:GetSignal(signalName: string) → Signal Fetches a signal with the given name. Creates the Signal JIT.  "},{"title":"ConnectSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ConnectSignal","content":"&lt;/&gt; BaseObject:ConnectSignal( signalName: string, func: (...any) → () ) → () Connects a function to a signal with the given name. Creates the signal JIT. Shorthand for :GetSignal(signalName):Connect(func).  "},{"title":"GetDestroyedSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetDestroyedSignal","content":"&lt;/&gt; BaseObject:GetDestroyedSignal() → Signal Returns a signal that fires when the object is destroyed. Creates the signal JIT. Kept for backwards compatibility. local obj = BaseObject.new() obj:GetDestroyedSignal():Connect(function() print(&quot;Object Destroyed!&quot;) end) obj:Destroy() -- Prints &quot;Object Destroyed!&quot;   "},{"title":"BindToInstance​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BindToInstance","content":"&lt;/&gt; BaseObject:BindToInstance( obj: Instance , destroyOnNilParent: boolean?-- Whether or not to destroy the object when the parent is nil'd ) → function-- Disconnects the binding Binds the object to the given instance. When the object is destroyed, it will destroy the instance. When the instance is destroyed, it will destroy the object. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:BindToInstance(part) do -- setup prints on destroy obj:AddTask(function() print(&quot;Object Destroyed!&quot;) end) part.Destroying:Connect(function() print(&quot;Part Destroyed!&quot;) end) end local X = if math.random(1,2) == 1 then obj or part X:Destroy() -- Prints &quot;Object Destroyed!&quot; and &quot;Part Destroyed!&quot; (Destroying one will destroy the other)   "},{"title":"Destroy​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#Destroy","content":"&lt;/&gt; BaseObject:Destroy() → () Marks the Object as Destroyed, fires the Destroyed Signal, cleans up the BaseObject, and sets the metatable to nil/a special locked MT. Overriding If you override this method, you need to make sure you callSuperClass.Destroy(self) to call the superclass methods. function MyCustomClass:Destroy() SuperClass.Destroy(self) -- calls the superclass method to clean up events, tasks, etc.. end   "},{"title":"GetId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetId","content":"&lt;/&gt; BaseObject:GetId() → number Returns the ID of the BaseObject Can be used to fetch the object with BaseObject.getObjectFromId(id)  "},{"title":"IsA​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#IsA","content":"&lt;/&gt; BaseObject:IsA(classOrClassName: {[any]: any} | string) → boolean Returns true if the given object is of a given class. Takes a class name or class object.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetTask","content":"&lt;/&gt; BaseObject:GetTask(taskId: any) → Task? Fetches the task with the given ID if it exists. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:AddTask(part, nil, &quot;Test&quot;) print(obj:GetTask(&quot;Test&quot;) == part) -- true   "},{"title":"AddTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddTask","content":"&lt;/&gt; BaseObject:AddTask( task: Task, taskCleanupMethod: (string | true | nil)?,-- (if none is given it will try to infer; Passing true tells it to call it as a function) taskId: any? ) → Task-- The task that was given Adds a task to the janitor. If a taskId is provided, it will be used as the key for the task in the janitor and can then be fetched later with :GetTask(). If an ID is provided and there already exists a task with that ID, it will clean up the existing task and then replace the index with the new one. It will return the task that was added/given. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end) obj:Destroy() -- Prints &quot;Hello, World!&quot;   "},{"title":"AddPromise​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddPromise","content":"&lt;/&gt; BaseObject:AddPromise(prom: Promise) → Promise Adds a promise to the janitor. Similar to :AddTask(). Returns the same Promise that was given to it. local prom = Promise.delay(math.random(10)) local obj = BaseObject.new() obj:AddPromise(prom) task.wait(math.random(10)) obj:Destroy() -- Cancels the promise if it hasn't resolved yet   "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTask","content":"&lt;/&gt; BaseObject:RemoveTask( taskId: any, dontClean: boolean? ) → () Removes a task from the janitor. Cleans the task as if :DoCleaning was called. If dontClean is true, it will not clean up the task, it will just remove it from the janitor. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTask(&quot;Test&quot;) -- Prints &quot;Hello, World!&quot;   "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTaskNoClean","content":"&lt;/&gt; BaseObject:RemoveTaskNoClean(taskId: any) → () Removes a task from the janitor without cleaning it. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTaskNoClean(&quot;Test&quot;) -- Does NOT print &quot;Hello, World!&quot;   "},{"title":"FireSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#FireSignal","content":"&lt;/&gt; BaseObject:FireSignal( signalName: string,-- The name of the signal to fire ...: any-- Arguments to pass to the signal ) → () Fires the signal with the given name, if it exists. Equivalent to calling :GetSignal(signalName):Fire(...) except this does not require the signal to exist first. local obj = BaseObject.new() local SignalName = &quot;Test&quot; obj:RegisterSignal(SignalName) obj:GetSignal(SignalName):Connect(print) obj:FireSignal(SignalName, &quot;Hello, World!&quot;) -- Fires the signal with the argument &quot;Hello, World!&quot;   "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RegisterSignal","content":"&lt;/&gt; BaseObject:RegisterSignal( signalName: string-- Name of signal to register ) → () Marks a signal with the given name as registered. Does not actually build a new signal, it sets the index to a SignalMarker to identify it as registered so that it can be fetched later.  "},{"title":"HasSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#HasSignal","content":"&lt;/&gt; BaseObject:HasSignal(signalName: string) → boolean Checks whether or not a signal with the given name is registered. local obj = BaseObject.new() local SignalName = &quot;Test&quot; print(obj:HasSignal(SignalName)) -- false obj:RegisterSignal(SignalName) print(obj:HasSignal(SignalName)) -- true   "},{"title":"GetSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetSignal","content":"&lt;/&gt; BaseObject:GetSignal(signalName: string) → Signal Fetches a signal with the given name. Creates the Signal JIT.  "},{"title":"ConnectSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ConnectSignal","content":"&lt;/&gt; BaseObject:ConnectSignal( signalName: string, func: (...any) → () ) → () Connects a function to a signal with the given name. Creates the signal JIT. Shorthand for :GetSignal(signalName):Connect(func).  "},{"title":"GetDestroyedSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetDestroyedSignal","content":"&lt;/&gt; BaseObject:GetDestroyedSignal() → Signal Returns a signal that fires when the object is destroyed. Creates the signal JIT. Kept for backwards compatibility. local obj = BaseObject.new() obj:GetDestroyedSignal():Connect(function() print(&quot;Object Destroyed!&quot;) end) obj:Destroy() -- Prints &quot;Object Destroyed!&quot;   "},{"title":"BindToInstance​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BindToInstance","content":"&lt;/&gt; BaseObject:BindToInstance( obj: Instance , destroyOnNilParent: boolean?-- Whether or not to destroy the object when the parent is nil'd ) → function-- Disconnects the binding Binds the object to the given instance. When the object is destroyed, it will destroy the instance. When the instance is destroyed, it will destroy the object. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:BindToInstance(part) do -- setup prints on destroy obj:AddTask(function() print(&quot;Object Destroyed!&quot;) end) part.Destroying:Connect(function() print(&quot;Part Destroyed!&quot;) end) end local X = if math.random(1,2) == 1 then obj or part X:Destroy() -- Prints &quot;Object Destroyed!&quot; and &quot;Part Destroyed!&quot; (Destroying one will destroy the other)   "},{"title":"Destroy​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#Destroy","content":"&lt;/&gt; BaseObject:Destroy() → () Marks the Object as Destroyed, fires the Destroyed Signal, cleans up the BaseObject, and sets the metatable to nil/a special locked MT. Overriding If you override this method, you need to make sure you callSuperClass.Destroy(self) to call the superclass methods. function MyCustomClass:Destroy() SuperClass.Destroy(self) -- calls the superclass method to clean up events, tasks, etc.. end   "},{"title":"GetId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetId","content":"&lt;/&gt; BaseObject:GetId() → number Returns the ID of the BaseObject Can be used to fetch the object with BaseObject.getObjectFromId(id)  "},{"title":"IsA​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#IsA","content":"&lt;/&gt; BaseObject:IsA(classOrClassName: {[any]: any} | string) → boolean Returns true if the given object is of a given class. Takes a class name or class object.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetTask","content":"&lt;/&gt; BaseObject:GetTask(taskId: any) → Task? Fetches the task with the given ID if it exists. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:AddTask(part, nil, &quot;Test&quot;) print(obj:GetTask(&quot;Test&quot;) == part) -- true   "},{"title":"AddTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddTask","content":"&lt;/&gt; BaseObject:AddTask( task: Task, taskCleanupMethod: (string | true | nil)?,-- (if none is given it will try to infer; Passing true tells it to call it as a function) taskId: any? ) → Task-- The task that was given Adds a task to the janitor. If a taskId is provided, it will be used as the key for the task in the janitor and can then be fetched later with :GetTask(). If an ID is provided and there already exists a task with that ID, it will clean up the existing task and then replace the index with the new one. It will return the task that was added/given. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end) obj:Destroy() -- Prints &quot;Hello, World!&quot;   "},{"title":"AddPromise​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddPromise","content":"&lt;/&gt; BaseObject:AddPromise(prom: Promise) → Promise Adds a promise to the janitor. Similar to :AddTask(). Returns the same Promise that was given to it. local prom = Promise.delay(math.random(10)) local obj = BaseObject.new() obj:AddPromise(prom) task.wait(math.random(10)) obj:Destroy() -- Cancels the promise if it hasn't resolved yet   "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTask","content":"&lt;/&gt; BaseObject:RemoveTask( taskId: any, dontClean: boolean? ) → () Removes a task from the janitor. Cleans the task as if :DoCleaning was called. If dontClean is true, it will not clean up the task, it will just remove it from the janitor. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTask(&quot;Test&quot;) -- Prints &quot;Hello, World!&quot;   "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTaskNoClean","content":"&lt;/&gt; BaseObject:RemoveTaskNoClean(taskId: any) → () Removes a task from the janitor without cleaning it. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTaskNoClean(&quot;Test&quot;) -- Does NOT print &quot;Hello, World!&quot;   "},{"title":"FireSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#FireSignal","content":"&lt;/&gt; BaseObject:FireSignal( signalName: string,-- The name of the signal to fire ...: any-- Arguments to pass to the signal ) → () Fires the signal with the given name, if it exists. Equivalent to calling :GetSignal(signalName):Fire(...) except this does not require the signal to exist first. local obj = BaseObject.new() local SignalName = &quot;Test&quot; obj:RegisterSignal(SignalName) obj:GetSignal(SignalName):Connect(print) obj:FireSignal(SignalName, &quot;Hello, World!&quot;) -- Fires the signal with the argument &quot;Hello, World!&quot;   "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RegisterSignal","content":"&lt;/&gt; BaseObject:RegisterSignal( signalName: string-- Name of signal to register ) → () Marks a signal with the given name as registered. Does not actually build a new signal, it sets the index to a SignalMarker to identify it as registered so that it can be fetched later.  "},{"title":"HasSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#HasSignal","content":"&lt;/&gt; BaseObject:HasSignal(signalName: string) → boolean Checks whether or not a signal with the given name is registered. local obj = BaseObject.new() local SignalName = &quot;Test&quot; print(obj:HasSignal(SignalName)) -- false obj:RegisterSignal(SignalName) print(obj:HasSignal(SignalName)) -- true   "},{"title":"GetSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetSignal","content":"&lt;/&gt; BaseObject:GetSignal(signalName: string) → Signal Fetches a signal with the given name. Creates the Signal JIT.  "},{"title":"ConnectSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ConnectSignal","content":"&lt;/&gt; BaseObject:ConnectSignal( signalName: string, func: (...any) → () ) → () Connects a function to a signal with the given name. Creates the signal JIT. Shorthand for :GetSignal(signalName):Connect(func).  "},{"title":"GetDestroyedSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetDestroyedSignal","content":"&lt;/&gt; BaseObject:GetDestroyedSignal() → Signal Returns a signal that fires when the object is destroyed. Creates the signal JIT. Kept for backwards compatibility. local obj = BaseObject.new() obj:GetDestroyedSignal():Connect(function() print(&quot;Object Destroyed!&quot;) end) obj:Destroy() -- Prints &quot;Object Destroyed!&quot;   "},{"title":"BindToInstance​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BindToInstance","content":"&lt;/&gt; BaseObject:BindToInstance( obj: Instance , destroyOnNilParent: boolean?-- Whether or not to destroy the object when the parent is nil'd ) → function-- Disconnects the binding Binds the object to the given instance. When the object is destroyed, it will destroy the instance. When the instance is destroyed, it will destroy the object. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:BindToInstance(part) do -- setup prints on destroy obj:AddTask(function() print(&quot;Object Destroyed!&quot;) end) part.Destroying:Connect(function() print(&quot;Part Destroyed!&quot;) end) end local X = if math.random(1,2) == 1 then obj or part X:Destroy() -- Prints &quot;Object Destroyed!&quot; and &quot;Part Destroyed!&quot; (Destroying one will destroy the other)  "},{"title":"TableUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#functions","content":" "},{"title":"Copy​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Copy","content":"&lt;/&gt; TableUtil.Copy( tbl: table,-- Table to copy deep: boolean?-- Whether or not to perform a deep copy ) → table Creates a copy of the given table. By default, a shallow copy is performed. For deep copies, a second boolean argument must be passed to the function. No cyclical references Deep copies are not protected against cyclical references. Passing a table with cyclical references and the deep parameter set to true will result in a stack-overflow.  "},{"title":"Sync​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Sync","content":"&lt;/&gt; TableUtil.Sync( srcTbl: table,-- Source table templateTbl: table-- Template table ) → table Synchronizes the srcTbl based on the templateTbl. This will make sure that srcTbl has all of the same keys as templateTbl, including removing keys in srcTbl that are not present in templateTbl. This is a deep operation, so any nested tables will be synchronized as well. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, experience = 12} data = TableUtil.Sync(data, template) print(data) --&gt; {kills = 10, deaths = 0, xp = 0} Data Loss Warning This is a two-way sync, so the source table will have dataremoved that isn't found in the template table. This can be problematic if used for player data, where there might be dynamic data added that isn't in the template. For player data, use TableUtil.Reconcile instead.  "},{"title":"Reconcile​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Reconcile","content":"&lt;/&gt; TableUtil.Reconcile( source: table, template: table ) → table Performs a one-way sync on the source table against the template table. Any keys found in template that are not found in source will be added to source. This is useful for syncing player data against data template tables to ensure players have all the necessary keys, while maintaining existing keys that may no longer be in the template. This is a deep operation, so nested tables will also be properly reconciled. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, abc = 20} local correctedData = TableUtil.Reconcile(data, template) print(correctedData) --&gt; {kills = 10, deaths = 0, xp = 0, abc = 20}   "},{"title":"SwapRemove​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#SwapRemove","content":"&lt;/&gt; TableUtil.SwapRemove( tbl: table,-- Array i: number-- Index ) → () Removes index i in the table by swapping the value at i with the last value in the array, and then trimming off the last value from the array. This allows removal of the value at i in O(1) time, but does not preserve array ordering. If a value needs to be removed from an array, but ordering of the array does not matter, using SwapRemove is always preferred over table.remove. In the following example, we remove &quot;B&quot; at index 2. SwapRemove does this by moving the last value &quot;E&quot; over top of &quot;B&quot;, and then trimming off &quot;E&quot; at the end of the array: local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} TableUtil.SwapRemove(t, 2) -- Remove &quot;B&quot; print(t) --&gt; {&quot;A&quot;, &quot;E&quot;, &quot;C&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"SwapRemoveFirstValue​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#SwapRemoveFirstValue","content":"&lt;/&gt; TableUtil.SwapRemoveFirstValue( tbl: table,-- Array v: any-- Value to find ) → number? Performs table.find(tbl, v) to find the index of the given value, and then performs TableUtil.SwapRemove on that index. local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} TableUtil.SwapRemoveFirstValue(t, &quot;C&quot;) print(t) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;E&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Map​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Map","content":"&lt;/&gt; TableUtil.Map( tbl: table, predicate: ( value: any, key: any, tbl: table ) → newValue: any ) → table Performs a map operation against the given table, which can be used to map new values based on the old values at given keys/indices. For example: local t = {A = 10, B = 20, C = 30} local t2 = TableUtil.Map(t, function(value) return value * 2 end) print(t2) --&gt; {A = 20, B = 40, C = 60}   "},{"title":"Filter​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Filter","content":"&lt;/&gt; TableUtil.Filter( tbl: table, predicate: ( value: any, key: any, tbl: table ) → keep: boolean ) → table Performs a filter operation against the given table, which can be used to filter out unwanted values from the table. For example: local t = {A = 10, B = 20, C = 30} local t2 = TableUtil.Filter(t, function(value, key) return value &gt; 15 end) print(t2) --&gt; {B = 40, C = 60}   "},{"title":"Reduce​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Reduce","content":"&lt;/&gt; TableUtil.Reduce( tbl: table, predicate: ( accumulator: any, value: any, index: any, tbl: table ) → result: any ) → table Performs a reduce operation against the given table, which can be used to reduce the table into a single value. This could be used to sum up a table or transform all the values into a compound value of any kind. For example: local t = {10, 20, 30, 40} local result = TableUtil.Reduce(t, function(accum, value) return accum + value end) print(result) --&gt; 100   "},{"title":"Assign​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Assign","content":"&lt;/&gt; TableUtil.Assign( target: table, ...: table ) → table Copies all values of the given tables into the target table. local t = {A = 10} local t2 = {B = 20} local t3 = {C = 30, D = 40} local newT = TableUtil.Assign(t, t2, t3) print(newT) --&gt; {A = 10, B = 20, C = 30, D = 40}   "},{"title":"Extend​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Extend","content":"&lt;/&gt; TableUtil.Extend( target: table, extension: table ) → table Extends the target array with the extension array. local t = {10, 20, 30} local t2 = {30, 40, 50} local tNew = TableUtil.Extend(t, t2) print(tNew) --&gt; {10, 20, 30, 30, 40, 50} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Reverse​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Reverse","content":"&lt;/&gt; TableUtil.Reverse(tbl: table) → table Reverses the array. local t = {1, 5, 10} local tReverse = TableUtil.Reverse(t) print(tReverse) --&gt; {10, 5, 1} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Shuffle​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Shuffle","content":"&lt;/&gt; TableUtil.Shuffle( tbl: table, rngOverride: Random? ) → table Shuffles the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local shuffled = TableUtil.Shuffle(t) print(shuffled) --&gt; e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Sample​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Sample","content":"&lt;/&gt; TableUtil.Sample( tbl: table, sampleSize: number, rngOverride: Random? ) → table Returns a random sample of the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local sample = TableUtil.Sample(t, 3) print(sample) --&gt; e.g. {6, 2, 5} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Flat​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Flat","content":"&lt;/&gt; TableUtil.Flat( tbl: table, depth: number? ) → table Returns a new table where all sub-arrays have been bubbled up to the top. The depth at which the scan is performed is dictated by the depth parameter, which is set to 1 by default. local t = {{10, 20}, {90, 100}, {30, 15}} local flat = TableUtil.Flat(t) print(flat) --&gt; {10, 20, 90, 100, 30, 15} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"FlatMap​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#FlatMap","content":"&lt;/&gt; TableUtil.FlatMap( tbl: table, predicate: ( key: any, value: any, tbl: table ) → newValue: any ) → table Calls TableUtil.Map on the given table and predicate, and then calls TableUtil.Flat on the result from the map operation. local t = {10, 20, 30} local result = TableUtil.FlatMap(t, function(value) return {value, value * 2} end) print(result) --&gt; {10, 20, 20, 40, 30, 60} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Keys​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Keys","content":"&lt;/&gt; TableUtil.Keys(tbl: table) → table Returns an array with all the keys in the table. local t = {A = 10, B = 20, C = 30} local keys = TableUtil.Keys(t) print(keys) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} Ordering The ordering of the keys is never guaranteed. If order is imperative, calltable.sort on the resulting keys array. local keys = TableUtil.Keys(t) table.sort(keys)   "},{"title":"Values​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Values","content":"&lt;/&gt; TableUtil.Values(tbl: table) → table Returns an array with all the values in the table. local t = {A = 10, B = 20, C = 30} local values = TableUtil.Values(t) print(values) --&gt; {10, 20, 30} Ordering The ordering of the values is never guaranteed. If order is imperative, calltable.sort on the resulting values array. local values = TableUtil.Values(t) table.sort(values)   "},{"title":"Find​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Find","content":"&lt;/&gt; TableUtil.Find( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → ( value: any?, key: any? ) Performs a linear scan across the table and calls callback on each item in the array. Returns the value and key of the first pair in which the callback returns true. local t = { {Name = &quot;Bob&quot;, Age = 20}; {Name = &quot;Jill&quot;, Age = 30}; {Name = &quot;Ann&quot;, Age = 25}; } -- Find first person who has a name starting with J: local firstPersonWithJ = TableUtil.Find(t, function(person) return person.Name:sub(1, 1):lower() == &quot;j&quot; end) print(firstPersonWithJ) --&gt; {Name = &quot;Jill&quot;, Age = 30} Dictionary Ordering While Find can also be used with dictionaries, dictionary ordering is never guaranteed, and thus the result could be different if there are more than one possible matches given the data and callback function.  "},{"title":"Every​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Every","content":"&lt;/&gt; TableUtil.Every( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for every item in the table. local t = {10, 20, 40, 50, 60} local allAboveZero = TableUtil.Every(t, function(value) return value &gt; 0 end) print(&quot;All above zero:&quot;, allAboveZero) --&gt; All above zero: true   "},{"title":"Some​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Some","content":"&lt;/&gt; TableUtil.Some( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for at least one of the items in the table. local t = {10, 20, 40, 50, 60} local someBelowTwenty = TableUtil.Some(t, function(value) return value &lt; 20 end) print(&quot;Some below twenty:&quot;, someBelowTwenty) --&gt; Some below twenty: true   "},{"title":"Truncate​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Truncate","content":"&lt;/&gt; TableUtil.Truncate( tbl: table, length: number ) → table Returns a new table truncated to the length of length. Any length equal or greater than the current length will simply return a shallow copy of the table. local t = {10, 20, 30, 40, 50, 60, 70, 80} local tTruncated = TableUtil.Truncate(t, 3) print(tTruncated) --&gt; {10, 20, 30}   "},{"title":"Zip​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Zip","content":"&lt;/&gt; TableUtil.Zip(...: table) → ( iter: ( t: table, k: any ) → ( key: any?, values: table? ), tbl: table, startIndex: any? ) Returns an iterator that can scan through multiple tables at the same time side-by-side, matching against shared keys/indices. local t1 = {10, 20, 30, 40, 50} local t2 = {60, 70, 80, 90, 100} for key,values in TableUtil.Zip(t1, t2) do print(key, values) end --[[ Outputs: 1 {10, 60} 2 {20, 70} 3 {30, 80} 4 {40, 90} 5 {50, 100} --]]   "},{"title":"Lock​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Lock","content":"&lt;/&gt; TableUtil.Lock(tbl: table) → table Locks the table using table.freeze, as well as any nested tables within the given table. This will lock the whole deep structure of the table, disallowing any further modifications. local tbl = {xyz = {abc = 32}} tbl.xyz.abc = 28 -- Works fine TableUtil.Lock(tbl) tbl.xyz.abc = 64 -- Will throw an error (cannot modify readonly table)   "},{"title":"IsEmpty​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#IsEmpty","content":"&lt;/&gt; TableUtil.IsEmpty(tbl: table) → boolean Returns true if the given table is empty. This is simply performed by checking if next(tbl) is nil and works for both arrays and dictionaries. This is useful when needing to check if a table is empty but not knowing if it is an array or dictionary. TableUtil.IsEmpty({}) -- true TableUtil.IsEmpty({&quot;abc&quot;}) -- false TableUtil.IsEmpty({abc = 32}) -- false   "},{"title":"EncodeJSON​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#EncodeJSON","content":"&lt;/&gt; TableUtil.EncodeJSON(value: any) → string Proxy for HttpService:JSONEncode.  "},{"title":"DecodeJSON​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#DecodeJSON","content":"&lt;/&gt; TableUtil.DecodeJSON(value: any) → string Proxy for HttpService:JSONDecode.  "},{"title":"ShallowReconcile​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#ShallowReconcile","content":"&lt;/&gt; TableUtil.ShallowReconcile( src: S, template: T ) → S&amp;T Performs a one-way sync on the source table against the template table. Any keys found in template that are not found in source will be added to source. This is useful for syncing player data against data template tables to ensure players have all the necessary keys, while maintaining existing keys that may no longer be in the template. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, abc = 20} local correctedData = TableUtil.ShallowReconcile(data, template) print(correctedData) --&gt; {kills = 10, deaths = 0, xp = 0, abc = 20}   "},{"title":"ToDict​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#ToDict","content":"&lt;/&gt; TableUtil.ToDict( array: {T},-- The array to parse fn: ( T, number ) → ( K, V )-- A function to transform the index ) → {[K]: V}-- The new dictionary Converts an array into a dictionary using a given function to generate a new Key and Value.  "},{"title":"Weak​","type":1,"pageTitle":"TableUtil","url":"/ModulesOnRails/api/TableUtil#Weak","content":"&lt;/&gt; TableUtil.Weak( tbl: T?,-- The table to make weak mode: string?-- The mode to use for the weak table ) → T&amp;tbl-- The weak table A simple wrapper for making a weak table. By default just the keys are made weak, but the second argument allows specifying the mode. "},{"title":"VectorUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/VectorUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#types","content":" "},{"title":"Vector​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#Vector","content":"&lt;/&gt; type Vector = Vector3 | Vector2    "},{"title":"Plane​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#Plane","content":"&lt;/&gt; type Plane = {number} Data type representing a plane. The plane is represented by a table with 4 values. Typically used for plane intersection calculations. "},{"title":"Functions​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#functions","content":" "},{"title":"unpack​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#unpack","content":"&lt;/&gt; VectorUtil.unpack(Vector: Vector) → ...number Splits a Vector into its components.  "},{"title":"snap​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#snap","content":"&lt;/&gt; VectorUtil.snap( vector: T&amp;Vector, snapToNearestMultiple: number ) → Vector Snaps a Vector to the nearest multiple of the given number for each coordinate.  "},{"title":"roundLength​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#roundLength","content":"Vector2 Vector3 &lt;/&gt; VectorUtil.roundLength( vector: T&amp;Vector, increment: number ) → T Rounds a Vectors length to the nearest multiple of the given number.  "},{"title":"randomUnitVector​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#randomUnitVector","content":"&lt;/&gt; VectorUtil.randomUnitVector() → Vector3  Returns a random unit vector3. Evenly distributes around the unit sphere.  "},{"title":"truncate​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#truncate","content":"&lt;/&gt; VectorUtil.truncate( Vector: T&amp;Vector,-- The vector to truncate. maxLength: number-- The maximum length of the vector. ) → Vector-- The truncated vector. Truncates the length of a vector such that if it exceeds the given length, it will be truncated to that length.  "},{"title":"getAngle​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#getAngle","content":"&lt;/&gt; VectorUtil.getAngle(vector: Vector2 ) → number Returns the angle of a Vector2 relative to the X axis.  "},{"title":"getAngleBetween​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#getAngleBetween","content":"&lt;/&gt; VectorUtil.getAngleBetween( firstVector: Vector, secondVector: Vector ) → number Returns the shortest angle between two vectors in Radians.  "},{"title":"getSignedAngleBetweenVector3s​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#getSignedAngleBetweenVector3s","content":"&lt;/&gt; VectorUtil.getSignedAngleBetweenVector3s( firstVector: Vector3 ,-- The start of the angle secondVector: Vector3 ,-- The end of the angle axis: Vector3 -- The axis to rotate around ) → number-- The signed angle between the two vectors in radians. Returns a signed angle in radians between two Vector3s around a given axis. The sign is calculated counter-clockwise, left of first vector is positive, right of first vector is negative.  "},{"title":"getSignedAngleBetweenVector2s​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#getSignedAngleBetweenVector2s","content":"&lt;/&gt; VectorUtil.getSignedAngleBetweenVector2s( firstVector: Vector2 ,-- The start of the angle secondVector: Vector2 -- The end of the angle ) → number-- The signed angle between the two vectors in radians. Returns a signed angle in radians between two vectors. The sign is calculated counter-clockwise, left of first vector is positive, right of first vector is negative.  "},{"title":"isNaN​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#isNaN","content":"&lt;/&gt; VectorUtil.isNaN(vector: Vector) → boolean Checks if a given vector is NaN.  "},{"title":"abs​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#abs","content":"&lt;/&gt; VectorUtil.abs(Vector: T&amp;Vector) → T Returns the absolute value of the Vector  "},{"title":"sign​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#sign","content":"&lt;/&gt; VectorUtil.sign(Vector: T&amp;Vector) → T Returns a Vector where each component is the sign of the original Vector.  "},{"title":"normalize​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#normalize","content":"&lt;/&gt; VectorUtil.normalize(Vector: T&amp;Vector) → T Safely Normalizes a Vector.  "},{"title":"flattenY​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#flattenY","content":"&lt;/&gt; VectorUtil.flattenY( Vector: Vector3 ,-- The Vector3 to flatten. newY: number?-- the height to flatten the vector to. Defaults to 0. ) → Vector3 -- The flattened Vector3. Flattens a Vector3 on its Y axis  "},{"title":"flatten​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#flatten","content":"&lt;/&gt; VectorUtil.flatten( Vector: Vector3 ,-- The Vector3 to flatten. axis: Enum.Axis,-- The axis to flatten the vector on. Defaults to &quot;Y&quot;. defaultValue: number?-- The value to set the flattened axis to. Defaults to 0. ) → Vector3 -- The flattened Vector3. Flattens a given Vector3 on a specified axis  "},{"title":"getAxis​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#getAxis","content":"&lt;/&gt; VectorUtil.getAxis( vector: Vector3 ,-- The Vector to pull from axis: Enum.Axis-- The axis to get ) → Vector3 -- The returned Vector containing only the specified axis. Takes a Vector and removes all values except the specified Axis.  "},{"title":"setAxis​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#setAxis","content":"&lt;/&gt; VectorUtil.setAxis( vector: Vector3 ,-- The Vector to change from axis: Enum.Axis,-- The axis to set value: number-- The new value of the axis ) → Vector3 -- The adjusted Vector Takes a Vector and sets the axis value to the specified number.  "},{"title":"rotateVector3​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#rotateVector3","content":"&lt;/&gt; VectorUtil.rotateVector3( vectorToRotate: Vector3 ,-- The vector to rotate. anglesToRotate: ({number} | Vector3 | CFrame )-- The angles to rotate the vector by. ) → Vector3 -- The rotated vector. Rotates a vector about its axis by the given angles. Takes a CFrame.Angles object as the angles to rotate by. Works similarly to rotating a CFrame. rotateVector(Vector3.new(1,0,0), CFrame.Angles(0,math.pi,0)) -- Output: Vector3.new(-1,0,0)  "},{"title":"rotateVector2​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#rotateVector2","content":"&lt;/&gt; VectorUtil.rotateVector2( vectorToRotate: Vector2 ,-- The vector to rotate. angle: number-- The angle [In Radians] to rotate the vector by. ) → Vector2 -- The rotated vector. Rotates a vector2 by a given amount of radians.  "},{"title":"closestPointOnLine​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#closestPointOnLine","content":"&lt;/&gt; VectorUtil.closestPointOnLine( refPoint: Vector3 ,-- The point to find the closest point to. linePoint: Vector3 ,-- A point along the line. lineDirection: Vector3 -- The direction of the line. ) → Vector3 -- The closest point on the line to the reference point. Finds the closest point on a line to a given point.  "},{"title":"closestPointsBetweenLines​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#closestPointsBetweenLines","content":"&lt;/&gt; VectorUtil.closestPointsBetweenLines( point1: Vector3 ,-- A point along the first line. direction1: Vector3 ,-- The direction of the first line. point2: Vector3 ,-- A point along the second line. direction2: Vector3 -- The direction of the second line. ) → ( Vector2 ,-- The closest point on the first line. Vector2 -- The closest point on the second line. ) Finds the closest two points on two lines. The lines are defined by some point along them and a direction  "},{"title":"planeIntersectionPoint​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#planeIntersectionPoint","content":"&lt;/&gt; VectorUtil.planeIntersectionPoint( lineOrigin: Vector3 ,-- A point along the line. lineDirection: Vector3 ,-- The direction of the line. planeOrigin: Vector3 ,-- A point on the plane. planeNormal: Vector3 -- The normal of the plane. ) → Vector3? -- The intersection point of the line and the plane if one exists. Finds the intersection point of a line and a plane.  "},{"title":"lineIntersectsSphere​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#lineIntersectsSphere","content":"&lt;/&gt; VectorUtil.lineIntersectsSphere( lineOrigin: Vector3 ,-- A point along the line. lineDirection: Vector3 ,-- The direction of the line. sphereOrigin: Vector3 ,-- The origin of the sphere. sphereRadius: number-- The radius of the sphere. ) → boolean-- Whether or not the line intersects the sphere. Tests whether or not a line of infinite length intersects a sphere at some point.  "},{"title":"lineSegmentIntersectsSphere​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#lineSegmentIntersectsSphere","content":"&lt;/&gt; VectorUtil.lineSegmentIntersectsSphere( linePoint1: Vector3 ,-- The start point of the line segment. linePoint2: Vector3 ,-- The end point of the line segment. sphereOrigin: Vector3 ,-- The center point of the sphere. sphereRadius: number-- The radius of the sphere. ) → boolean-- Whether or not the line segment intersects the sphere. Tests whether or not a line segment intersects a sphere at some point. Only returns true if the intersection point is between the two points of the line segment.  "},{"title":"calculatePlaneFromPoints​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#calculatePlaneFromPoints","content":"&lt;/&gt; VectorUtil.calculatePlaneFromPoints( p1: Vector3 ,-- The first point. p2: Vector3 ,-- The second point. p3: Vector3 -- The third point. ) → Plane-- The plane defined by the three points. Creates a plane from three points. The normal of the plane is determined by the input order of the points.  "},{"title":"calculatePlaneFromPointAndNormal​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#calculatePlaneFromPointAndNormal","content":"&lt;/&gt; VectorUtil.calculatePlaneFromPointAndNormal( point: Vector3 ,-- A point on the plane. normal: Vector3 -- The normal of the plane. ) → Plane-- The plane defined by the point and normal. Creates a plane from a point and a normal.  "},{"title":"pointLiesOnPlane​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#pointLiesOnPlane","content":"&lt;/&gt; VectorUtil.pointLiesOnPlane( point: Vector3 ,-- The point to check. plane: Plane-- The plane to check against. ) → boolean-- Whether or not the point lies on the plane. Checks if a point lies on a plane. Use one of the calculatePlane functions to generate a plane. local plane = VectorUtil.calculatePlaneFromPoints(Vector3.new(0,0,0), Vector3.new(1,0,0), Vector3.new(0,1,0)) local point = Vector3.new(1,1,0) VectorUtil.pointLiesOnPlane(point plane) -- Output: true   "},{"title":"projectOnPlane​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#projectOnPlane","content":"&lt;/&gt; VectorUtil.projectOnPlane( dir: Vector3 ,-- The vector to project. normal: Vector3? -- The normal of the plane to project onto. Defaults to Vector3.new(0, 1, 0). ) → Vector3 -- The projected vector. Projects a vector onto a plane defined by a normal. local dir = Vector3.new(1, 1, 1) local normal = Vector3.new(0, 1, 0) VectorUtil.projectOnPlane(dir, normal) -- Output: Vector3.new(1, 0, 1)   "},{"title":"reflect​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#reflect","content":"&lt;/&gt; VectorUtil.reflect( dir: Vector3 ,-- The vector to reflect. normal: Vector3 -- The normal of the surface to reflect off of. ) → Vector3 -- The reflected vector. Reflects a vector off a surface normal.  "},{"title":"reflectIgnoringY​","type":1,"pageTitle":"VectorUtil","url":"/ModulesOnRails/api/VectorUtil#reflectIgnoringY","content":"&lt;/&gt; VectorUtil.reflectIgnoringY( dir: Vector3 ,-- The vector to reflect. surfaceNormal: Vector3 -- The normal of the surface to reflect off of. ) → Vector3 -- The reflected vector. Reflects a vector ignoring the Y component of the surface normal. This is useful when you want to keep reflections on a 2D plane. "},{"title":"Janitor","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Janitor","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#properties","content":" "},{"title":"CurrentlyCleaning​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#CurrentlyCleaning","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Janitor.CurrentlyCleaning: boolean Whether or not the Janitor is currently cleaning up.  "},{"title":"SuppressInstanceReDestroy​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#SuppressInstanceReDestroy","content":"since 1.15.4 &lt;/&gt; Janitor.SuppressInstanceReDestroy: boolean Whether or not you want to suppress the re-destroying of instances. Default is false, which is the original behavior.  "},{"title":"CurrentlyCleaning​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#CurrentlyCleaning","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Janitor.CurrentlyCleaning: boolean Whether or not the Janitor is currently cleaning up.  "},{"title":"SuppressInstanceReDestroy​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#SuppressInstanceReDestroy","content":"since 1.15.4 &lt;/&gt; Janitor.SuppressInstanceReDestroy: boolean Whether or not you want to suppress the re-destroying of instances. Default is false, which is the original behavior.  "},{"title":"CurrentlyCleaning​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#CurrentlyCleaning","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Janitor.CurrentlyCleaning: boolean Whether or not the Janitor is currently cleaning up.  "},{"title":"SuppressInstanceReDestroy​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#SuppressInstanceReDestroy","content":"since 1.15.4 &lt;/&gt; Janitor.SuppressInstanceReDestroy: boolean Whether or not you want to suppress the re-destroying of instances. Default is false, which is the original behavior. "},{"title":"Functions​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#new","content":"&lt;/&gt; Janitor.new() → Janitor Instantiates a new Janitor object.  "},{"title":"Is​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Is","content":"&lt;/&gt; Janitor.Is( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. Determines if the passed object is a Janitor. This checks the metatable directly.  "},{"title":"instanceof​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#instanceof","content":"&lt;/&gt; Janitor.instanceof( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. An alias for Janitor.Is. This is intended for roblox-ts support.  "},{"title":"new​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#new","content":"&lt;/&gt; Janitor.new() → Janitor Instantiates a new Janitor object.  "},{"title":"Is​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Is","content":"&lt;/&gt; Janitor.Is( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. Determines if the passed object is a Janitor. This checks the metatable directly.  "},{"title":"instanceof​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#instanceof","content":"&lt;/&gt; Janitor.instanceof( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. An alias for Janitor.Is. This is intended for roblox-ts support.  "},{"title":"new​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#new","content":"&lt;/&gt; Janitor.new() → Janitor Instantiates a new Janitor object.  "},{"title":"Is​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Is","content":"&lt;/&gt; Janitor.Is( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. Determines if the passed object is a Janitor. This checks the metatable directly.  "},{"title":"instanceof​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#instanceof","content":"&lt;/&gt; Janitor.instanceof( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. An alias for Janitor.Is. This is intended for roblox-ts support.  "},{"title":"Add​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Add","content":"&lt;/&gt; Janitor:Add( object: T,-- The object you want to clean up. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown-- The index that can be used to clean up the object manually. ) → T-- The object that was passed as the first argument. Adds an object to Janitor for later cleanup, where methodName is the key of the method within object which should be called at cleanup time. If the methodName is true the object itself will be called if it's a function or have task.cancel called on it if it is a thread. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Returns the object. Note Objects not given an explicit methodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to &quot;Disconnect&quot;, functions and threads will be assigned to true, and everything else will default to &quot;Destroy&quot;. Not recommended, but hey, you do you. Luau: local Workspace = game:GetService(&quot;Workspace&quot;) local TweenService = game:GetService(&quot;TweenService&quot;) local obliterator = Janitor.new() local part = Workspace:FindFirstChild(&quot;Part&quot;) :: Part -- Queue the Part to be Destroyed at Cleanup time obliterator:Add(part, &quot;Destroy&quot;) -- Queue function to be called with `true` methodName obliterator:Add(print, true) -- Close a thread. obliterator:Add(task.defer(function() while true do print(&quot;Running!&quot;) task.wait(0.5) end end), true) -- This implementation allows you to specify behavior for any object obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Cancel&quot;) -- By passing an index, the object will occupy a namespace -- If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Destroy&quot;, &quot;CurrentTween&quot;) TypeScript: import { Workspace, TweenService } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ CurrentTween: Tween }&gt;(); const part = Workspace.FindFirstChild(&quot;Part&quot;) as Part; // Queue the part to be Destroyed at Cleanup time obliterator.Add(part, &quot;Destroy&quot;); // Queue function to be called with `true` methodName obliterator.Add(print, true); // Close a thread. obliterator.Add(task.defer(() =&gt; { while (true) { print(&quot;Running!&quot;); task.wait(0.5); } }), true); // This implementation allows you to specify behavior for any object obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Cancel&quot;); // By passing an index, the object will occupy a namespace // If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Destroy&quot;, &quot;CurrentTween&quot;);   "},{"title":"AddObject​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#AddObject","content":"since v1.16.0 &lt;/&gt; Janitor:AddObject( constructor: {new: (A...) → T},-- The constructor for the object you want to add to the Janitor. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown,-- The index that can be used to clean up the object manually. ...: A...-- The arguments that will be passed to the constructor. ) → T-- The object that was passed as the first argument. Constructs an object for you and adds it to the Janitor. It's really just shorthand for Janitor:Add(object.new(), methodName, index). Luau: local obliterator = Janitor.new() local subObliterator = obliterator:AddObject(Janitor, &quot;Destroy&quot;) -- subObliterator is another Janitor! TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); const subObliterator = obliterator.AddObject(Janitor, &quot;Destroy&quot;);   "},{"title":"AddPromise​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#AddPromise","content":"&lt;/&gt; Janitor:AddPromise( promiseObject: Promise-- The promise you want to add to the Janitor. ) → Promise Adds a Promise to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled. Luau: local obliterator = Janitor.new() obliterator:AddPromise(Promise.delay(3)):andThenCall(print, &quot;Finished!&quot;):catch(warn) task.wait(1) obliterator:Cleanup() TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.AddPromise(Promise.delay(3)).andThenCall(print, &quot;Finished!&quot;).catch(warn); task.wait(1); obliterator.Cleanup();  "},{"title":"Errors","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor##","content":"Type\tDescriptionNotAPromiseError\tThrown if the promise is not a Promise.  "},{"title":"Remove​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Remove","content":"&lt;/&gt; Janitor:Remove( index: unknown-- The index you want to remove. ) → Janitor Cleans up whatever Object was set to this namespace by the 3rd parameter of Janitor.Add. Luau: local obliterator = Janitor.new() obliterator:Add(workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) obliterator:Remove(&quot;Baseplate&quot;) TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); obliterator.Remove(&quot;Baseplate&quot;);   "},{"title":"RemoveNoClean​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveNoClean( index: unknown-- The index you are removing. ) → Janitor Removes an object from the Janitor without running a cleanup. Luau local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed!&quot;) end, true, &quot;Function&quot;) obliterator:RemoveNoClean(&quot;Function&quot;) -- Does not print. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Function: () =&gt; void }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed!&quot;), true, &quot;Function&quot;); obliterator.RemoveNoClean(&quot;Function&quot;); // Does not print.   "},{"title":"RemoveList​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveList","content":"since v1.14.0 &lt;/&gt; Janitor:RemoveList( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot; TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOp = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOp, Two: NoOp, Three: NoOp }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot;   "},{"title":"RemoveListNoClean​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveListNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveListNoClean( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once without running their cleanup. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Nothing is printed. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOperation = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOperation, Two: NoOperation, Three: NoOperation }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Nothing is printed.   "},{"title":"Get​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Get","content":"&lt;/&gt; Janitor:Get( index: unknown-- The index that the object is stored under. ) → unknown?-- This will return the object if it is found, but it won't return anything if it doesn't exist. Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using __index. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:Get(&quot;Baseplate&quot;)) -- Returns Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.Get(&quot;Baseplate&quot;)); // Returns Baseplate.   "},{"title":"GetAll​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#GetAll","content":"since v1.15.1 &lt;/&gt; Janitor:GetAll() → {[any]: any} Returns a frozen copy of the Janitor's indices. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:GetAll().Baseplate) -- Prints Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.GetAll().Baseplate); // Prints Baseplate.   "},{"title":"Cleanup​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Cleanup","content":"&lt;/&gt; Janitor:Cleanup() → () Calls each object's methodName (or calls the object if methodName == true) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor object (so it can be used as a destructor callback). Luau: obliterator:Cleanup() -- Valid. obliterator() -- Also valid. TypeScript: obliterator.Cleanup() // TypeScript version doesn't support the __call method of cleaning.   "},{"title":"Destroy​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Destroy","content":"&lt;/&gt; Janitor:Destroy() → () Calls Janitor.Cleanup and renders the Janitor unusable. Metatable Removal Running this will make any further attempts to call a method of Janitor error.  "},{"title":"LinkToInstance​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#LinkToInstance","content":"&lt;/&gt; Janitor:LinkToInstance( object: Instance ,-- The instance you want to link the Janitor to. allowMultiple?: boolean-- Whether or not to allow multiple links on the same Janitor. ) → RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance. &quot;Links&quot; this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroy()d and garbage collected. A Janitor may only be linked to one instance at a time, unless allowMultiple is true. When called with a truthy allowMultiple parameter, the Janitor will &quot;link&quot; the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy allowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy allowMultiple parameter, if applicable. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Cleaning up!&quot;) end, true) do local folder = Instance.new(&quot;Folder&quot;) obliterator:LinkToInstance(folder) folder:Destroy() end TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.Add(() =&gt; print(&quot;Cleaning up!&quot;), true); { const folder = new Instance(&quot;Folder&quot;); obliterator.LinkToInstance(folder, false); folder.Destroy(); }   "},{"title":"LinkToInstances​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#LinkToInstances","content":"&lt;/&gt; Janitor:LinkToInstances( ...: Instance -- All the Instances you want linked. ) → Janitor-- A new Janitor that can be used to manually disconnect all LinkToInstances. Links several instances to a new Janitor, which is then returned.  "},{"title":"Add​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Add","content":"&lt;/&gt; Janitor:Add( object: T,-- The object you want to clean up. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown-- The index that can be used to clean up the object manually. ) → T-- The object that was passed as the first argument. Adds an object to Janitor for later cleanup, where methodName is the key of the method within object which should be called at cleanup time. If the methodName is true the object itself will be called if it's a function or have task.cancel called on it if it is a thread. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Returns the object. Note Objects not given an explicit methodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to &quot;Disconnect&quot;, functions and threads will be assigned to true, and everything else will default to &quot;Destroy&quot;. Not recommended, but hey, you do you. Luau: local Workspace = game:GetService(&quot;Workspace&quot;) local TweenService = game:GetService(&quot;TweenService&quot;) local obliterator = Janitor.new() local part = Workspace:FindFirstChild(&quot;Part&quot;) :: Part -- Queue the Part to be Destroyed at Cleanup time obliterator:Add(part, &quot;Destroy&quot;) -- Queue function to be called with `true` methodName obliterator:Add(print, true) -- Close a thread. obliterator:Add(task.defer(function() while true do print(&quot;Running!&quot;) task.wait(0.5) end end), true) -- This implementation allows you to specify behavior for any object obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Cancel&quot;) -- By passing an index, the object will occupy a namespace -- If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Destroy&quot;, &quot;CurrentTween&quot;) TypeScript: import { Workspace, TweenService } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ CurrentTween: Tween }&gt;(); const part = Workspace.FindFirstChild(&quot;Part&quot;) as Part; // Queue the part to be Destroyed at Cleanup time obliterator.Add(part, &quot;Destroy&quot;); // Queue function to be called with `true` methodName obliterator.Add(print, true); // Close a thread. obliterator.Add(task.defer(() =&gt; { while (true) { print(&quot;Running!&quot;); task.wait(0.5); } }), true); // This implementation allows you to specify behavior for any object obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Cancel&quot;); // By passing an index, the object will occupy a namespace // If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Destroy&quot;, &quot;CurrentTween&quot;);   "},{"title":"AddObject​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#AddObject","content":"since v1.16.0 &lt;/&gt; Janitor:AddObject( constructor: {new: (A...) → T},-- The constructor for the object you want to add to the Janitor. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown,-- The index that can be used to clean up the object manually. ...: A...-- The arguments that will be passed to the constructor. ) → T-- The object that was passed as the first argument. Constructs an object for you and adds it to the Janitor. It's really just shorthand for Janitor:Add(object.new(), methodName, index). Luau: local obliterator = Janitor.new() local subObliterator = obliterator:AddObject(Janitor, &quot;Destroy&quot;) -- subObliterator is another Janitor! TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); const subObliterator = obliterator.AddObject(Janitor, &quot;Destroy&quot;);   "},{"title":"AddPromise​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#AddPromise","content":"&lt;/&gt; Janitor:AddPromise( promiseObject: Promise-- The promise you want to add to the Janitor. ) → Promise Adds a Promise to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled. Luau: local obliterator = Janitor.new() obliterator:AddPromise(Promise.delay(3)):andThenCall(print, &quot;Finished!&quot;):catch(warn) task.wait(1) obliterator:Cleanup() TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.AddPromise(Promise.delay(3)).andThenCall(print, &quot;Finished!&quot;).catch(warn); task.wait(1); obliterator.Cleanup();  "},{"title":"Errors","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor##","content":"Type\tDescriptionNotAPromiseError\tThrown if the promise is not a Promise.  "},{"title":"Remove​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Remove","content":"&lt;/&gt; Janitor:Remove( index: unknown-- The index you want to remove. ) → Janitor Cleans up whatever Object was set to this namespace by the 3rd parameter of Janitor.Add. Luau: local obliterator = Janitor.new() obliterator:Add(workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) obliterator:Remove(&quot;Baseplate&quot;) TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); obliterator.Remove(&quot;Baseplate&quot;);   "},{"title":"RemoveNoClean​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveNoClean( index: unknown-- The index you are removing. ) → Janitor Removes an object from the Janitor without running a cleanup. Luau local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed!&quot;) end, true, &quot;Function&quot;) obliterator:RemoveNoClean(&quot;Function&quot;) -- Does not print. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Function: () =&gt; void }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed!&quot;), true, &quot;Function&quot;); obliterator.RemoveNoClean(&quot;Function&quot;); // Does not print.   "},{"title":"RemoveList​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveList","content":"since v1.14.0 &lt;/&gt; Janitor:RemoveList( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot; TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOp = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOp, Two: NoOp, Three: NoOp }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot;   "},{"title":"RemoveListNoClean​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveListNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveListNoClean( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once without running their cleanup. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Nothing is printed. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOperation = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOperation, Two: NoOperation, Three: NoOperation }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Nothing is printed.   "},{"title":"Get​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Get","content":"&lt;/&gt; Janitor:Get( index: unknown-- The index that the object is stored under. ) → unknown?-- This will return the object if it is found, but it won't return anything if it doesn't exist. Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using __index. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:Get(&quot;Baseplate&quot;)) -- Returns Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.Get(&quot;Baseplate&quot;)); // Returns Baseplate.   "},{"title":"GetAll​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#GetAll","content":"since v1.15.1 &lt;/&gt; Janitor:GetAll() → {[any]: any} Returns a frozen copy of the Janitor's indices. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:GetAll().Baseplate) -- Prints Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.GetAll().Baseplate); // Prints Baseplate.   "},{"title":"Cleanup​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Cleanup","content":"&lt;/&gt; Janitor:Cleanup() → () Calls each object's methodName (or calls the object if methodName == true) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor object (so it can be used as a destructor callback). Luau: obliterator:Cleanup() -- Valid. obliterator() -- Also valid. TypeScript: obliterator.Cleanup() // TypeScript version doesn't support the __call method of cleaning.   "},{"title":"Destroy​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Destroy","content":"&lt;/&gt; Janitor:Destroy() → () Calls Janitor.Cleanup and renders the Janitor unusable. Metatable Removal Running this will make any further attempts to call a method of Janitor error.  "},{"title":"LinkToInstance​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#LinkToInstance","content":"&lt;/&gt; Janitor:LinkToInstance( object: Instance ,-- The instance you want to link the Janitor to. allowMultiple?: boolean-- Whether or not to allow multiple links on the same Janitor. ) → RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance. &quot;Links&quot; this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroy()d and garbage collected. A Janitor may only be linked to one instance at a time, unless allowMultiple is true. When called with a truthy allowMultiple parameter, the Janitor will &quot;link&quot; the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy allowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy allowMultiple parameter, if applicable. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Cleaning up!&quot;) end, true) do local folder = Instance.new(&quot;Folder&quot;) obliterator:LinkToInstance(folder) folder:Destroy() end TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.Add(() =&gt; print(&quot;Cleaning up!&quot;), true); { const folder = new Instance(&quot;Folder&quot;); obliterator.LinkToInstance(folder, false); folder.Destroy(); }   "},{"title":"LinkToInstances​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#LinkToInstances","content":"&lt;/&gt; Janitor:LinkToInstances( ...: Instance -- All the Instances you want linked. ) → Janitor-- A new Janitor that can be used to manually disconnect all LinkToInstances. Links several instances to a new Janitor, which is then returned.  "},{"title":"Add​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Add","content":"&lt;/&gt; Janitor:Add( object: T,-- The object you want to clean up. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown-- The index that can be used to clean up the object manually. ) → T-- The object that was passed as the first argument. Adds an object to Janitor for later cleanup, where methodName is the key of the method within object which should be called at cleanup time. If the methodName is true the object itself will be called if it's a function or have task.cancel called on it if it is a thread. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Returns the object. Note Objects not given an explicit methodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to &quot;Disconnect&quot;, functions and threads will be assigned to true, and everything else will default to &quot;Destroy&quot;. Not recommended, but hey, you do you. Luau: local Workspace = game:GetService(&quot;Workspace&quot;) local TweenService = game:GetService(&quot;TweenService&quot;) local obliterator = Janitor.new() local part = Workspace:FindFirstChild(&quot;Part&quot;) :: Part -- Queue the Part to be Destroyed at Cleanup time obliterator:Add(part, &quot;Destroy&quot;) -- Queue function to be called with `true` methodName obliterator:Add(print, true) -- Close a thread. obliterator:Add(task.defer(function() while true do print(&quot;Running!&quot;) task.wait(0.5) end end), true) -- This implementation allows you to specify behavior for any object obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Cancel&quot;) -- By passing an index, the object will occupy a namespace -- If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Destroy&quot;, &quot;CurrentTween&quot;) TypeScript: import { Workspace, TweenService } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ CurrentTween: Tween }&gt;(); const part = Workspace.FindFirstChild(&quot;Part&quot;) as Part; // Queue the part to be Destroyed at Cleanup time obliterator.Add(part, &quot;Destroy&quot;); // Queue function to be called with `true` methodName obliterator.Add(print, true); // Close a thread. obliterator.Add(task.defer(() =&gt; { while (true) { print(&quot;Running!&quot;); task.wait(0.5); } }), true); // This implementation allows you to specify behavior for any object obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Cancel&quot;); // By passing an index, the object will occupy a namespace // If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Destroy&quot;, &quot;CurrentTween&quot;);   "},{"title":"AddObject​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#AddObject","content":"since v1.16.0 &lt;/&gt; Janitor:AddObject( constructor: {new: (A...) → T},-- The constructor for the object you want to add to the Janitor. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown,-- The index that can be used to clean up the object manually. ...: A...-- The arguments that will be passed to the constructor. ) → T-- The object that was passed as the first argument. Constructs an object for you and adds it to the Janitor. It's really just shorthand for Janitor:Add(object.new(), methodName, index). Luau: local obliterator = Janitor.new() local subObliterator = obliterator:AddObject(Janitor, &quot;Destroy&quot;) -- subObliterator is another Janitor! TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); const subObliterator = obliterator.AddObject(Janitor, &quot;Destroy&quot;);   "},{"title":"AddPromise​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#AddPromise","content":"&lt;/&gt; Janitor:AddPromise( promiseObject: Promise-- The promise you want to add to the Janitor. ) → Promise Adds a Promise to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled. Luau: local obliterator = Janitor.new() obliterator:AddPromise(Promise.delay(3)):andThenCall(print, &quot;Finished!&quot;):catch(warn) task.wait(1) obliterator:Cleanup() TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.AddPromise(Promise.delay(3)).andThenCall(print, &quot;Finished!&quot;).catch(warn); task.wait(1); obliterator.Cleanup();  "},{"title":"Errors","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor##","content":"Type\tDescriptionNotAPromiseError\tThrown if the promise is not a Promise.  "},{"title":"Remove​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Remove","content":"&lt;/&gt; Janitor:Remove( index: unknown-- The index you want to remove. ) → Janitor Cleans up whatever Object was set to this namespace by the 3rd parameter of Janitor.Add. Luau: local obliterator = Janitor.new() obliterator:Add(workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) obliterator:Remove(&quot;Baseplate&quot;) TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); obliterator.Remove(&quot;Baseplate&quot;);   "},{"title":"RemoveNoClean​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveNoClean( index: unknown-- The index you are removing. ) → Janitor Removes an object from the Janitor without running a cleanup. Luau local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed!&quot;) end, true, &quot;Function&quot;) obliterator:RemoveNoClean(&quot;Function&quot;) -- Does not print. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Function: () =&gt; void }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed!&quot;), true, &quot;Function&quot;); obliterator.RemoveNoClean(&quot;Function&quot;); // Does not print.   "},{"title":"RemoveList​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveList","content":"since v1.14.0 &lt;/&gt; Janitor:RemoveList( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot; TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOp = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOp, Two: NoOp, Three: NoOp }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot;   "},{"title":"RemoveListNoClean​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveListNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveListNoClean( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once without running their cleanup. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Nothing is printed. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOperation = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOperation, Two: NoOperation, Three: NoOperation }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Nothing is printed.   "},{"title":"Get​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Get","content":"&lt;/&gt; Janitor:Get( index: unknown-- The index that the object is stored under. ) → unknown?-- This will return the object if it is found, but it won't return anything if it doesn't exist. Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using __index. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:Get(&quot;Baseplate&quot;)) -- Returns Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.Get(&quot;Baseplate&quot;)); // Returns Baseplate.   "},{"title":"GetAll​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#GetAll","content":"since v1.15.1 &lt;/&gt; Janitor:GetAll() → {[any]: any} Returns a frozen copy of the Janitor's indices. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:GetAll().Baseplate) -- Prints Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.GetAll().Baseplate); // Prints Baseplate.   "},{"title":"Cleanup​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Cleanup","content":"&lt;/&gt; Janitor:Cleanup() → () Calls each object's methodName (or calls the object if methodName == true) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor object (so it can be used as a destructor callback). Luau: obliterator:Cleanup() -- Valid. obliterator() -- Also valid. TypeScript: obliterator.Cleanup() // TypeScript version doesn't support the __call method of cleaning.   "},{"title":"Destroy​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Destroy","content":"&lt;/&gt; Janitor:Destroy() → () Calls Janitor.Cleanup and renders the Janitor unusable. Metatable Removal Running this will make any further attempts to call a method of Janitor error.  "},{"title":"LinkToInstance​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#LinkToInstance","content":"&lt;/&gt; Janitor:LinkToInstance( object: Instance ,-- The instance you want to link the Janitor to. allowMultiple?: boolean-- Whether or not to allow multiple links on the same Janitor. ) → RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance. &quot;Links&quot; this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroy()d and garbage collected. A Janitor may only be linked to one instance at a time, unless allowMultiple is true. When called with a truthy allowMultiple parameter, the Janitor will &quot;link&quot; the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy allowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy allowMultiple parameter, if applicable. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Cleaning up!&quot;) end, true) do local folder = Instance.new(&quot;Folder&quot;) obliterator:LinkToInstance(folder) folder:Destroy() end TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.Add(() =&gt; print(&quot;Cleaning up!&quot;), true); { const folder = new Instance(&quot;Folder&quot;); obliterator.LinkToInstance(folder, false); folder.Destroy(); }   "},{"title":"LinkToInstances​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#LinkToInstances","content":"&lt;/&gt; Janitor:LinkToInstances( ...: Instance -- All the Instances you want linked. ) → Janitor-- A new Janitor that can be used to manually disconnect all LinkToInstances. Links several instances to a new Janitor, which is then returned. "},{"title":"TableManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#types","content":" "},{"title":"CanBeArray<T>​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#CanBeArray<T>","content":"&lt;/&gt; type CanBeArray&lt;T&gt; = T | {T} A type that could be an individual of the type or an array of the type.  "},{"title":"Path​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Path","content":"&lt;/&gt; type Path = string | {any} A path to a value in a table. Can be written as a string in dot format or an array of strings. :::Note The array format is faster to parse and should be used when possible. ::: local tbl = { MyPath = { To = { Value = 0; }; }; } local path1: Path = &quot;MyPath.To.Value&quot; -- Style 1 local path2: Path = {&quot;MyPath&quot;, &quot;To&quot;, &quot;Value&quot;} -- Style 2   "},{"title":"ValueListenerFn​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ValueListenerFn","content":"&lt;/&gt; type ValueListenerFn = ( newValue: any, oldValue: any?, changeMetadata: ChangeMetadata? ) → ()   "},{"title":"ListenerType​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenerType","content":"&lt;/&gt; type ListenerType = &quot;ValueChanged&quot; | &quot;ArraySet&quot; | &quot;ArrayInsert&quot; | &quot;ArrayRemove&quot; This information is mostly for internal use.  "},{"title":"DataChangeSource​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#DataChangeSource","content":"&lt;/&gt; type DataChangeSource = &quot;self&quot; | &quot;child&quot; | &quot;parent&quot; This information is mostly for internal use.  "},{"title":"ChangeMetadata​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ChangeMetadata","content":"&lt;/&gt; interface ChangeMetadata { ListenerType: ListenerType-- The listener type that was fired. SourceDirection: DataChangeSource-- The source direction of the change. SourcePath: {string}-- The origin path of the change. NewValue: any?-- [Only for value changes] The new value. OldValue: any?-- [Only for value changes] The old value. } Metadata about the change that fired a listener. Used to provide more context to listeners. Allows you to figure out where the change came from, if it wasnt a direct change.  "},{"title":"CanBeArray<T>​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#CanBeArray<T>","content":"&lt;/&gt; type CanBeArray&lt;T&gt; = T | {T} A type that could be an individual of the type or an array of the type.  "},{"title":"Path​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Path","content":"&lt;/&gt; type Path = string | {any} A path to a value in a table. Can be written as a string in dot format or an array of strings. :::Note The array format is faster to parse and should be used when possible. ::: local tbl = { MyPath = { To = { Value = 0; }; }; } local path1: Path = &quot;MyPath.To.Value&quot; -- Style 1 local path2: Path = {&quot;MyPath&quot;, &quot;To&quot;, &quot;Value&quot;} -- Style 2   "},{"title":"ValueListenerFn​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ValueListenerFn","content":"&lt;/&gt; type ValueListenerFn = ( newValue: any, oldValue: any?, changeMetadata: ChangeMetadata? ) → ()   "},{"title":"ListenerType​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenerType","content":"&lt;/&gt; type ListenerType = &quot;ValueChanged&quot; | &quot;ArraySet&quot; | &quot;ArrayInsert&quot; | &quot;ArrayRemove&quot; This information is mostly for internal use.  "},{"title":"DataChangeSource​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#DataChangeSource","content":"&lt;/&gt; type DataChangeSource = &quot;self&quot; | &quot;child&quot; | &quot;parent&quot; This information is mostly for internal use.  "},{"title":"ChangeMetadata​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ChangeMetadata","content":"&lt;/&gt; interface ChangeMetadata { ListenerType: ListenerType-- The listener type that was fired. SourceDirection: DataChangeSource-- The source direction of the change. SourcePath: {string}-- The origin path of the change. NewValue: any?-- [Only for value changes] The new value. OldValue: any?-- [Only for value changes] The old value. } Metadata about the change that fired a listener. Used to provide more context to listeners. Allows you to figure out where the change came from, if it wasnt a direct change. "},{"title":"Properties​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Enums","content":"&lt;/&gt; TableManager.Enums: { ListenerType: ListenerTypeEnum, DataChangeSource: DataChangeSourceEnum } A collection of enums used by the TableManager.  "},{"title":"Enums​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Enums","content":"&lt;/&gt; TableManager.Enums: { ListenerType: ListenerTypeEnum, DataChangeSource: DataChangeSourceEnum } A collection of enums used by the TableManager. "},{"title":"Functions​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#new","content":"Constructor &lt;/&gt; TableManager.new(data: table?) → TableManager Creates a new TableManager. Takes a table to manage, if one is not given then it will construct an empty table. Modifying the given table Once you give a table to a TableManager, you should never modify it directly. Doing so can result in the TableManager being unable to properly track changes and potentially cause data desyncs. Key/Value Rules The given table's keys should follow these rules: No Mixed Tables (Tables containing keys of different datatypes) Avoid using tables as keys. Keys must not contain periods. Keys must not be empty strings. Tables/Arrays should be assigned to only one key. (No shared references as this can cause desyncs) Nested tables/arrays should not be given to other TableManager instances. (Can cause desyncs) info Only one TableManager should be created for a given table. Attempting to create a TableManager for a table that is already being managed will return the existing TableManager. Call metamethod You can call the TableManager class to create a new instance of it. TableManager() is equivalent to TableManager.new(). local manager = TableManager { Coins = 0; Title = &quot;Knight&quot;; }   "},{"title":"new​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#new","content":"Constructor &lt;/&gt; TableManager.new(data: table?) → TableManager Creates a new TableManager. Takes a table to manage, if one is not given then it will construct an empty table. Modifying the given table Once you give a table to a TableManager, you should never modify it directly. Doing so can result in the TableManager being unable to properly track changes and potentially cause data desyncs. Key/Value Rules The given table's keys should follow these rules: No Mixed Tables (Tables containing keys of different datatypes) Avoid using tables as keys. Keys must not contain periods. Keys must not be empty strings. Tables/Arrays should be assigned to only one key. (No shared references as this can cause desyncs) Nested tables/arrays should not be given to other TableManager instances. (Can cause desyncs) info Only one TableManager should be created for a given table. Attempting to create a TableManager for a table that is already being managed will return the existing TableManager. Call metamethod You can call the TableManager class to create a new instance of it. TableManager() is equivalent to TableManager.new(). local manager = TableManager { Coins = 0; Title = &quot;Knight&quot;; }   "},{"title":"Destroy​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Destroy","content":"&lt;/&gt; TableManager:Destroy() → () Disconnects any listeners and removes the table from the managed tables.  "},{"title":"Get​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Get","content":"&lt;/&gt; TableManager:Get( path: Path, idx: (number | string)? ) → any Fetches the value at the given path. Accepts a string path or an array path. Accepts an optional secondary argument to fetch a value at an index in an array. Aliases: GetValue local manager = TableManager.new({ Currency = { Coins = 100; Gems = 10; }; }) -- The following are all equivalent acceptable methods of fetching the value. print(manager:Get(&quot;Currency.Coins&quot;)) -- 100 print(manager:Get({&quot;Currency&quot;, &quot;Coins&quot;})) -- 100 print(manager:Get().Currency.Coins) -- 100 Getting the Root Table Calling :Get() with no arguments, an empty string, or an empty table will return the root table.  "},{"title":"Set​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Set","content":"&lt;/&gt; TableManager:Set( path: Path, ...: any ) → () Sets the value at the given path to the given value. :Set acts as a combined function for :SetValue and :ArraySet. :Set(myPathToValue, newValue) :Set(myPathToArray, index, newValue) Overwriting the root table Overwriting the root table is not recommended, but is technically possible by giving an empty table or string as a Path. Doing so has not been tested in depth and may result in unintended behavior. Setting array values You cannot set values to nil in an array with this method due to the way it parses args. Use ArraySet instead if you need to set values to nil.  "},{"title":"Increment​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Increment","content":"&lt;/&gt; TableManager:Increment( path: Path, ...: any ) → number? Increments the value at the given path by the given amount. If the value is not a number, it will throw an error. :Increment acts as a combined function for :IncrementValue and :ArrayIncrement. :Increment(myPathToValue, amountToIncrementBy) :Increment(myPathToArray, index, amountToIncrementBy)   "},{"title":"Update​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Update","content":"&lt;/&gt; TableManager:Update( path: Path, ...: any ) → any? Mutates the value at the given path by calling the given function with the current value. :Update(myPathToValue, function(currentValue) return currentValue + 1 end) Aliases :Mutate is an alias for :Update. This alias is consistent with all other 'Update' methods.  "},{"title":"SetValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetValue","content":"&lt;/&gt; TableManager:SetValue( path: Path, value: any ) → boolean Sets the value at the given path to the given value. This will fire the ValueChanged signal if the value is different. Returns a boolean indicating whether or not the value was changed. local didChange = manager:SetValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"IncrementValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#IncrementValue","content":"&lt;/&gt; TableManager:IncrementValue( path: Path, amount: Numeric ) → number Increments the value at the given path by the given amount. If the value at the path or the given amount is not a number, it will throw an error. Returns the newly incremeneted value. local newValue = manager:IncrementValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"UpdateValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#UpdateValue","content":"&lt;/&gt; TableManager:UpdateValue( path: Path, fn: (currentValue: any) → (any) ) → any Mutates the value at the given path by calling the given function with the current value. The function should return the new value. manager:SetValue(&quot;MyPath.To.Value&quot;, &quot;Hello World&quot;) local newValue = manager:UpdateValue(&quot;MyPath.To.Value&quot;, function(currentValue) return string.upper(currentValue) .. &quot;!&quot; end) print(newValue) -- HELLO WORLD! print(manager:GetValue(&quot;MyPath.To.Value&quot;)) -- HELLO WORLD!   "},{"title":"SetManyValues​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetManyValues","content":"&lt;/&gt; TableManager:SetManyValues( path: Path, valueDict: {[any]: any} ) → () Sets the values at the given path to the given values. This will fire the ValueChanged listener for each value that is different. caution Uses pairs to check through the given table and thus Does not support setting values to nil. local manager = TableManager.new({ Foo = { Bar = { Value1 = 0; Value2 = 0; Value3 = 0; }; }; }) manager:SetManyValues(&quot;Foo.Bar&quot;, { Value1 = 100; Value3 = 300; })   "},{"title":"ArrayUpdate​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayUpdate","content":"&lt;/&gt; TableManager:ArrayUpdate( path: Path,-- The path to the array to mutate. index: number | {number} | &quot;#&quot;,-- The index or indices to mutate. If &quot;#&quot; is given, it will mutate all indices. fn: (currentValue: any) → (any)-- The function to call with the current value. Should return the new value. ) → () Mutates an index or indices in the array at the given path by calling the given function with the current value. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayUpdate(&quot;MyArray&quot;, 3, function(currentValue) return currentValue * 2 }) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 6, 4, 5}   "},{"title":"ArrayIncrement​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayIncrement","content":"&lt;/&gt; TableManager:ArrayIncrement( path: Path,-- The path to the array to increment. index: number | {number},-- The index or indices to increment. amount: number?-- The amount to increment by. If not given, it will increment by 1. ) → () Increments the indices at the given path by the given amount. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayIncrement(&quot;MyArray&quot;, 3, 10) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 13, 4, 5}   "},{"title":"ArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArraySet","content":"&lt;/&gt; TableManager:ArraySet( path: Path, index: (CanBeArray&lt;number&gt; | '#')?, value: any ) → () Sets the value at the given index in the array at the given path. The index can be a number or an array of numbers. If an array is given then the value will be set at each of those indices in the array.  "},{"title":"ArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayInsert","content":"&lt;/&gt; TableManager:ArrayInsert( path: Path, ...: any ) → () Inserts the given value into the array at the given path at the given index. If no index is given, it will insert at the end of the array. This follows the convention of table.insert where the index is given in the middle only if there are 3 args. x:ArrayInsert(&quot;MyArray&quot;, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at index 1 x:ArrayInsert(&quot;MyArray&quot;, 1) -- appends 1 to the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, 2) -- Inserts 2 at index 1   "},{"title":"ArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemove","content":"&lt;/&gt; TableManager:ArrayRemove( path: Path, index: number? ) → any Removes the value at the given index from the array at the given path. If no index is given, it will remove the last value in the array. Returns the value that was removed if one was.  "},{"title":"ArrayRemoveFirstValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemoveFirstValue","content":"&lt;/&gt; TableManager:ArrayRemoveFirstValue( path: Path, value: any ) → number? Removes the first instance of the given value from the array at the given path. Returns a number indicating the index that it was was removed from if one was.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ToFusionState","content":"&lt;/&gt; TableManager:ToFusionState(path: Path) → FusionState&lt;any&gt; Returns a Fusion State object that is bound to the value at the given path. This method is memoized so calling it repeatedly with the same path will return the same State object and quickly. local path = &quot;MyPath.To.Value&quot; manager:SetValue(path, 100) local state = manager:ToFusionState(path) print(peek(state)) -- 100 manager:SetValue(path, 200) task.wait() -- If your signals are deffered then the state will update on the next frame print(peek(state)) -- 200 Deffered Signals The value of the Fusion State object is updated via the ValueChanged listener and thus may be deffered if your signals are deffered. Setting Although this currently returns a Fusion Value object, it is not recommended to set the value as this may be a Computed in the future. Setting the state will not actually change the value in the TableManager. Version This method uses Fusion 0.3.0 internally so it may not work with older versions.  "},{"title":"PromiseValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#PromiseValue","content":"&lt;/&gt; TableManager:PromiseValue( path: Path, condition: (value: any?) → (boolean) ) → Promise Creates a promise that resolves when the given condition is met. The condition is immediately and every time the value changes. If no condition is given then it will resolve with the current value unless it is nil, in which case it will resolve on the first change.  "},{"title":"Observe​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Observe","content":"&lt;/&gt; TableManager:Observe( path: Path,-- The path to the value to observe. fn: ValueListenerFn,-- The function to call when the value changes. runOnNil: boolean?-- Whether or not to fire the function when the value is nil. ) → Connection-- A connection used to disconnect the listener. Observes a value at a path and calls the function immediately with the current value, as well as when it changes. Listening to nil values It will NOT fire if the new/starting value is nil, unless runOnNil is true. When it changes from nil, the oldValue will be the last known non nil value. The binding call of the function is an exception and will give nil as the oldValue. This is done so that Observe can be used to execute instructions when a value is percieved as 'ready'. local path = &quot;MyPath.To.Value&quot; local connection = manager:Observe(path, function(newValue) print(&quot;Value at&quot;, path, &quot;is&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"OnKeyChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyChange","content":"&lt;/&gt; TableManager:OnKeyChange( parentPath: Path?, fn: ( keyChanged: any, newValue: any, oldValue: any ) → () ) → () Listens to a change at a specified path and calls the function when the value changes. manager:Set(&quot;Stats&quot;, { Health = 100; Mana = 50; }) local connection = manager:ListenToKeyChange(&quot;Stats&quot;, function(key, newValue) print(`{key} changed to {newValue}`) end) manager:SetValue(&quot;Stats.Health&quot;, 200) -- Health changed to 200 manager:SetValue(&quot;Stats.Mana&quot;, 100) -- Mana changed to 100   "},{"title":"OnKeyAdd​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyAdd","content":"&lt;/&gt; TableManager:OnKeyAdd( parentPath: Path?, fn: ( newKey: any, newValue: any ) → () ) → Connection Listens to when a new key is added (Changed from nil) to a table at a specified path and calls the function.  "},{"title":"OnKeyRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyRemove","content":"&lt;/&gt; TableManager:OnKeyRemove( parentPath: Path?, fn: ( removedKey: any, lastValue: any ) → () ) → Connection Listens to when a key is removed (Set to nil) from a table at a specified path and calls the function.  "},{"title":"OnValueChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnValueChange","content":"&lt;/&gt; TableManager:OnValueChange( path: Path, fn: ValueListenerFn ) → Connection Listens to a change at a specified path and calls the function when the value changes. This does NOT fire when the value is an array/dictionary and one of its children changes. local connection = manager:OnValueChange(&quot;MyPath.To.Value&quot;, function(newValue, oldValue) print(&quot;Value changed from&quot;, oldValue, &quot;to&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"OnArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArraySet","content":"&lt;/&gt; TableManager:OnArraySet( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when an index is set in an array at a specified path and calls the function. The function receives the index and the new value. caution The array listeners do not fire from changes to parent or child values.  "},{"title":"OnArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArrayInsert","content":"&lt;/&gt; TableManager:OnArrayInsert( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when a value is inserted into an array at a specified path and calls the function when the value changes.  "},{"title":"OnArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArrayRemove","content":"&lt;/&gt; TableManager:OnArrayRemove( path: Path, fn: ( oldIndex: number, oldValue: any ) → () ) → Connection Listens to when a value is removed from an array at a specified path and calls the function.  "},{"title":"Destroy​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Destroy","content":"&lt;/&gt; TableManager:Destroy() → () Disconnects any listeners and removes the table from the managed tables.  "},{"title":"Get​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Get","content":"&lt;/&gt; TableManager:Get( path: Path, idx: (number | string)? ) → any Fetches the value at the given path. Accepts a string path or an array path. Accepts an optional secondary argument to fetch a value at an index in an array. Aliases: GetValue local manager = TableManager.new({ Currency = { Coins = 100; Gems = 10; }; }) -- The following are all equivalent acceptable methods of fetching the value. print(manager:Get(&quot;Currency.Coins&quot;)) -- 100 print(manager:Get({&quot;Currency&quot;, &quot;Coins&quot;})) -- 100 print(manager:Get().Currency.Coins) -- 100 Getting the Root Table Calling :Get() with no arguments, an empty string, or an empty table will return the root table.  "},{"title":"Set​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Set","content":"&lt;/&gt; TableManager:Set( path: Path, ...: any ) → () Sets the value at the given path to the given value. :Set acts as a combined function for :SetValue and :ArraySet. :Set(myPathToValue, newValue) :Set(myPathToArray, index, newValue) Overwriting the root table Overwriting the root table is not recommended, but is technically possible by giving an empty table or string as a Path. Doing so has not been tested in depth and may result in unintended behavior. Setting array values You cannot set values to nil in an array with this method due to the way it parses args. Use ArraySet instead if you need to set values to nil.  "},{"title":"Increment​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Increment","content":"&lt;/&gt; TableManager:Increment( path: Path, ...: any ) → number? Increments the value at the given path by the given amount. If the value is not a number, it will throw an error. :Increment acts as a combined function for :IncrementValue and :ArrayIncrement. :Increment(myPathToValue, amountToIncrementBy) :Increment(myPathToArray, index, amountToIncrementBy)   "},{"title":"Update​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Update","content":"&lt;/&gt; TableManager:Update( path: Path, ...: any ) → any? Mutates the value at the given path by calling the given function with the current value. :Update(myPathToValue, function(currentValue) return currentValue + 1 end) Aliases :Mutate is an alias for :Update. This alias is consistent with all other 'Update' methods.  "},{"title":"SetValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetValue","content":"&lt;/&gt; TableManager:SetValue( path: Path, value: any ) → boolean Sets the value at the given path to the given value. This will fire the ValueChanged signal if the value is different. Returns a boolean indicating whether or not the value was changed. local didChange = manager:SetValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"IncrementValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#IncrementValue","content":"&lt;/&gt; TableManager:IncrementValue( path: Path, amount: Numeric ) → number Increments the value at the given path by the given amount. If the value at the path or the given amount is not a number, it will throw an error. Returns the newly incremeneted value. local newValue = manager:IncrementValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"UpdateValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#UpdateValue","content":"&lt;/&gt; TableManager:UpdateValue( path: Path, fn: (currentValue: any) → (any) ) → any Mutates the value at the given path by calling the given function with the current value. The function should return the new value. manager:SetValue(&quot;MyPath.To.Value&quot;, &quot;Hello World&quot;) local newValue = manager:UpdateValue(&quot;MyPath.To.Value&quot;, function(currentValue) return string.upper(currentValue) .. &quot;!&quot; end) print(newValue) -- HELLO WORLD! print(manager:GetValue(&quot;MyPath.To.Value&quot;)) -- HELLO WORLD!   "},{"title":"SetManyValues​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetManyValues","content":"&lt;/&gt; TableManager:SetManyValues( path: Path, valueDict: {[any]: any} ) → () Sets the values at the given path to the given values. This will fire the ValueChanged listener for each value that is different. caution Uses pairs to check through the given table and thus Does not support setting values to nil. local manager = TableManager.new({ Foo = { Bar = { Value1 = 0; Value2 = 0; Value3 = 0; }; }; }) manager:SetManyValues(&quot;Foo.Bar&quot;, { Value1 = 100; Value3 = 300; })   "},{"title":"ArrayUpdate​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayUpdate","content":"&lt;/&gt; TableManager:ArrayUpdate( path: Path,-- The path to the array to mutate. index: number | {number} | &quot;#&quot;,-- The index or indices to mutate. If &quot;#&quot; is given, it will mutate all indices. fn: (currentValue: any) → (any)-- The function to call with the current value. Should return the new value. ) → () Mutates an index or indices in the array at the given path by calling the given function with the current value. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayUpdate(&quot;MyArray&quot;, 3, function(currentValue) return currentValue * 2 }) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 6, 4, 5}   "},{"title":"ArrayIncrement​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayIncrement","content":"&lt;/&gt; TableManager:ArrayIncrement( path: Path,-- The path to the array to increment. index: number | {number},-- The index or indices to increment. amount: number?-- The amount to increment by. If not given, it will increment by 1. ) → () Increments the indices at the given path by the given amount. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayIncrement(&quot;MyArray&quot;, 3, 10) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 13, 4, 5}   "},{"title":"ArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArraySet","content":"&lt;/&gt; TableManager:ArraySet( path: Path, index: (CanBeArray&lt;number&gt; | '#')?, value: any ) → () Sets the value at the given index in the array at the given path. The index can be a number or an array of numbers. If an array is given then the value will be set at each of those indices in the array.  "},{"title":"ArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayInsert","content":"&lt;/&gt; TableManager:ArrayInsert( path: Path, ...: any ) → () Inserts the given value into the array at the given path at the given index. If no index is given, it will insert at the end of the array. This follows the convention of table.insert where the index is given in the middle only if there are 3 args. x:ArrayInsert(&quot;MyArray&quot;, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at index 1 x:ArrayInsert(&quot;MyArray&quot;, 1) -- appends 1 to the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, 2) -- Inserts 2 at index 1   "},{"title":"ArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemove","content":"&lt;/&gt; TableManager:ArrayRemove( path: Path, index: number? ) → any Removes the value at the given index from the array at the given path. If no index is given, it will remove the last value in the array. Returns the value that was removed if one was.  "},{"title":"ArrayRemoveFirstValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemoveFirstValue","content":"&lt;/&gt; TableManager:ArrayRemoveFirstValue( path: Path, value: any ) → number? Removes the first instance of the given value from the array at the given path. Returns a number indicating the index that it was was removed from if one was.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ToFusionState","content":"&lt;/&gt; TableManager:ToFusionState(path: Path) → FusionState&lt;any&gt; Returns a Fusion State object that is bound to the value at the given path. This method is memoized so calling it repeatedly with the same path will return the same State object and quickly. local path = &quot;MyPath.To.Value&quot; manager:SetValue(path, 100) local state = manager:ToFusionState(path) print(peek(state)) -- 100 manager:SetValue(path, 200) task.wait() -- If your signals are deffered then the state will update on the next frame print(peek(state)) -- 200 Deffered Signals The value of the Fusion State object is updated via the ValueChanged listener and thus may be deffered if your signals are deffered. Setting Although this currently returns a Fusion Value object, it is not recommended to set the value as this may be a Computed in the future. Setting the state will not actually change the value in the TableManager. Version This method uses Fusion 0.3.0 internally so it may not work with older versions.  "},{"title":"PromiseValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#PromiseValue","content":"&lt;/&gt; TableManager:PromiseValue( path: Path, condition: (value: any?) → (boolean) ) → Promise Creates a promise that resolves when the given condition is met. The condition is immediately and every time the value changes. If no condition is given then it will resolve with the current value unless it is nil, in which case it will resolve on the first change.  "},{"title":"Observe​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Observe","content":"&lt;/&gt; TableManager:Observe( path: Path,-- The path to the value to observe. fn: ValueListenerFn,-- The function to call when the value changes. runOnNil: boolean?-- Whether or not to fire the function when the value is nil. ) → Connection-- A connection used to disconnect the listener. Observes a value at a path and calls the function immediately with the current value, as well as when it changes. Listening to nil values It will NOT fire if the new/starting value is nil, unless runOnNil is true. When it changes from nil, the oldValue will be the last known non nil value. The binding call of the function is an exception and will give nil as the oldValue. This is done so that Observe can be used to execute instructions when a value is percieved as 'ready'. local path = &quot;MyPath.To.Value&quot; local connection = manager:Observe(path, function(newValue) print(&quot;Value at&quot;, path, &quot;is&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"OnKeyChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyChange","content":"&lt;/&gt; TableManager:OnKeyChange( parentPath: Path?, fn: ( keyChanged: any, newValue: any, oldValue: any ) → () ) → () Listens to a change at a specified path and calls the function when the value changes. manager:Set(&quot;Stats&quot;, { Health = 100; Mana = 50; }) local connection = manager:ListenToKeyChange(&quot;Stats&quot;, function(key, newValue) print(`{key} changed to {newValue}`) end) manager:SetValue(&quot;Stats.Health&quot;, 200) -- Health changed to 200 manager:SetValue(&quot;Stats.Mana&quot;, 100) -- Mana changed to 100   "},{"title":"OnKeyAdd​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyAdd","content":"&lt;/&gt; TableManager:OnKeyAdd( parentPath: Path?, fn: ( newKey: any, newValue: any ) → () ) → Connection Listens to when a new key is added (Changed from nil) to a table at a specified path and calls the function.  "},{"title":"OnKeyRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyRemove","content":"&lt;/&gt; TableManager:OnKeyRemove( parentPath: Path?, fn: ( removedKey: any, lastValue: any ) → () ) → Connection Listens to when a key is removed (Set to nil) from a table at a specified path and calls the function.  "},{"title":"OnValueChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnValueChange","content":"&lt;/&gt; TableManager:OnValueChange( path: Path, fn: ValueListenerFn ) → Connection Listens to a change at a specified path and calls the function when the value changes. This does NOT fire when the value is an array/dictionary and one of its children changes. local connection = manager:OnValueChange(&quot;MyPath.To.Value&quot;, function(newValue, oldValue) print(&quot;Value changed from&quot;, oldValue, &quot;to&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"OnArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArraySet","content":"&lt;/&gt; TableManager:OnArraySet( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when an index is set in an array at a specified path and calls the function. The function receives the index and the new value. caution The array listeners do not fire from changes to parent or child values.  "},{"title":"OnArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArrayInsert","content":"&lt;/&gt; TableManager:OnArrayInsert( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when a value is inserted into an array at a specified path and calls the function when the value changes.  "},{"title":"OnArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArrayRemove","content":"&lt;/&gt; TableManager:OnArrayRemove( path: Path, fn: ( oldIndex: number, oldValue: any ) → () ) → Connection Listens to when a value is removed from an array at a specified path and calls the function. "},{"title":"Promise","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Promise","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#types","content":" "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#Status","content":"enum &lt;/&gt; interface Status { Started: &quot;Started&quot;-- The Promise is executing, and not settled yet. Resolved: &quot;Resolved&quot;-- The Promise finished successfully. Rejected: &quot;Rejected&quot;-- The Promise was rejected. Cancelled: &quot;Cancelled&quot;-- The Promise was cancelled before it finished. } An enum value used to represent the Promise's status.  "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#Status","content":"enum &lt;/&gt; interface Status { Started: &quot;Started&quot;-- The Promise is executing, and not settled yet. Resolved: &quot;Resolved&quot;-- The Promise finished successfully. Rejected: &quot;Rejected&quot;-- The Promise was rejected. Cancelled: &quot;Cancelled&quot;-- The Promise was cancelled before it finished. } An enum value used to represent the Promise's status.  "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#Status","content":"enum &lt;/&gt; interface Status { Started: &quot;Started&quot;-- The Promise is executing, and not settled yet. Resolved: &quot;Resolved&quot;-- The Promise finished successfully. Rejected: &quot;Rejected&quot;-- The Promise was rejected. Cancelled: &quot;Cancelled&quot;-- The Promise was cancelled before it finished. } An enum value used to represent the Promise's status. "},{"title":"Properties​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#properties","content":" "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#Status","content":"This item is read only and cannot be modified. Read Only enums &lt;/&gt; Promise.Status: Status A table containing all members of the Status enum, e.g., Promise.Status.Resolved.  "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#Status","content":"This item is read only and cannot be modified. Read Only enums &lt;/&gt; Promise.Status: Status A table containing all members of the Status enum, e.g., Promise.Status.Resolved.  "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#Status","content":"This item is read only and cannot be modified. Read Only enums &lt;/&gt; Promise.Status: Status A table containing all members of the Status enum, e.g., Promise.Status.Resolved. "},{"title":"Functions​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#new","content":"&lt;/&gt; Promise.new(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise Construct a new Promise that will be resolved or rejected with the given callbacks. If you resolve with a Promise, it will be chained onto. You can safely yield within the executor function and it will not block the creating thread. local myFunction() return Promise.new(function(resolve, reject, onCancel) wait(1) resolve(&quot;Hello world!&quot;) end) end myFunction():andThen(print) You do not need to use pcall within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If error() is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into Promise.Error(Promise.Error.Kind.ExecutionError) objects for tracking debug information. You may register an optional cancellation hook by using the onCancel argument: This should be used to abort any ongoing operations leading up to the promise being settled. Call the onCancel function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled. onCancel returns true if the Promise was already cancelled when you called onCancel. Calling onCancel with no argument will not override a previously set cancellation hook, but it will still return true if the Promise is currently cancelled. You can set the cancellation hook at any time before resolving. When a promise is cancelled, calls to resolve or reject will be ignored, regardless of if you set a cancellation hook or not. caution If the Promise is cancelled, the executor thread is closed with coroutine.close after the cancellation hook is called. You must perform any cleanup code in the cancellation hook: any time your executor yields, it may never resume.  "},{"title":"defer​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#defer","content":"&lt;/&gt; Promise.defer(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise The same as Promise.new, except execution begins after the next Heartbeat event. This is a spiritual replacement for spawn, but it does not suffer from the same issues as spawn. local function waitForChild(instance, childName, timeout) return Promise.defer(function(resolve, reject) local child = instance:WaitForChild(childName, timeout) ;(child and resolve or reject)(child) end) end   "},{"title":"resolve​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#resolve","content":"&lt;/&gt; Promise.resolve(...: any) → Promise&lt;...any&gt; Creates an immediately resolved Promise with the given value. -- Example using Promise.resolve to deliver cached values: function getSomething(name) if cache[name] then return Promise.resolve(cache[name]) else return Promise.new(function(resolve, reject) local thing = getTheThing() cache[name] = thing resolve(thing) end) end end   "},{"title":"reject​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#reject","content":"&lt;/&gt; Promise.reject(...: any) → Promise&lt;...any&gt; Creates an immediately rejected Promise with the given value. caution Something needs to consume this rejection (i.e. :catch() it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.  "},{"title":"try​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#try","content":"&lt;/&gt; Promise.try( callback: (...: T...) → ...any, ...: T...-- Additional arguments passed to callback ) → Promise Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback. info Promise.try is similar to Promise.promisify, except the callback is invoked immediately instead of returning a new function. Promise.try(function() return math.random(1, 2) == 1 and &quot;ok&quot; or error(&quot;Oh an error!&quot;) end) :andThen(function(text) print(text) end) :catch(function(err) warn(&quot;Something went wrong&quot;) end)   "},{"title":"all​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#all","content":"&lt;/&gt; Promise.all(promises: {Promise&lt;T&gt;}) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a new promise that: is resolved after all input promises resolve. is rejected if any input promises reject. info Only the first return value from each promise will be present in the resulting array. After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.all(promises)   "},{"title":"fold​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#fold","content":"since v3.1.0 &lt;/&gt; Promise.fold( list: {T | Promise&lt;T&gt;}, reducer: ( accumulator: U, value: T, index: number ) → U | Promise&lt;U&gt;, initialValue: U ) → () Folds an array of values or promises into a single value. The array is traversed sequentially. The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value. The folding will stop at the first rejection encountered. local basket = {&quot;blueberry&quot;, &quot;melon&quot;, &quot;pear&quot;, &quot;melon&quot;} Promise.fold(basket, function(cost, fruit) if fruit == &quot;blueberry&quot; then return cost -- blueberries are free! else -- call a function that returns a promise with the fruit price return fetchPrice(fruit):andThen(function(fruitCost) return cost + fruitCost end) end end, 0)   "},{"title":"some​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#some","content":"&lt;/&gt; Promise.some( promises: {Promise&lt;T&gt;}, count: number ) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as count Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers. count 0 results in an empty array. The resultant array will never have more than count elements. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve   "},{"title":"any​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#any","content":"&lt;/&gt; Promise.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as any of the input Promises resolves. It will reject only if all input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers. Resolves directly with the value of the first resolved Promise. This is essentially [Promise.some] with 1 count, except the Promise resolves with the value directly instead of an array with one element. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)   "},{"title":"allSettled​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#allSettled","content":"&lt;/&gt; Promise.allSettled(promises: {Promise&lt;T&gt;}) → Promise&lt;{Status}&gt; Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping promise:finally over the array of Promises. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.allSettled(promises)   "},{"title":"race​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#race","content":"&lt;/&gt; Promise.race(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects. warning If the first Promise to settle from the array settles with a rejection, the resulting Promise from race will reject. If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use Promise.any or Promise.some instead. All other Promises that don't win the race will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.race(promises) -- Only returns 1st value to resolve or reject   "},{"title":"each​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#each","content":"since 3.0.0 &lt;/&gt; Promise.each( list: {T | Promise&lt;T&gt;}, predicate: ( value: T, index: number ) → U | Promise&lt;U&gt; ) → Promise&lt;{U}&gt; Iterates serially over the given an array of values, calling the predicate callback on each value before continuing. If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item in the array. info Promise.each is similar to Promise.all, except the Promises are ran in order instead of all at once. But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time. The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value. Promise.each({ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot; }, function(value, index) return Promise.delay(1):andThen(function() print((&quot;%d) Got %s!&quot;):format(index, value)) end) end) --[[ (1 second passes) &gt; 1) Got foo! (1 second passes) &gt; 2) Got bar! (1 second passes) &gt; 3) Got baz! (1 second passes) &gt; 4) Got qux! ]] If the Promise a predicate returns rejects, the Promise from Promise.each is also rejected with the same value. If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value. If a Promise in the array of values is already Rejected when Promise.each is called, Promise.each rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when Promise.each is called, Promise.each rejects with Promise.Error(Promise.Error.Kind.AlreadyCancelled). If a Promise in the array of values is Started at first, but later rejects, Promise.each will reject with that value and iteration will not continue once iteration encounters that value. Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values. If this Promise returned from Promise.each rejects or is cancelled for any reason, the following are true: Iteration will not continue. Any Promises within the array of values will now be cancelled if they have no other consumers. The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.  "},{"title":"is​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#is","content":"&lt;/&gt; Promise.is(object: any) → boolean-- true if the given object is a Promise. Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an andThen method.  "},{"title":"promisify​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#promisify","content":"&lt;/&gt; Promise.promisify(callback: (...: any) → ...any) → (...: any) → Promise Wraps a function that yields into one that returns a Promise. Any errors that occur while executing the function will be turned into rejections. info Promise.promisify is similar to Promise.try, except the callback is returned as a callable function instead of being invoked immediately. local sleep = Promise.promisify(wait) sleep(1):andThen(print) local isPlayerInGroup = Promise.promisify(function(player, groupId) return player:IsInGroup(groupId) end)   "},{"title":"delay​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#delay","content":"&lt;/&gt; Promise.delay(seconds: number) → Promise&lt;number&gt; Returns a Promise that resolves after seconds seconds have passed. The Promise resolves with the actual amount of time that was waited. This function is not a wrapper around wait. Promise.delay uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler. warning Passing NaN, infinity, or a number less than 1/60 is equivalent to passing 1/60. Promise.delay(5):andThenCall(print, &quot;This prints after 5 seconds&quot;)   "},{"title":"retry​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#retry","content":"since 3.0.0 &lt;/&gt; Promise.retry( callback: (...: P) → Promise&lt;T&gt;, times: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise. local function canFail(a, b, c) return Promise.new(function(resolve, reject) -- do something that can fail local failed, thing = doSomethingThatCanFail(a, b, c) if failed then reject(&quot;it failed&quot;) else resolve(thing) end end) end local MAX_RETRIES = 10 local value = Promise.retry(canFail, MAX_RETRIES, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) -- args to send to canFail   "},{"title":"retryWithDelay​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#retryWithDelay","content":"since v3.2.0 &lt;/&gt; Promise.retryWithDelay( callback: (...: P) → Promise&lt;T&gt;, times: number, seconds: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, waiting seconds seconds between each retry, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise.  "},{"title":"fromEvent​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#fromEvent","content":"since 3.0.0 &lt;/&gt; Promise.fromEvent( event: Event,-- Any object with a Connect method. This includes all Roblox events. predicate?: (...: P) → boolean-- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again. ) → Promise&lt;P&gt; Converts an event into a Promise which resolves the next time the event fires. The optional predicate callback, if passed, will receive the event arguments and should return true or false, based on if this fired event should resolve the Promise or not. If true, the Promise resolves. If false, nothing happens and the predicate will be rerun the next time the event fires. The Promise will resolve with the event arguments. tip This function will work given any object with a Connect method. This includes all Roblox events. -- Creates a Promise which only resolves when `somePart` is touched -- by a part named `&quot;Something specific&quot;`. return Promise.fromEvent(somePart.Touched, function(part) return part.Name == &quot;Something specific&quot; end)   "},{"title":"onUnhandledRejection​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#onUnhandledRejection","content":"since v3.2.0 &lt;/&gt; Promise.onUnhandledRejection( callback: ( promise: Promise, ...: any )-- A callback that runs when an unhandled rejection happens. ) → () → ()-- Function that unregisters the callback when called Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise is rejected, and the rejection is not observed with :catch. The callback is called with the actual promise that rejected, followed by the rejection values.  "},{"title":"new​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#new","content":"&lt;/&gt; Promise.new(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise Construct a new Promise that will be resolved or rejected with the given callbacks. If you resolve with a Promise, it will be chained onto. You can safely yield within the executor function and it will not block the creating thread. local myFunction() return Promise.new(function(resolve, reject, onCancel) wait(1) resolve(&quot;Hello world!&quot;) end) end myFunction():andThen(print) You do not need to use pcall within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If error() is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into Promise.Error(Promise.Error.Kind.ExecutionError) objects for tracking debug information. You may register an optional cancellation hook by using the onCancel argument: This should be used to abort any ongoing operations leading up to the promise being settled. Call the onCancel function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled. onCancel returns true if the Promise was already cancelled when you called onCancel. Calling onCancel with no argument will not override a previously set cancellation hook, but it will still return true if the Promise is currently cancelled. You can set the cancellation hook at any time before resolving. When a promise is cancelled, calls to resolve or reject will be ignored, regardless of if you set a cancellation hook or not. caution If the Promise is cancelled, the executor thread is closed with coroutine.close after the cancellation hook is called. You must perform any cleanup code in the cancellation hook: any time your executor yields, it may never resume.  "},{"title":"defer​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#defer","content":"&lt;/&gt; Promise.defer(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise The same as Promise.new, except execution begins after the next Heartbeat event. This is a spiritual replacement for spawn, but it does not suffer from the same issues as spawn. local function waitForChild(instance, childName, timeout) return Promise.defer(function(resolve, reject) local child = instance:WaitForChild(childName, timeout) ;(child and resolve or reject)(child) end) end   "},{"title":"resolve​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#resolve","content":"&lt;/&gt; Promise.resolve(...: any) → Promise&lt;...any&gt; Creates an immediately resolved Promise with the given value. -- Example using Promise.resolve to deliver cached values: function getSomething(name) if cache[name] then return Promise.resolve(cache[name]) else return Promise.new(function(resolve, reject) local thing = getTheThing() cache[name] = thing resolve(thing) end) end end   "},{"title":"reject​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#reject","content":"&lt;/&gt; Promise.reject(...: any) → Promise&lt;...any&gt; Creates an immediately rejected Promise with the given value. caution Something needs to consume this rejection (i.e. :catch() it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.  "},{"title":"try​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#try","content":"&lt;/&gt; Promise.try( callback: (...: T...) → ...any, ...: T...-- Additional arguments passed to callback ) → Promise Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback. info Promise.try is similar to Promise.promisify, except the callback is invoked immediately instead of returning a new function. Promise.try(function() return math.random(1, 2) == 1 and &quot;ok&quot; or error(&quot;Oh an error!&quot;) end) :andThen(function(text) print(text) end) :catch(function(err) warn(&quot;Something went wrong&quot;) end)   "},{"title":"all​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#all","content":"&lt;/&gt; Promise.all(promises: {Promise&lt;T&gt;}) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a new promise that: is resolved after all input promises resolve. is rejected if any input promises reject. info Only the first return value from each promise will be present in the resulting array. After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.all(promises)   "},{"title":"fold​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#fold","content":"since v3.1.0 &lt;/&gt; Promise.fold( list: {T | Promise&lt;T&gt;}, reducer: ( accumulator: U, value: T, index: number ) → U | Promise&lt;U&gt;, initialValue: U ) → () Folds an array of values or promises into a single value. The array is traversed sequentially. The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value. The folding will stop at the first rejection encountered. local basket = {&quot;blueberry&quot;, &quot;melon&quot;, &quot;pear&quot;, &quot;melon&quot;} Promise.fold(basket, function(cost, fruit) if fruit == &quot;blueberry&quot; then return cost -- blueberries are free! else -- call a function that returns a promise with the fruit price return fetchPrice(fruit):andThen(function(fruitCost) return cost + fruitCost end) end end, 0)   "},{"title":"some​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#some","content":"&lt;/&gt; Promise.some( promises: {Promise&lt;T&gt;}, count: number ) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as count Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers. count 0 results in an empty array. The resultant array will never have more than count elements. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve   "},{"title":"any​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#any","content":"&lt;/&gt; Promise.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as any of the input Promises resolves. It will reject only if all input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers. Resolves directly with the value of the first resolved Promise. This is essentially [Promise.some] with 1 count, except the Promise resolves with the value directly instead of an array with one element. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)   "},{"title":"allSettled​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#allSettled","content":"&lt;/&gt; Promise.allSettled(promises: {Promise&lt;T&gt;}) → Promise&lt;{Status}&gt; Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping promise:finally over the array of Promises. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.allSettled(promises)   "},{"title":"race​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#race","content":"&lt;/&gt; Promise.race(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects. warning If the first Promise to settle from the array settles with a rejection, the resulting Promise from race will reject. If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use Promise.any or Promise.some instead. All other Promises that don't win the race will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.race(promises) -- Only returns 1st value to resolve or reject   "},{"title":"each​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#each","content":"since 3.0.0 &lt;/&gt; Promise.each( list: {T | Promise&lt;T&gt;}, predicate: ( value: T, index: number ) → U | Promise&lt;U&gt; ) → Promise&lt;{U}&gt; Iterates serially over the given an array of values, calling the predicate callback on each value before continuing. If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item in the array. info Promise.each is similar to Promise.all, except the Promises are ran in order instead of all at once. But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time. The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value. Promise.each({ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot; }, function(value, index) return Promise.delay(1):andThen(function() print((&quot;%d) Got %s!&quot;):format(index, value)) end) end) --[[ (1 second passes) &gt; 1) Got foo! (1 second passes) &gt; 2) Got bar! (1 second passes) &gt; 3) Got baz! (1 second passes) &gt; 4) Got qux! ]] If the Promise a predicate returns rejects, the Promise from Promise.each is also rejected with the same value. If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value. If a Promise in the array of values is already Rejected when Promise.each is called, Promise.each rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when Promise.each is called, Promise.each rejects with Promise.Error(Promise.Error.Kind.AlreadyCancelled). If a Promise in the array of values is Started at first, but later rejects, Promise.each will reject with that value and iteration will not continue once iteration encounters that value. Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values. If this Promise returned from Promise.each rejects or is cancelled for any reason, the following are true: Iteration will not continue. Any Promises within the array of values will now be cancelled if they have no other consumers. The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.  "},{"title":"is​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#is","content":"&lt;/&gt; Promise.is(object: any) → boolean-- true if the given object is a Promise. Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an andThen method.  "},{"title":"promisify​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#promisify","content":"&lt;/&gt; Promise.promisify(callback: (...: any) → ...any) → (...: any) → Promise Wraps a function that yields into one that returns a Promise. Any errors that occur while executing the function will be turned into rejections. info Promise.promisify is similar to Promise.try, except the callback is returned as a callable function instead of being invoked immediately. local sleep = Promise.promisify(wait) sleep(1):andThen(print) local isPlayerInGroup = Promise.promisify(function(player, groupId) return player:IsInGroup(groupId) end)   "},{"title":"delay​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#delay","content":"&lt;/&gt; Promise.delay(seconds: number) → Promise&lt;number&gt; Returns a Promise that resolves after seconds seconds have passed. The Promise resolves with the actual amount of time that was waited. This function is not a wrapper around wait. Promise.delay uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler. warning Passing NaN, infinity, or a number less than 1/60 is equivalent to passing 1/60. Promise.delay(5):andThenCall(print, &quot;This prints after 5 seconds&quot;)   "},{"title":"retry​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#retry","content":"since 3.0.0 &lt;/&gt; Promise.retry( callback: (...: P) → Promise&lt;T&gt;, times: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise. local function canFail(a, b, c) return Promise.new(function(resolve, reject) -- do something that can fail local failed, thing = doSomethingThatCanFail(a, b, c) if failed then reject(&quot;it failed&quot;) else resolve(thing) end end) end local MAX_RETRIES = 10 local value = Promise.retry(canFail, MAX_RETRIES, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) -- args to send to canFail   "},{"title":"retryWithDelay​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#retryWithDelay","content":"since v3.2.0 &lt;/&gt; Promise.retryWithDelay( callback: (...: P) → Promise&lt;T&gt;, times: number, seconds: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, waiting seconds seconds between each retry, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise.  "},{"title":"fromEvent​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#fromEvent","content":"since 3.0.0 &lt;/&gt; Promise.fromEvent( event: Event,-- Any object with a Connect method. This includes all Roblox events. predicate?: (...: P) → boolean-- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again. ) → Promise&lt;P&gt; Converts an event into a Promise which resolves the next time the event fires. The optional predicate callback, if passed, will receive the event arguments and should return true or false, based on if this fired event should resolve the Promise or not. If true, the Promise resolves. If false, nothing happens and the predicate will be rerun the next time the event fires. The Promise will resolve with the event arguments. tip This function will work given any object with a Connect method. This includes all Roblox events. -- Creates a Promise which only resolves when `somePart` is touched -- by a part named `&quot;Something specific&quot;`. return Promise.fromEvent(somePart.Touched, function(part) return part.Name == &quot;Something specific&quot; end)   "},{"title":"onUnhandledRejection​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#onUnhandledRejection","content":"since v3.2.0 &lt;/&gt; Promise.onUnhandledRejection( callback: ( promise: Promise, ...: any )-- A callback that runs when an unhandled rejection happens. ) → () → ()-- Function that unregisters the callback when called Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise is rejected, and the rejection is not observed with :catch. The callback is called with the actual promise that rejected, followed by the rejection values.  "},{"title":"new​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#new","content":"&lt;/&gt; Promise.new(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise Construct a new Promise that will be resolved or rejected with the given callbacks. If you resolve with a Promise, it will be chained onto. You can safely yield within the executor function and it will not block the creating thread. local myFunction() return Promise.new(function(resolve, reject, onCancel) wait(1) resolve(&quot;Hello world!&quot;) end) end myFunction():andThen(print) You do not need to use pcall within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If error() is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into Promise.Error(Promise.Error.Kind.ExecutionError) objects for tracking debug information. You may register an optional cancellation hook by using the onCancel argument: This should be used to abort any ongoing operations leading up to the promise being settled. Call the onCancel function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled. onCancel returns true if the Promise was already cancelled when you called onCancel. Calling onCancel with no argument will not override a previously set cancellation hook, but it will still return true if the Promise is currently cancelled. You can set the cancellation hook at any time before resolving. When a promise is cancelled, calls to resolve or reject will be ignored, regardless of if you set a cancellation hook or not. caution If the Promise is cancelled, the executor thread is closed with coroutine.close after the cancellation hook is called. You must perform any cleanup code in the cancellation hook: any time your executor yields, it may never resume.  "},{"title":"defer​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#defer","content":"&lt;/&gt; Promise.defer(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise The same as Promise.new, except execution begins after the next Heartbeat event. This is a spiritual replacement for spawn, but it does not suffer from the same issues as spawn. local function waitForChild(instance, childName, timeout) return Promise.defer(function(resolve, reject) local child = instance:WaitForChild(childName, timeout) ;(child and resolve or reject)(child) end) end   "},{"title":"resolve​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#resolve","content":"&lt;/&gt; Promise.resolve(...: any) → Promise&lt;...any&gt; Creates an immediately resolved Promise with the given value. -- Example using Promise.resolve to deliver cached values: function getSomething(name) if cache[name] then return Promise.resolve(cache[name]) else return Promise.new(function(resolve, reject) local thing = getTheThing() cache[name] = thing resolve(thing) end) end end   "},{"title":"reject​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#reject","content":"&lt;/&gt; Promise.reject(...: any) → Promise&lt;...any&gt; Creates an immediately rejected Promise with the given value. caution Something needs to consume this rejection (i.e. :catch() it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.  "},{"title":"try​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#try","content":"&lt;/&gt; Promise.try( callback: (...: T...) → ...any, ...: T...-- Additional arguments passed to callback ) → Promise Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback. info Promise.try is similar to Promise.promisify, except the callback is invoked immediately instead of returning a new function. Promise.try(function() return math.random(1, 2) == 1 and &quot;ok&quot; or error(&quot;Oh an error!&quot;) end) :andThen(function(text) print(text) end) :catch(function(err) warn(&quot;Something went wrong&quot;) end)   "},{"title":"all​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#all","content":"&lt;/&gt; Promise.all(promises: {Promise&lt;T&gt;}) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a new promise that: is resolved after all input promises resolve. is rejected if any input promises reject. info Only the first return value from each promise will be present in the resulting array. After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.all(promises)   "},{"title":"fold​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#fold","content":"since v3.1.0 &lt;/&gt; Promise.fold( list: {T | Promise&lt;T&gt;}, reducer: ( accumulator: U, value: T, index: number ) → U | Promise&lt;U&gt;, initialValue: U ) → () Folds an array of values or promises into a single value. The array is traversed sequentially. The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value. The folding will stop at the first rejection encountered. local basket = {&quot;blueberry&quot;, &quot;melon&quot;, &quot;pear&quot;, &quot;melon&quot;} Promise.fold(basket, function(cost, fruit) if fruit == &quot;blueberry&quot; then return cost -- blueberries are free! else -- call a function that returns a promise with the fruit price return fetchPrice(fruit):andThen(function(fruitCost) return cost + fruitCost end) end end, 0)   "},{"title":"some​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#some","content":"&lt;/&gt; Promise.some( promises: {Promise&lt;T&gt;}, count: number ) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as count Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers. count 0 results in an empty array. The resultant array will never have more than count elements. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve   "},{"title":"any​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#any","content":"&lt;/&gt; Promise.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as any of the input Promises resolves. It will reject only if all input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers. Resolves directly with the value of the first resolved Promise. This is essentially [Promise.some] with 1 count, except the Promise resolves with the value directly instead of an array with one element. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)   "},{"title":"allSettled​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#allSettled","content":"&lt;/&gt; Promise.allSettled(promises: {Promise&lt;T&gt;}) → Promise&lt;{Status}&gt; Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping promise:finally over the array of Promises. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.allSettled(promises)   "},{"title":"race​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#race","content":"&lt;/&gt; Promise.race(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects. warning If the first Promise to settle from the array settles with a rejection, the resulting Promise from race will reject. If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use Promise.any or Promise.some instead. All other Promises that don't win the race will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.race(promises) -- Only returns 1st value to resolve or reject   "},{"title":"each​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#each","content":"since 3.0.0 &lt;/&gt; Promise.each( list: {T | Promise&lt;T&gt;}, predicate: ( value: T, index: number ) → U | Promise&lt;U&gt; ) → Promise&lt;{U}&gt; Iterates serially over the given an array of values, calling the predicate callback on each value before continuing. If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item in the array. info Promise.each is similar to Promise.all, except the Promises are ran in order instead of all at once. But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time. The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value. Promise.each({ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot; }, function(value, index) return Promise.delay(1):andThen(function() print((&quot;%d) Got %s!&quot;):format(index, value)) end) end) --[[ (1 second passes) &gt; 1) Got foo! (1 second passes) &gt; 2) Got bar! (1 second passes) &gt; 3) Got baz! (1 second passes) &gt; 4) Got qux! ]] If the Promise a predicate returns rejects, the Promise from Promise.each is also rejected with the same value. If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value. If a Promise in the array of values is already Rejected when Promise.each is called, Promise.each rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when Promise.each is called, Promise.each rejects with Promise.Error(Promise.Error.Kind.AlreadyCancelled). If a Promise in the array of values is Started at first, but later rejects, Promise.each will reject with that value and iteration will not continue once iteration encounters that value. Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values. If this Promise returned from Promise.each rejects or is cancelled for any reason, the following are true: Iteration will not continue. Any Promises within the array of values will now be cancelled if they have no other consumers. The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.  "},{"title":"is​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#is","content":"&lt;/&gt; Promise.is(object: any) → boolean-- true if the given object is a Promise. Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an andThen method.  "},{"title":"promisify​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#promisify","content":"&lt;/&gt; Promise.promisify(callback: (...: any) → ...any) → (...: any) → Promise Wraps a function that yields into one that returns a Promise. Any errors that occur while executing the function will be turned into rejections. info Promise.promisify is similar to Promise.try, except the callback is returned as a callable function instead of being invoked immediately. local sleep = Promise.promisify(wait) sleep(1):andThen(print) local isPlayerInGroup = Promise.promisify(function(player, groupId) return player:IsInGroup(groupId) end)   "},{"title":"delay​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#delay","content":"&lt;/&gt; Promise.delay(seconds: number) → Promise&lt;number&gt; Returns a Promise that resolves after seconds seconds have passed. The Promise resolves with the actual amount of time that was waited. This function is not a wrapper around wait. Promise.delay uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler. warning Passing NaN, infinity, or a number less than 1/60 is equivalent to passing 1/60. Promise.delay(5):andThenCall(print, &quot;This prints after 5 seconds&quot;)   "},{"title":"retry​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#retry","content":"since 3.0.0 &lt;/&gt; Promise.retry( callback: (...: P) → Promise&lt;T&gt;, times: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise. local function canFail(a, b, c) return Promise.new(function(resolve, reject) -- do something that can fail local failed, thing = doSomethingThatCanFail(a, b, c) if failed then reject(&quot;it failed&quot;) else resolve(thing) end end) end local MAX_RETRIES = 10 local value = Promise.retry(canFail, MAX_RETRIES, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) -- args to send to canFail   "},{"title":"retryWithDelay​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#retryWithDelay","content":"since v3.2.0 &lt;/&gt; Promise.retryWithDelay( callback: (...: P) → Promise&lt;T&gt;, times: number, seconds: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, waiting seconds seconds between each retry, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise.  "},{"title":"fromEvent​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#fromEvent","content":"since 3.0.0 &lt;/&gt; Promise.fromEvent( event: Event,-- Any object with a Connect method. This includes all Roblox events. predicate?: (...: P) → boolean-- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again. ) → Promise&lt;P&gt; Converts an event into a Promise which resolves the next time the event fires. The optional predicate callback, if passed, will receive the event arguments and should return true or false, based on if this fired event should resolve the Promise or not. If true, the Promise resolves. If false, nothing happens and the predicate will be rerun the next time the event fires. The Promise will resolve with the event arguments. tip This function will work given any object with a Connect method. This includes all Roblox events. -- Creates a Promise which only resolves when `somePart` is touched -- by a part named `&quot;Something specific&quot;`. return Promise.fromEvent(somePart.Touched, function(part) return part.Name == &quot;Something specific&quot; end)   "},{"title":"onUnhandledRejection​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#onUnhandledRejection","content":"since v3.2.0 &lt;/&gt; Promise.onUnhandledRejection( callback: ( promise: Promise, ...: any )-- A callback that runs when an unhandled rejection happens. ) → () → ()-- Function that unregisters the callback when called Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise is rejected, and the rejection is not observed with :catch. The callback is called with the actual promise that rejected, followed by the rejection values.  "},{"title":"timeout​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#timeout","content":"&lt;/&gt; Promise:timeout( seconds: number, rejectionValue?: any-- The value to reject with if the timeout is reached ) → Promise Returns a new Promise that resolves if the chained Promise resolves within seconds seconds, or rejects if execution time exceeds seconds. The chained Promise will be cancelled if the timeout is reached. Rejects with rejectionValue if it is non-nil. If a rejectionValue is not given, it will reject with a Promise.Error(Promise.Error.Kind.TimedOut). This can be checked with [Error.isKind]. getSomething():timeout(5):andThen(function(something) -- got something and it only took at max 5 seconds end):catch(function(e) -- Either getting something failed or the time was exceeded. if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then warn(&quot;Operation timed out!&quot;) else warn(&quot;Operation encountered an error!&quot;) end end) Sugar for: Promise.race({ Promise.delay(seconds):andThen(function() return Promise.reject( rejectionValue == nil and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut }) or rejectionValue ) end), promise })   "},{"title":"getStatus​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#getStatus","content":"&lt;/&gt; Promise:getStatus() → Status Returns the current Promise status.  "},{"title":"andThen​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThen","content":"&lt;/&gt; Promise:andThen( successHandler: (...: any) → ...any, failureHandler?: (...: any) → ...any ) → Promise&lt;...any&gt; Chains onto an existing Promise and returns a new Promise. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. You can return a Promise from the success or failure handler and it will be chained onto. Calling andThen on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by andThen is cancelled, successHandler and failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"catch​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#catch","content":"&lt;/&gt; Promise:catch(failureHandler: (...: any) → ...any) → Promise&lt;...any&gt; Shorthand for Promise:andThen(nil, failureHandler). Returns a Promise that resolves if the failureHandler worked without encountering an additional error. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. Calling catch on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by catch is cancelled, failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"tap​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#tap","content":"&lt;/&gt; Promise:tap(tapHandler: (...: any) → ...any) → Promise&lt;...any&gt; Similar to Promise.andThen, except the return value is the same as the value passed to the handler. In other words, you can insert a :tap into a Promise chain without affecting the value that downstream Promises receive. getTheValue() :tap(print) :andThen(function(theValue) print(&quot;Got&quot;, theValue, &quot;even though print returns nil!&quot;) end) If you return a Promise from the tap handler callback, its value will be discarded but tap will still wait until it resolves before passing the original value through.  "},{"title":"andThenCall​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThenCall","content":"&lt;/&gt; Promise:andThenCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Attaches an andThen handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded. promise:andThenCall(someFunction, &quot;some&quot;, &quot;arguments&quot;) This is sugar for promise:andThen(function() return someFunction(&quot;some&quot;, &quot;arguments&quot;) end)   "},{"title":"andThenReturn​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThenReturn","content":"&lt;/&gt; Promise:andThenReturn( ...: any-- Values to return from the function ) → Promise Attaches an andThen handler to this Promise that discards the resolved value and returns the given value from it. promise:andThenReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:andThen(function() return &quot;some&quot;, &quot;values&quot; end) caution Promises are eager, so if you pass a Promise to andThenReturn, it will begin executing before andThenReturn is reached in the chain. Likewise, if you pass a Promise created from [Promise.reject] into andThenReturn, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [Promise.andThen].  "},{"title":"cancel​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#cancel","content":"&lt;/&gt; Promise:cancel() → () Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled. Cancellations will propagate upwards and downwards through chained promises. Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call andThen twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled. promise:cancel()   "},{"title":"finally​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finally","content":"&lt;/&gt; Promise:finally(finallyHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, or cancelled. Returns a new Promise that: resolves with the same values that this Promise resolves with. rejects with the same values that this Promise rejects with. is cancelled if this Promise is cancelled. If the value you return from the handler is a Promise: We wait for the Promise to resolve, but we ultimately discard the resolved value. If the returned Promise rejects, the Promise returned from finally will reject with the rejected value from the returned promise. If the finally Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too. Otherwise, the return value from the finally handler is entirely discarded. Cancellation As of Promise v4, Promise:finally does not count as a consumer of the parent Promise for cancellation purposes. This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is cancelled and the finally callbacks run then and there. Cancellation still propagates through the finally Promise though: if you cancel the finally Promise, it can cancel its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the finally Promise will also be cancelled. local thing = createSomething() doSomethingWith(thing) :andThen(function() print(&quot;It worked!&quot;) -- do something.. end) :catch(function() warn(&quot;Oh no it failed!&quot;) end) :finally(function() -- either way, destroy thing thing:Destroy() end)   "},{"title":"finallyCall​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finallyCall","content":"&lt;/&gt; Promise:finallyCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for finally. Attaches a finally handler to this Promise that calls the given callback with the predefined arguments.  "},{"title":"finallyReturn​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finallyReturn","content":"&lt;/&gt; Promise:finallyReturn( ...: any-- Values to return from the function ) → Promise Attaches a finally handler to this Promise that discards the resolved value and returns the given value from it. promise:finallyReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:finally(function() return &quot;some&quot;, &quot;values&quot; end)   "},{"title":"awaitStatus​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#awaitStatus","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:awaitStatus() → ( Status,-- The Status representing the fate of the Promise ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.  "},{"title":"await​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:await() → ( boolean,-- true if the Promise successfully resolved ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with. caution If the Promise gets cancelled, this function will return false, which is indistinguishable from a rejection. If you need to differentiate, you should use [Promise.awaitStatus] instead. local worked, value = getTheValue():await() if worked then print(&quot;got&quot;, value) else warn(&quot;it failed&quot;) end   "},{"title":"expect​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#expect","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:expect() → ...any-- The values the Promise resolved with. Yields the current thread until the given Promise completes. Returns the values that the promise resolved with. local worked = pcall(function() print(&quot;got&quot;, getTheValue():expect()) end) if not worked then warn(&quot;it failed&quot;) end This is essentially sugar for: select(2, assert(promise:await())) Errors if the Promise rejects or gets cancelled. "},{"title":"Errors","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise##","content":"Type\tDescriptionany\tErrors with the rejection value if this Promise rejects or gets cancelled.  "},{"title":"now​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#now","content":"&lt;/&gt; Promise:now( rejectionValue?: any-- The value to reject with if the Promise isn't resolved ) → Promise Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling :now(). This can be used to ensure your andThen handler occurs on the same frame as the root Promise execution. doSomething() :now() :andThen(function(value) print(&quot;Got&quot;, value, &quot;synchronously.&quot;) end) If this Promise is still running, Rejected, or Cancelled, the Promise returned from :now() will reject with the rejectionValue if passed, otherwise with a Promise.Error(Promise.Error.Kind.NotResolvedInTime). This can be checked with [Error.isKind].  "},{"title":"timeout​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#timeout","content":"&lt;/&gt; Promise:timeout( seconds: number, rejectionValue?: any-- The value to reject with if the timeout is reached ) → Promise Returns a new Promise that resolves if the chained Promise resolves within seconds seconds, or rejects if execution time exceeds seconds. The chained Promise will be cancelled if the timeout is reached. Rejects with rejectionValue if it is non-nil. If a rejectionValue is not given, it will reject with a Promise.Error(Promise.Error.Kind.TimedOut). This can be checked with [Error.isKind]. getSomething():timeout(5):andThen(function(something) -- got something and it only took at max 5 seconds end):catch(function(e) -- Either getting something failed or the time was exceeded. if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then warn(&quot;Operation timed out!&quot;) else warn(&quot;Operation encountered an error!&quot;) end end) Sugar for: Promise.race({ Promise.delay(seconds):andThen(function() return Promise.reject( rejectionValue == nil and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut }) or rejectionValue ) end), promise })   "},{"title":"getStatus​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#getStatus","content":"&lt;/&gt; Promise:getStatus() → Status Returns the current Promise status.  "},{"title":"andThen​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThen","content":"&lt;/&gt; Promise:andThen( successHandler: (...: any) → ...any, failureHandler?: (...: any) → ...any ) → Promise&lt;...any&gt; Chains onto an existing Promise and returns a new Promise. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. You can return a Promise from the success or failure handler and it will be chained onto. Calling andThen on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by andThen is cancelled, successHandler and failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"catch​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#catch","content":"&lt;/&gt; Promise:catch(failureHandler: (...: any) → ...any) → Promise&lt;...any&gt; Shorthand for Promise:andThen(nil, failureHandler). Returns a Promise that resolves if the failureHandler worked without encountering an additional error. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. Calling catch on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by catch is cancelled, failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"tap​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#tap","content":"&lt;/&gt; Promise:tap(tapHandler: (...: any) → ...any) → Promise&lt;...any&gt; Similar to Promise.andThen, except the return value is the same as the value passed to the handler. In other words, you can insert a :tap into a Promise chain without affecting the value that downstream Promises receive. getTheValue() :tap(print) :andThen(function(theValue) print(&quot;Got&quot;, theValue, &quot;even though print returns nil!&quot;) end) If you return a Promise from the tap handler callback, its value will be discarded but tap will still wait until it resolves before passing the original value through.  "},{"title":"andThenCall​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThenCall","content":"&lt;/&gt; Promise:andThenCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Attaches an andThen handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded. promise:andThenCall(someFunction, &quot;some&quot;, &quot;arguments&quot;) This is sugar for promise:andThen(function() return someFunction(&quot;some&quot;, &quot;arguments&quot;) end)   "},{"title":"andThenReturn​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThenReturn","content":"&lt;/&gt; Promise:andThenReturn( ...: any-- Values to return from the function ) → Promise Attaches an andThen handler to this Promise that discards the resolved value and returns the given value from it. promise:andThenReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:andThen(function() return &quot;some&quot;, &quot;values&quot; end) caution Promises are eager, so if you pass a Promise to andThenReturn, it will begin executing before andThenReturn is reached in the chain. Likewise, if you pass a Promise created from [Promise.reject] into andThenReturn, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [Promise.andThen].  "},{"title":"cancel​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#cancel","content":"&lt;/&gt; Promise:cancel() → () Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled. Cancellations will propagate upwards and downwards through chained promises. Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call andThen twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled. promise:cancel()   "},{"title":"finally​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finally","content":"&lt;/&gt; Promise:finally(finallyHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, or cancelled. Returns a new Promise that: resolves with the same values that this Promise resolves with. rejects with the same values that this Promise rejects with. is cancelled if this Promise is cancelled. If the value you return from the handler is a Promise: We wait for the Promise to resolve, but we ultimately discard the resolved value. If the returned Promise rejects, the Promise returned from finally will reject with the rejected value from the returned promise. If the finally Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too. Otherwise, the return value from the finally handler is entirely discarded. Cancellation As of Promise v4, Promise:finally does not count as a consumer of the parent Promise for cancellation purposes. This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is cancelled and the finally callbacks run then and there. Cancellation still propagates through the finally Promise though: if you cancel the finally Promise, it can cancel its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the finally Promise will also be cancelled. local thing = createSomething() doSomethingWith(thing) :andThen(function() print(&quot;It worked!&quot;) -- do something.. end) :catch(function() warn(&quot;Oh no it failed!&quot;) end) :finally(function() -- either way, destroy thing thing:Destroy() end)   "},{"title":"finallyCall​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finallyCall","content":"&lt;/&gt; Promise:finallyCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for finally. Attaches a finally handler to this Promise that calls the given callback with the predefined arguments.  "},{"title":"finallyReturn​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finallyReturn","content":"&lt;/&gt; Promise:finallyReturn( ...: any-- Values to return from the function ) → Promise Attaches a finally handler to this Promise that discards the resolved value and returns the given value from it. promise:finallyReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:finally(function() return &quot;some&quot;, &quot;values&quot; end)   "},{"title":"awaitStatus​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#awaitStatus","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:awaitStatus() → ( Status,-- The Status representing the fate of the Promise ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.  "},{"title":"await​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:await() → ( boolean,-- true if the Promise successfully resolved ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with. caution If the Promise gets cancelled, this function will return false, which is indistinguishable from a rejection. If you need to differentiate, you should use [Promise.awaitStatus] instead. local worked, value = getTheValue():await() if worked then print(&quot;got&quot;, value) else warn(&quot;it failed&quot;) end   "},{"title":"expect​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#expect","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:expect() → ...any-- The values the Promise resolved with. Yields the current thread until the given Promise completes. Returns the values that the promise resolved with. local worked = pcall(function() print(&quot;got&quot;, getTheValue():expect()) end) if not worked then warn(&quot;it failed&quot;) end This is essentially sugar for: select(2, assert(promise:await())) Errors if the Promise rejects or gets cancelled. "},{"title":"Errors","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise##","content":"Type\tDescriptionany\tErrors with the rejection value if this Promise rejects or gets cancelled.  "},{"title":"now​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#now","content":"&lt;/&gt; Promise:now( rejectionValue?: any-- The value to reject with if the Promise isn't resolved ) → Promise Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling :now(). This can be used to ensure your andThen handler occurs on the same frame as the root Promise execution. doSomething() :now() :andThen(function(value) print(&quot;Got&quot;, value, &quot;synchronously.&quot;) end) If this Promise is still running, Rejected, or Cancelled, the Promise returned from :now() will reject with the rejectionValue if passed, otherwise with a Promise.Error(Promise.Error.Kind.NotResolvedInTime). This can be checked with [Error.isKind].  "},{"title":"timeout​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#timeout","content":"&lt;/&gt; Promise:timeout( seconds: number, rejectionValue?: any-- The value to reject with if the timeout is reached ) → Promise Returns a new Promise that resolves if the chained Promise resolves within seconds seconds, or rejects if execution time exceeds seconds. The chained Promise will be cancelled if the timeout is reached. Rejects with rejectionValue if it is non-nil. If a rejectionValue is not given, it will reject with a Promise.Error(Promise.Error.Kind.TimedOut). This can be checked with [Error.isKind]. getSomething():timeout(5):andThen(function(something) -- got something and it only took at max 5 seconds end):catch(function(e) -- Either getting something failed or the time was exceeded. if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then warn(&quot;Operation timed out!&quot;) else warn(&quot;Operation encountered an error!&quot;) end end) Sugar for: Promise.race({ Promise.delay(seconds):andThen(function() return Promise.reject( rejectionValue == nil and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut }) or rejectionValue ) end), promise })   "},{"title":"getStatus​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#getStatus","content":"&lt;/&gt; Promise:getStatus() → Status Returns the current Promise status.  "},{"title":"andThen​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThen","content":"&lt;/&gt; Promise:andThen( successHandler: (...: any) → ...any, failureHandler?: (...: any) → ...any ) → Promise&lt;...any&gt; Chains onto an existing Promise and returns a new Promise. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. You can return a Promise from the success or failure handler and it will be chained onto. Calling andThen on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by andThen is cancelled, successHandler and failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"catch​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#catch","content":"&lt;/&gt; Promise:catch(failureHandler: (...: any) → ...any) → Promise&lt;...any&gt; Shorthand for Promise:andThen(nil, failureHandler). Returns a Promise that resolves if the failureHandler worked without encountering an additional error. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. Calling catch on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by catch is cancelled, failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"tap​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#tap","content":"&lt;/&gt; Promise:tap(tapHandler: (...: any) → ...any) → Promise&lt;...any&gt; Similar to Promise.andThen, except the return value is the same as the value passed to the handler. In other words, you can insert a :tap into a Promise chain without affecting the value that downstream Promises receive. getTheValue() :tap(print) :andThen(function(theValue) print(&quot;Got&quot;, theValue, &quot;even though print returns nil!&quot;) end) If you return a Promise from the tap handler callback, its value will be discarded but tap will still wait until it resolves before passing the original value through.  "},{"title":"andThenCall​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThenCall","content":"&lt;/&gt; Promise:andThenCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Attaches an andThen handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded. promise:andThenCall(someFunction, &quot;some&quot;, &quot;arguments&quot;) This is sugar for promise:andThen(function() return someFunction(&quot;some&quot;, &quot;arguments&quot;) end)   "},{"title":"andThenReturn​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThenReturn","content":"&lt;/&gt; Promise:andThenReturn( ...: any-- Values to return from the function ) → Promise Attaches an andThen handler to this Promise that discards the resolved value and returns the given value from it. promise:andThenReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:andThen(function() return &quot;some&quot;, &quot;values&quot; end) caution Promises are eager, so if you pass a Promise to andThenReturn, it will begin executing before andThenReturn is reached in the chain. Likewise, if you pass a Promise created from [Promise.reject] into andThenReturn, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [Promise.andThen].  "},{"title":"cancel​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#cancel","content":"&lt;/&gt; Promise:cancel() → () Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled. Cancellations will propagate upwards and downwards through chained promises. Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call andThen twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled. promise:cancel()   "},{"title":"finally​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finally","content":"&lt;/&gt; Promise:finally(finallyHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, or cancelled. Returns a new Promise that: resolves with the same values that this Promise resolves with. rejects with the same values that this Promise rejects with. is cancelled if this Promise is cancelled. If the value you return from the handler is a Promise: We wait for the Promise to resolve, but we ultimately discard the resolved value. If the returned Promise rejects, the Promise returned from finally will reject with the rejected value from the returned promise. If the finally Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too. Otherwise, the return value from the finally handler is entirely discarded. Cancellation As of Promise v4, Promise:finally does not count as a consumer of the parent Promise for cancellation purposes. This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is cancelled and the finally callbacks run then and there. Cancellation still propagates through the finally Promise though: if you cancel the finally Promise, it can cancel its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the finally Promise will also be cancelled. local thing = createSomething() doSomethingWith(thing) :andThen(function() print(&quot;It worked!&quot;) -- do something.. end) :catch(function() warn(&quot;Oh no it failed!&quot;) end) :finally(function() -- either way, destroy thing thing:Destroy() end)   "},{"title":"finallyCall​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finallyCall","content":"&lt;/&gt; Promise:finallyCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for finally. Attaches a finally handler to this Promise that calls the given callback with the predefined arguments.  "},{"title":"finallyReturn​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finallyReturn","content":"&lt;/&gt; Promise:finallyReturn( ...: any-- Values to return from the function ) → Promise Attaches a finally handler to this Promise that discards the resolved value and returns the given value from it. promise:finallyReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:finally(function() return &quot;some&quot;, &quot;values&quot; end)   "},{"title":"awaitStatus​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#awaitStatus","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:awaitStatus() → ( Status,-- The Status representing the fate of the Promise ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.  "},{"title":"await​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:await() → ( boolean,-- true if the Promise successfully resolved ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with. caution If the Promise gets cancelled, this function will return false, which is indistinguishable from a rejection. If you need to differentiate, you should use [Promise.awaitStatus] instead. local worked, value = getTheValue():await() if worked then print(&quot;got&quot;, value) else warn(&quot;it failed&quot;) end   "},{"title":"expect​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#expect","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:expect() → ...any-- The values the Promise resolved with. Yields the current thread until the given Promise completes. Returns the values that the promise resolved with. local worked = pcall(function() print(&quot;got&quot;, getTheValue():expect()) end) if not worked then warn(&quot;it failed&quot;) end This is essentially sugar for: select(2, assert(promise:await())) Errors if the Promise rejects or gets cancelled. "},{"title":"Errors","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise##","content":"Type\tDescriptionany\tErrors with the rejection value if this Promise rejects or gets cancelled.  "},{"title":"now​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#now","content":"&lt;/&gt; Promise:now( rejectionValue?: any-- The value to reject with if the Promise isn't resolved ) → Promise Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling :now(). This can be used to ensure your andThen handler occurs on the same frame as the root Promise execution. doSomething() :now() :andThen(function(value) print(&quot;Got&quot;, value, &quot;synchronously.&quot;) end) If this Promise is still running, Rejected, or Cancelled, the Promise returned from :now() will reject with the rejectionValue if passed, otherwise with a Promise.Error(Promise.Error.Kind.NotResolvedInTime). This can be checked with [Error.isKind]. "}]