[{"title":"CmdrHandler","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrHandler","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#Server","content":"&lt;/&gt; CmdrHandler.Server: CmdrServer   "},{"title":"Client​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#Client","content":"&lt;/&gt; CmdrHandler.Client: CmdrClient  "},{"title":"ClientTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientTableReplicator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#functions","content":" "},{"title":"fromTemplate​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#fromTemplate","content":"Static &lt;/&gt; ClientTableReplicator.fromTemplate() → () Creates a ReplicatedTableSingleton object from the given template configuration. See TableReplicatorSingleton.new for more information.  "},{"title":"onNew​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#onNew","content":"&lt;/&gt; ClientTableReplicator.onNew( classTokenName: string, fn: (replicator: ClientTableReplicator) → () ) → () → () Listens for a new ClientTableReplicator of the given ClassName. Listening after server data loaded If you call this method after the ClientTableReplicator has already requested and loaded the server data, then this listener may miss the creation of some replicators. It is recommended to call this method before calling .requestServerData() or use .forEach() instead.  "},{"title":"requestServerData​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#requestServerData","content":"&lt;/&gt; ClientTableReplicator.requestServerData() → Promise Requests all the existing replicators from the server. This should only be called once, calling it multiple times will return the same promise. All replicator listeners should be registered before calling this method. "},{"title":"ClientPlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientPlayerDataManager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#properties","content":" "},{"title":"DEFAULT_MANAGER_NAME​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#DEFAULT_MANAGER_NAME","content":"&lt;/&gt; ClientPlayerDataManager.DEFAULT_MANAGER_NAME: string The default internal manager name.  "},{"title":"PlayerDataReady​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#PlayerDataReady","content":"&lt;/&gt; ClientPlayerDataManager.PlayerDataReady: Signal&lt;Player &gt; A signal that fires when a Player's data is ready to be used. "},{"title":"Functions​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#new","content":"Constructor Static &lt;/&gt; ClientPlayerDataManager.new(config: { ProfileSchema: table, }) → ClientPlayerDataManager   "},{"title":"GetImmediate​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#GetImmediate","content":"&lt;/&gt; ClientPlayerDataManager:GetImmediate(managerName: string?) → TableReplicatorSingleton Gets the TableReplicatorSingleton for this manager so you can get immediate info from it if needed.  "},{"title":"GetManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#GetManager","content":"&lt;/&gt; ClientPlayerDataManager:GetManager(managerName: string?) → TableManager? Gets the TableManager associated with the given name. This method may return nil if the data has not replicated yet.  "},{"title":"PromiseManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#PromiseManager","content":"&lt;/&gt; ClientPlayerDataManager:PromiseManager(managerName: string?) → Promise Promises the TableManager associated with the given name. If it doesnt exist when called then it will wait for it to be replicated and then will resolve.  "},{"title":"RegisterManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#RegisterManager","content":"&lt;/&gt; ClientPlayerDataManager:RegisterManager(config: string | {Name: string;DefaultDataSchema: table;ConditionFn: ((replicator: TableReplicator) → boolean)?}) → TableReplicatorSingleton Registers a tableManager/TableReplicatorSingleton to be watched for on the client. Informal registration. Assumes data key in the profile template is the same as the given name. ClientPlayerDataManager:RegisterManager(&quot;Currency&quot;) Formal registration. Used for more complex/custom registering of managers. Equivalent to the above ClientPlayerDataManager:RegisterManager({ Name = &quot;Currency&quot;, DefaultDataSchema = profileTemplate[&quot;Currency&quot;], ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end, })   "},{"title":"Start​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#Start","content":"unreleased &lt;/&gt; ClientPlayerDataManager:Start() → () Marks the CPDM as started. This is not currently neccessary "},{"title":"----------------","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/----------------","content":"On this page ----------------","keywords":""},{"title":"DropletClientManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletClientManager","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#new","content":"constructor &lt;/&gt; DropletClientManager.new() → DropletClientManager Creates a new DropletClientManager if one has not already been made, returns the existing one if one already exists.  "},{"title":"RegisterResourceType​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#RegisterResourceType","content":"&lt;/&gt; DropletClientManager:RegisterResourceType( resourceType: string, data: ResourceTypeData ) → () Registers a new resource type.  "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#GetResourceTypeData","content":"&lt;/&gt; DropletClientManager:GetResourceTypeData(resourceType: string) → ResourceTypeData? Returns the resource type data for the given resource type  "},{"title":"GetCollectionRadius​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#GetCollectionRadius","content":"&lt;/&gt; DropletClientManager:GetCollectionRadius() → number Gets the distance at which a droplet must be within to be collected by the LocalPlayer "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → () }   "},{"title":"Connection​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → () } Represents a connection. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → ()) → Connection Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object.  "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → ()) → Connection Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"/ModulesOnRails/api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object. "},{"title":"ClientRemoteEvent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientRemoteEvent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteEvent","url":"/ModulesOnRails/api/ClientRemoteEvent#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteEvent","url":"/ModulesOnRails/api/ClientRemoteEvent#Connect","content":"&lt;/&gt; ClientRemoteEvent:Connect(fn: (...: any) → ()) → Connection Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteEvent","url":"/ModulesOnRails/api/ClientRemoteEvent#Fire","content":"&lt;/&gt; ClientRemoteEvent:Fire(...: any) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server. "},{"title":"Comm","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Comm","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#properties","content":" "},{"title":"ServerComm​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#ServerComm","content":"&lt;/&gt; Comm.ServerComm: ServerComm   "},{"title":"ClientComm​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#ClientComm","content":"&lt;/&gt; Comm.ClientComm: ClientComm   "},{"title":"ServerComm​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#ServerComm","content":"&lt;/&gt; Comm.ServerComm: ServerComm   "},{"title":"ClientComm​","type":1,"pageTitle":"Comm","url":"/ModulesOnRails/api/Comm#ClientComm","content":"&lt;/&gt; Comm.ClientComm: ClientComm  "},{"title":"Error","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Error","content":"On this page Error An object to represent runtime errors that occur during execution. Promises that experience an error like this will be rejected with an instance of this object.","keywords":""},{"title":"CmdrClient","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrClient","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#functions","content":" "},{"title":"PromiseCmdr​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#PromiseCmdr","content":"&lt;/&gt; CmdrClient:PromiseCmdr() → Promise Returns a promise that resolves with the Cmdr instance.https://eryn.io/Cmdr/api/CmdrClient.html return Promise  "},{"title":"HasPermission​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#HasPermission","content":"&lt;/&gt; CmdrClient:HasPermission( commandName: string-- The name of the command to check ) → boolean Checks if a player has permission to run a command  "},{"title":"ExecuteCommand​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#ExecuteCommand","content":"&lt;/&gt; CmdrClient:ExecuteCommand(...: string) → Promise&lt;string&gt; Executes a command CmdrService:ExecuteCommand(&quot;blink&quot;)   "},{"title":"GetPermissions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetPermissions","content":"&lt;/&gt; CmdrClient:GetPermissions() → {any} Gets the permissions for the local player Does not return permissions granted from groups  "},{"title":"GetGroupRankPermissions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetGroupRankPermissions","content":"&lt;/&gt; CmdrClient:GetGroupRankPermissions( groupId: number,-- The Roblox group id to get permissions for rank: number-- The rank to get permissions for ) → {string}-- The permissions granted to the rank Gets the permissions granted to a particular rank in a group local permissions = CmdrService:GetGroupRankPermissions(15905255, 230)   "},{"title":"GetPermissionInheritance​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetPermissionInheritance","content":"&lt;/&gt; CmdrClient:GetPermissionInheritance(permissionGroup: string) → {string} Fetches the inherited permission group for a permission group "},{"title":"DropletManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#types","content":" "},{"title":"Droplet​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Droplet","content":"&lt;/&gt; type Droplet = Droplet   "},{"title":"ResourceTypeData​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#ResourceTypeData","content":"&lt;/&gt; type ResourceTypeData = ResourceTypeData   "},{"title":"ResourceSpawnData​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#ResourceSpawnData","content":"&lt;/&gt; type ResourceSpawnData = ResourceSpawnData  "},{"title":"Properties​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Server","content":"This item only works when running on the server. Server &lt;/&gt; DropletManager.Server: DropletServerManager Accessing this will automatically create a new DropletServerManager if one does not exist.  "},{"title":"Client​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Client","content":"This item only works when running on the client. Client &lt;/&gt; DropletManager.Client: DropletClientManager Accessing this will automatically create a new DropletClientManager if one does not exist.  "},{"title":"Util​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Util","content":"&lt;/&gt; DropletManager.Util: DropletUtil  "},{"title":"DropletServerManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletServerManager","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#new","content":"constructor &lt;/&gt; DropletServerManager.new() → DropletServerManager Creates a new DropletServerManager if one has not already been made, returns the existing one if one already exists.  "},{"title":"RegisterResourceType​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#RegisterResourceType","content":"&lt;/&gt; DropletServerManager:RegisterResourceType( resourceType: string, data: ResourceTypeData ) → () Registers a new resource type. Attempting to register a resource type with the same name as an existing one will error. local data = Import(&quot;ExampleResourceTypeData&quot;) -- This is an Example file included in the package you can check out. DropletServerManager:RegisterResourceType(&quot;Example&quot;, data)   "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#GetResourceTypeData","content":"&lt;/&gt; DropletServerManager:GetResourceTypeData(resourceType: string) → ResourceTypeData? Returns the resource type data for the given resource type.  "},{"title":"Spawn​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Spawn","content":"&lt;/&gt; DropletServerManager:Spawn( data: ResourceSpawnData-- The data used to spawn the droplet. ) → number-- The seed of the droplet request. Creates a new droplet request to create some defined number of droplets of a given ResourceType. The droplet request will be created on the server and replicated to the clients. A PlayerTargets array can be passed to specify which players the droplet request should be replicated to, if one isnt given it replicates to all connected players at the moment of the request. Caveats Some properties of the interface have special behaviors depending on their type. See 'ResourceSpawnData' for more info on important caveats and behavior. local Bounds = 35 local seed = DropletServerManager:Spawn({ ResourceType = &quot;Example&quot;; Value = NumberRange.new(0.6, 1.4); Count = NumberRange.new(2, 10); LifeTime = NumberRange.new(10, 20); SpawnLocation = Vector3.new( math.random(-Bounds,Bounds), 7, math.random(-Bounds,Bounds) ); CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector; })   "},{"title":"Claim​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Claim","content":"&lt;/&gt; DropletServerManager:Claim( collector: Player ,-- The player claiming the droplet. seed: number,-- The droplet request identifier. dropletNumber: number?-- The particular droplet number to claim. If nil, all remaining droplets will be claimed. ) → boolean-- Whether or not the claim was successful. Force claim a droplet(s) for a player.  "},{"title":"Collect​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Collect","content":"&lt;/&gt; DropletServerManager:Collect( collector: Player ,-- The player collecting the resource. seed: number,-- The droplet request identifier. dropletNumber: number?-- The particular droplet number to collect. If nil, all droplets will be collected. ) → boolean-- Whether or not the collection was successful. Force collects a droplet(s) resource and returns whether or not the collection was successful.  "},{"title":"GetCollectionRadius​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#GetCollectionRadius","content":"&lt;/&gt; DropletServerManager:GetCollectionRadius(player: Player ) → number Gets the collection radius for the given player.  "},{"title":"SetCollectionRadius​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#SetCollectionRadius","content":"&lt;/&gt; DropletServerManager:SetCollectionRadius( player: Player , radius: number ) → () Sets the collection radius for the given player. "},{"title":"Droplet","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Droplet","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#types","content":" "},{"title":"Droplet​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Droplet","content":"&lt;/&gt; type Droplet = Droplet  "},{"title":"Functions​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#functions","content":" "},{"title":"GetValue​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetValue","content":"&lt;/&gt; Droplet:GetValue() → any   "},{"title":"GetMetadata​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetMetadata","content":"&lt;/&gt; Droplet:GetMetadata() → any?   "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetResourceTypeData","content":"&lt;/&gt; Droplet:GetResourceTypeData() → ResourceTypeData   "},{"title":"GetPosition​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetPosition","content":"&lt;/&gt; Droplet:GetPosition() → Vector3    "},{"title":"GetModel​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetModel","content":"&lt;/&gt; Droplet:GetModel() → Actor    "},{"title":"GetSetupData​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetSetupData","content":"&lt;/&gt; Droplet:GetSetupData() → any Returns the data that was returned by the ResourceTypeData.Setup function  "},{"title":"Identify​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Identify","content":"&lt;/&gt; Droplet:Identify() → ( number,-- The seed of the droplet number-- The id of the droplet ) Returns the seed and id of the droplet. Used for internal identification.  "},{"title":"IsTimingOut​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#IsTimingOut","content":"&lt;/&gt; Droplet:IsTimingOut() → boolean Returns whether or not the droplet is in the process of timing out.  "},{"title":"AttachModel​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#AttachModel","content":"&lt;/&gt; Droplet:AttachModel(object: Model | BasePart ) → () Attaches a Model or Part to the droplet. Use this to add your visuals to the droplet.  "},{"title":"Collect​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Collect","content":"&lt;/&gt; Droplet:Collect(playerWhoCollected: Player ) → ()   "},{"title":"Claim​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Claim","content":"&lt;/&gt; Droplet:Claim(playerWhoClaimed: Player ) → ()  "},{"title":"ClientNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientNetWire","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#types","content":" "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = (args: {any}) → ( shouldContinue: boolean, ...any ) Middleware function for client-side operations. Returns whether to continue processing and any modified arguments. "},{"title":"Functions​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#new","content":"&lt;/&gt; ClientNetWire.new(nameSpace: string) → ClientNetWire Creates a new ClientNetWire. If a ClientNetWire with the same nameSpace already exists, it will be returned instead.  "},{"title":"onReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#onReady","content":"&lt;/&gt; ClientNetWire.onReady(clientNetWire: string | ClientNetWire) → Promise&lt;ClientNetWire&gt; Returns a promise that resolves when the ClientNetWire is ready for use.  "},{"title":"isReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#isReady","content":"&lt;/&gt; ClientNetWire.isReady(clientNetWire: ClientNetWire | string) → boolean Can be used to check if a clientNetWire is ready for use. Accepts either a ClientNetWire instance or a string name of the wire. Returns true if the ClientNetWire is ready, false otherwise.  "},{"title":"indexReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#indexReady","content":"&lt;/&gt; ClientNetWire.indexReady( wireOrName: ClientNetWire | string, idx: string-- The index to wait for existence of ) → Promise&lt;...any&gt; Returns a promise that resolves when the ClientNetWire is ready for use and the index exists. The resolved value is the value of the index. "},{"title":"DropletUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#types","content":" "},{"title":"WeightedArray<T>​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#WeightedArray<T>","content":"&lt;/&gt; type WeightedArray&lt;T&gt; = {{ Weight: number, Value: T }} A table of values with weights. The weights are used to calculate the probability of a value being chosen. The weights do not need to add up to 1. See ProbabilityDistributor for more information.  "},{"title":"NumOrRange​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#NumOrRange","content":"&lt;/&gt; type NumOrRange = number | NumberRange    "},{"title":"NumOrRangeOrWeightedArray​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#NumOrRangeOrWeightedArray","content":"&lt;/&gt; type NumOrRangeOrWeightedArray = NumOrRange | WeightedArray&lt;NumOrRange&gt;   "},{"title":"ResourceTypeData​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#ResourceTypeData","content":"&lt;/&gt; interface ResourceTypeData { Defaults: table SetupDroplet: (droplet: Droplet) → any? OnRenderUpdate: (( droplet: Droplet, renderTime: number ) → (CFrame? ))? OnDropletTimeout: ((droplet: Droplet) → ())? OnClientClaim: (( playerWhoCollected: Player , droplet: Droplet ) → ())? OnClientCollect: (( playerWhoCollected: Player , droplet: Droplet ) → ())? OnServerCollect: (( playerWhoCollected: Player , value: any, metadata: any ) → ())? }  [Defaults] is a table of default values for the droplet. This can be left empty. The values in this table are used to fill in any missing values in the ResourceSpawnData when a droplet is spawned as well as overriding certain behaviors internall for things like magnetization. [SetupDroplet] is called when a new droplet is created. Use this to setup your visuals and any variables you need to keep track of. All parts within this should be Anchored = false, CanCollide = false, and Massless = true. The return value of this function can be accessed via Droplet:GetSetupData() [OnRenderUpdate] is called every frame that the droplet is within render range of the LocalPlayer's Camera. Use this to update the visuals of your droplet. The return value, if one is given, must be a CFrame and is used for offsetting the droplet. [OnDropletTimeout] is called when the droplet times out. Use this to perform/cleanup any visual effects you may have. [OnClientClaim] is called when the server acknowledges that the droplet has been claimed. [OnClientCollect] is called when the droplet hits the player and is considered collected. It should be used for collection effects and other client side things. [OnServerCollect] is called once the server is informed by a client that the droplet has been collected. This is where you should perform any server side logic like actually giving things like Money or Exp.   "},{"title":"ResourceSpawnData​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#ResourceSpawnData","content":"&lt;/&gt; interface ResourceSpawnData { ResourceType: string-- The registered name of the resource type Value: any | NumOrRangeOrWeightedArray-- The value of the droplet Metadata: any?-- The metadata of the droplet SpawnLocation: Vector3 | CFrame | PVInstance -- The location to spawn the droplet CollectorMode: CollectorMode?-- The behavior of how the droplet is claimed PlayerTargets: Player | {Player }?-- The players that can collect the droplet LifeTime: NumOrRange?-- The time before the droplet dissapears Count: NumOrRangeOrWeightedArray?-- The number of droplets to spawn EjectionDuration: NumOrRangeOrWeightedArray?-- The time it takes to spew out all the droplets EjectionHorizontalVelocity: NumOrRangeOrWeightedArray?-- The horizontal velocity of the droplets when they are ejected EjectionVerticalVelocity: NumOrRangeOrWeightedArray?-- The vertical velocity of the droplets when they are ejected }  Special Behaviors Any index that takes a NumOrRangeOrWeightedArray will be parsed and calculated ahead of time internally so that the client and server are synced. For example, if you pass in a NumberRange for Value, the server will calculate a random decimal number between the min and max, this number would then be accessed by Droplet:GetValue() on the client.  "},{"title":"CollectorMode​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#CollectorMode","content":"&lt;/&gt; type CollectorMode = &quot;MultiCollector&quot; | &quot;SingleCollector&quot; The behavior of how the droplet is claimed. MultiCollector - Many players can collect this droplet, each has their own individual instance SingleCollector - Only one player can collect this droplet  "},{"title":"Properties​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#Enums","content":"&lt;/&gt; DropletUtil.Enums: {CollectorMode: { MultiCollector: CollectorMode, SingleCollector: CollectorMode }}  "},{"title":"AdjustableTimer","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/AdjustableTimer","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#functions","content":" "},{"title":"new​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#new","content":"&lt;/&gt; AdjustableTimer.new(config: { TimeScale: number?, StartTime: number?, }?) → AdjustableTimer Creates a new AdjustableTimer instance. Takes an optional configuration table. TimeScale: The initial time scale for the timer. Defaults to 1. StartTime: The initial start time of the timer. Defaults to the current server time (via workspace:GetServerTimeNow()). local timer = AdjustableTimer.new() timer:Resume() -- Start the timer Starting the Timer Timers are initialized in a paused state by default. You need to call :Resume() to start the timer.  "},{"title":"Unserialize​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#Unserialize","content":"&lt;/&gt; AdjustableTimer.Unserialize(data: SerializedAdjustableTimer) → AdjustableTimer Unserializes a table into an AdjustableTimer instance. local timer = AdjustableTimer.Unserialize(serializedData)   "},{"title":"Serialize​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#Serialize","content":"&lt;/&gt; AdjustableTimer:Serialize() → SerializedAdjustableTimer Serializes the timer into a saveable/network-safe table. local serializedData = timer:Serialize()   "},{"title":"GetElapsedTime​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#GetElapsedTime","content":"&lt;/&gt; AdjustableTimer:GetElapsedTime() → number-- The elapsed time in seconds. Gets the elapsed time that the timer has been running unpaused. print(timer:GetElapsedTime())   "},{"title":"Pause​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#Pause","content":"&lt;/&gt; AdjustableTimer:Pause() → AdjustableTimer Pauses the timer. Returns the timer for chaining. timer:Pause()   "},{"title":"Resume​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#Resume","content":"&lt;/&gt; AdjustableTimer:Resume() → AdjustableTimer Resumes the timer. Returns the timer for chaining. timer:Resume()   "},{"title":"IsPaused​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#IsPaused","content":"&lt;/&gt; AdjustableTimer:IsPaused() → boolean Returns whether or not the timer is paused. print(timer:IsPaused())   "},{"title":"SetTimeScale​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#SetTimeScale","content":"&lt;/&gt; AdjustableTimer:SetTimeScale( newRate: number,-- The new rate at with time will progress. _newRateChangeTime: number? ) → () Changes how fast the timer progresses every unpaused second.2 means the timer will progress twice as fast, 0.5 means it will progress half as fast. timer:SetTimeScale(2)   "},{"title":"GetTimeScale​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#GetTimeScale","content":"&lt;/&gt; AdjustableTimer:GetTimeScale() → number-- The current progress rate. Gets the current time scale of the timer. Represents how fast the timer progresses every unpaused second.2 means the timer will progress twice as fast, 0.5 means it will progress half as fast.  "},{"title":"AddElapsedTime​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#AddElapsedTime","content":"&lt;/&gt; AdjustableTimer:AddElapsedTime( seconds: number,-- The number of seconds to add. useTimeScale: boolean?-- Whether to apply the current time scale to the given seconds (default is false). ) → () Adds progress to the timer in raw seconds. local time = AdjustableTimer.new():Resume() print(timer:GetElapsedTime()) -- 0 timer:AddElapsedTime(10) print(timer:GetElapsedTime()) -- 10 timer:SetTimeScale(2) timer:AddElapsedTime(5, true) print(timer:GetElapsedTime()) -- 20   "},{"title":"SetElapsedTime​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#SetElapsedTime","content":"&lt;/&gt; AdjustableTimer:SetElapsedTime( seconds: number-- The elapsed time to set. ) → () Sets the elapsed time of the timer in raw seconds. timer:SetElapsedTime(30)   "},{"title":"SetStartTime​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#SetStartTime","content":"&lt;/&gt; AdjustableTimer:SetStartTime(timestamp: number) → () Sets the time at which the timer started. This will affect the elapsed time calculation. The timestamp should be relative to workspace:GetServerTimeNow(). Does not account for time scale or paused state. timer:SetStartTime(workspace:GetServerTimeNow() - 60) -- Set start time to 60 seconds ago  "},{"title":"ProbabilityDistributor","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ProbabilityDistributor","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#types","content":" "},{"title":"Weight​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Weight","content":"&lt;/&gt; type Weight = number | NumberRange | () → (number | NumberRange ) A valid input for the weight of an item in the WeightsTable. Allows for functions to be passed in to generate a weight on the fly. If a NumberRange is given in, it will generate a random INTEGER between the min and max values of the Range.  "},{"title":"WeightedItem<T>​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#WeightedItem<T>","content":"&lt;/&gt; interface WeightedItem&lt;T&gt; { Weight: Weight Value: T } The format weights and an associated value must be in.  "},{"title":"WeightedArray<T>​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#WeightedArray<T>","content":"&lt;/&gt; type WeightedArray&lt;T&gt; = {WeightedItem&lt;T&gt;} A valid input for the WeightsTable. "},{"title":"Functions​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#new","content":"&lt;/&gt; ProbabilityDistributor.new( weights: {WeightedItem&lt;T&gt;},-- A table of weights to distribute. randomOrSeed: (Random | number)?-- An optional random number generator to use for the rolls. If a number is passed, it will be used as the seed for a new random number generator. If nothing is passed, it will create a new Random and use the current time as the seed. ) → ProbabilityDistributor&lt;T&gt;-- A new probability distributor of type T. Where T is the type of the value of the weighted item. Constructs a new ProbabilityDistributor  "},{"title":"Roll​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Roll","content":"&lt;/&gt; ProbabilityDistributor:Roll( luck: number?-- [Optional] A number between 0 and 1 that determines how lucky the roll is. The number acts as a chance that it rerolls the item for a better version. 'Better'ness is determined by the initial order of the weights table. ) → T-- The value of the item that was rolled. Rolls the probability distributor for a weighted item.  "},{"title":"Clone​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Clone","content":"&lt;/&gt; ProbabilityDistributor:Clone() → ProbabilityDistributor&lt;T&gt;-- A new probability distributor of type T. Where T is the type of the value of the weighted item. Clones the probability distributor.  "},{"title":"Sample​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Sample","content":"&lt;/&gt; ProbabilityDistributor:Sample( numOfSamples: number?,-- The number of samples to take. Defaults to 10,000. luck: number?-- The luck to use for the rolls. Defaults to 0. ) → {[T]: number}-- A table of the items that were rolled and how many times they were rolled. Samples the probability distributor to show the distribution of the rolls. "},{"title":"CmdrTypes","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrTypes","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#types","content":" "},{"title":"ArgumentContext<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#ArgumentContext<T>","content":"&lt;/&gt; interface ArgumentContext&lt;T&gt; { Command: CommandContext&lt;T&gt;-- The command context this argument belongs to. Name: string-- The name of the argument Type: TypeDefinition&lt;T&gt;-- The type definition of the argument Required: boolean-- Whether or not this argument is required Executor: Player -- The player that ran the command this argument belongs to. RawValue: string-- The raw value of the argument RawSegments: {string}-- The raw segments of the argument Prefix: string-- The prefix of the argument }   "},{"title":"CommandContext<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandContext<T>","content":"&lt;/&gt; interface CommandContext&lt;T&gt; { Executor: Player -- The player who executed the command Name: string-- the name of the command Description: string-- the description of the command Alias: string-- The specific alias of this command that was used to trigger this command (may be the same as Name) Aliases: {string}-- The list of aliases that could have been used to trigger this command Group: any-- The group this command is a part of. Defined in command definitions, typically a string. RawText: string-- the raw text of the command RawArguments: {string}-- the raw arguments of the command Arguments: {ArgumentContext&lt;T&gt;}-- the parsed arguments of the command Cmdr: table Dispatcher: table-- the dispatcher that ran the command State: table-- A blank table that can be used to store user-defined information about this command's current execution. This could potentially be used with hooks to add information to this table which your command or other hooks could consume. }   "},{"title":"TypeDefinition<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#TypeDefinition<T>","content":"&lt;/&gt; interface TypeDefinition&lt;T&gt; { DisplayName: string-- The display name of the type Prefixes: string-- The prefixes that this type can use Transform: ( rawText: string, executor: Player ) → any-- A function that transforms the raw text into the desired type Validate: (value: T) → ( boolean, string? )-- A function that validates the value. Returns a boolean and an optional error message. ValidateOnce: (value: T) → ( boolean, string? )-- A function that validates the value once. Returns a boolean and an optional error message. Autocomplete: (value: T) → ( {string}, {IsPartial: boolean?} )-- A function that returns a list of possible completions for the value. Returns a list of strings and an optional boolean indicating if the completions are partial. Parse: (value: T) → any-- A function that parses the value Default: (plr: Player ) → string-- A function that returns the default value for the type Listable: boolean-- Whether or not this type is listable }   "},{"title":"CommandArgument​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandArgument","content":"&lt;/&gt; interface CommandArgument { Type: string | TypeDefinition&lt;any&gt;-- The type of the argument Name: string-- The name of the argument Description: string-- The description of the argument Optional: boolean-- Whether or not this argument is optional Default: any-- The default value of the argument }   "},{"title":"CommandDefinition<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandDefinition<T>","content":"&lt;/&gt; interface CommandDefinition&lt;T&gt; { Name: string-- The name of the command Description: string-- The description of the command Aliases: {string}?-- The aliases of the command Group: any?-- The group this command is a part of Args: {CommandArgument | (context: CommandContext&lt;T&gt;) → CommandArgument}-- The arguments of the command Data: (( context: CommandContext&lt;T&gt;, ...any ) → any)?-- The data of the command AutoExec: {string}?-- The autoexec of the command ClientRun: (( context: CommandContext&lt;T&gt;, ...any ) → string?)?-- The client run of the command }  "},{"title":"ExampleResourceTypeData","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ExampleResourceTypeData","content":"On this page ExampleResourceTypeData An Example ResourceTypeData file. This is used to define the general behavior of a droplet type. local GenericPart = Instance.new(&quot;Part&quot;) GenericPart.Name = &quot;GenericPart&quot; GenericPart.Transparency = 1 GenericPart.Size = Vector3.one GenericPart.Anchored = true GenericPart.CanCollide = false GenericPart.CanTouch = false GenericPart.CanQuery = false GenericPart.Massless = true -------------------------------------------------------------------------------- --// Data //-- -------------------------------------------------------------------------------- return { Defaults = { Value = NumberRange.new(0.6, 1.4); -- The value you want the droplet to have. This can be anything. -- Metadata = {}; -- You typically shouldnt default metadata. Count = NumberRange.new(2, 5); -- Number of droplets to spawn LifeTime = NumberRange.new(50, 60); -- Time before the droplet dissapears EjectionDuration = 1; -- Time it takes to spew out all the droplets EjectionHorizontalVelocity = NumberRange.new(0, 25); EjectionVerticalVelocity = NumberRange.new(25, 50); CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector; Mass = 1; -- Mass of the droplet (Used in magnitization calculations) MaxForce = math.huge; -- Maximum steering force applied to the droplet when magnitized to a player MaxVelocity = 150; -- Maxiumum velocity of the droplet when magnitized to a player CollectionRadius = 1.5; -- Radius from center of player the droplet must be to be considered 'collected' }; --[[ Called when a new droplet is created. Use this to setup your visuals and any variables you need to keep track of. All parts within this should be Anchored = false, CanCollide = false, and Massless = true. The return value of this function can be accessed via Droplet:GetSetupData() ]] SetupDroplet = function(droplet: Droplet) local Value = droplet:GetValue() :: number local VisualModel = Instance.new(&quot;Model&quot;) VisualModel.Name = &quot;VisualModel&quot; local OuterPart = GenericPart:Clone() OuterPart.Name = &quot;Outer&quot; OuterPart.Material = Enum.Material.Glass OuterPart.Transparency = 0.5 OuterPart.Color = Color3.fromRGB(16, 206, 16) OuterPart.Size = Vector3.one * Value OuterPart.Anchored = false OuterPart.Parent = VisualModel VisualModel.PrimaryPart = OuterPart local NumGen = Random.new() local InnerPart = OuterPart:Clone() InnerPart.Material = Enum.Material.Neon InnerPart.Name = &quot;Inner&quot; InnerPart.Color = Color3.fromRGB(219, 189, 18) InnerPart.Transparency = 0 InnerPart.CastShadow = false InnerPart.Size *= 0.6 + NumGen:NextNumber(-0.1, 0.1) InnerPart.CFrame = OuterPart.CFrame + Vector3.new( NumGen:NextNumber(-0.1, 0.1), NumGen:NextNumber(-0.1, 0.1), NumGen:NextNumber(-0.1, 0.1) ) InnerPart.Parent = VisualModel local Weld = Instance.new(&quot;WeldConstraint&quot;) Weld.Part0 = OuterPart Weld.Part1 = InnerPart Weld.Parent = VisualModel droplet:AddTask(task.spawn(function() for i = 0.025, 1, 0.025 do VisualModel:ScaleTo(i) task.wait() end VisualModel:ScaleTo(1) end), nil, &quot;GrowThread&quot;) droplet:AttachModel(VisualModel) return { VisualModel = VisualModel; SpinDirection = if math.random() &gt; 0.5 then 1 else -1; } end; -- Ran when the droplet is within render range of the LocalPlayer's Camera OnRenderUpdate = function(droplet: Droplet, rendertimeElapsed: number) local SetupData = droplet:GetSetupData() local OffsetCFrame = CFrame.new() do -- Bobbing local AMPLITUDE = 1 -- Studs of vertical movement (+- half of this) local FREQUENCY = 0.25 -- Cycles per second local Y = (AMPLITUDE * 0.5) * -math.cos((rendertimeElapsed*math.pi) * (FREQUENCY)) OffsetCFrame *= CFrame.new(0, AMPLITUDE + Y, 0) end do -- Rotating local TimeToMakeOneRotation = 4 local RotationsPerSecond = 1/TimeToMakeOneRotation OffsetCFrame *= CFrame.Angles(0, (rendertimeElapsed*math.pi) * RotationsPerSecond * SetupData.SpinDirection , 0) end return OffsetCFrame end; OnDropletTimeout = function(droplet: Droplet) local VisualModel = droplet:GetSetupData().VisualModel droplet:RemoveTask(&quot;GrowThread&quot;) for i = 1, 0.025, -0.025 do VisualModel:ScaleTo(i) task.wait() end end; OnClientClaim = function(playerWhoClaimed: Player, droplet: Droplet) -- droplet:Collect(playerWhoClaimed) end; --[[ Called when the droplet hits the player and is considered collected. This is ran on the client only. It should be used for collection effects and other client side things. ]] OnClientCollect = function(playerWhoCollected: Player, droplet: Droplet) local Value = droplet:GetValue() :: number local Part = GenericPart:Clone() Part.CFrame = droplet:GetPivot() task.delay(2, function() Part:Destroy() end) local CollectionSound = Instance.new(&quot;Sound&quot;) CollectionSound.SoundId = &quot;rbxassetid://402143943&quot; CollectionSound.Volume = 0.25 local PitchShift = Instance.new(&quot;PitchShiftSoundEffect&quot;) PitchShift.Octave = 2 - Value/1.5 PitchShift.Parent = CollectionSound CollectionSound.Parent = Part Part.Parent = workspace CollectionSound:Play() end; --[[ Called once the client informs the server that it has collected the droplet. ]] OnServerCollect = function(playerWhoCollected: Player, value: any, metadata: any) local ExpValue: number = value local leaderstats = playerWhoCollected:FindFirstChild(&quot;leaderstats&quot;) if not leaderstats then leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; leaderstats.Parent = playerWhoCollected end local expStat = leaderstats:FindFirstChild(&quot;Exp&quot;) if not expStat then expStat = Instance.new(&quot;NumberValue&quot;) expStat.Name = &quot;Exp&quot; expStat.Parent = leaderstats end expStat.Value += ExpValue -- Add the value to the player's &quot;exp&quot;. This is just an example. end; } ","keywords":""},{"title":"RemoteComponent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RemoteComponent","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#types","content":" "},{"title":"RemoteComponent​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#RemoteComponent","content":"&lt;/&gt; interface RemoteComponent { Client: table?-- Only available on the server. Set this to a table to expose it to the client. Server: table?-- Only available on the client. The indices of this are inferred from the server. }  "},{"title":"Functions​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#functions","content":" "},{"title":"createEvent () -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createEvent () -> MARKER","content":"&lt;/&gt; RemoteComponent.createEvent () -&gt; MARKER() → () Redirects to NetWire.createEvent  "},{"title":"createUnreliableEvent () -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createUnreliableEvent () -> MARKER","content":"&lt;/&gt; RemoteComponent.createUnreliableEvent () -&gt; MARKER() → () Redirects to NetWire.createUnreliableEvent  "},{"title":"createProperty (initialValue: any) -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createProperty (initialValue: any) -> MARKER","content":"&lt;/&gt; RemoteComponent.createProperty (initialValue: any) -&gt; MARKER() → () Redirects to NetWire.createProperty "},{"title":"BaseTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#types","content":" "},{"title":"Id​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Id","content":"&lt;/&gt; type Id = number The id of a replicator.  "},{"title":"SearchCondition​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#SearchCondition","content":"&lt;/&gt; type SearchCondition = string | ClassToken | Tags | ( replicator: BaseTableReplicator, manager: TableManager? ) → (boolean) A condition that can be used to filter replicators. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If the condition is a function then it should return a boolean to indicate success. If the condition is a ClassToken then it will check if the replicator's class token matches the given token. If the condition is a string then it will check if the replicator's class token name matches the given string. If the condition is a Tags dictionary then it will check if the replicator's tags are a superset of the given tags.  "},{"title":"Tags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Tags","content":"&lt;/&gt; type Tags = {[string]: any} The valid tag format that can be given to a TableReplicator. This table will become locked once given to a TableReplicator. Do not attempt to modify it after the fact. local tags = table.freeze { OwnerId = Player.UserId; ToolType = &quot;Sword&quot;; }  "},{"title":"Properties​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#properties","content":" "},{"title":"ReplicatorCreated​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#ReplicatorCreated","content":"&lt;/&gt; BaseTableReplicator.ReplicatorCreated: Signal&lt;BaseTableReplicator&gt; A signal that fires whenever a new replicator is created. "},{"title":"Functions​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#functions","content":" "},{"title":"iterating over BaseTableReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#__iter","content":"Metamethod &lt;/&gt; for in BaseTableReplicator do Iterates over all replicators that are currently in memory. for _, replicator in TableReplicator do print(replicator:GetServerId()) end   "},{"title":"getFromServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getFromServerId","content":"Static &lt;/&gt; BaseTableReplicator.getFromServerId(id: Id) → BaseTableReplicator? Returns the replicator with the given id if one exists.  "},{"title":"forEach​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#forEach","content":"Static &lt;/&gt; BaseTableReplicator.forEach( condition: SearchCondition, fn: ( replicator: BaseTableReplicator, manager: TableManager? ) → (), allowDestroyedReplicators: boolean? ) → () forEach is a special function that allows you to run a function on all replicators that currently exist or will exist that match the given condition. caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned.  "},{"title":"promiseFirstReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#promiseFirstReplicator","content":"Static &lt;/&gt; BaseTableReplicator.promiseFirstReplicator( condition: SearchCondition, allowDestroyedReplicators: boolean? ) → Promise&lt;BaseTableReplicator,TableManager?&gt; promiseFirstReplicator is a special function that allows you to run a function on the first replicator to satisfy the given condition. If no replicator currently exists that satisfies the condition then it will wait for one to be created. BaseTableReplicator.promiseFirstReplicator(&quot;Test&quot;) caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned.  "},{"title":"getAll​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getAll","content":"Static &lt;/&gt; BaseTableReplicator.getAll(classTokenName: string?) → {BaseTableReplicator} Fetches all replicators that are currently in memory. This is very slow and should be used sparingly.  "},{"title":"onNew​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#onNew","content":"Static &lt;/&gt; BaseTableReplicator.onNew( classToken: CanBeArray&lt;string | ClassToken&gt;, fn: (replicator: BaseTableReplicator) → () ) → () → () Listens for new replicators that are created with the given class token.  "},{"title":"GetTableManager​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTableManager","content":"&lt;/&gt; BaseTableReplicator:GetTableManager() → TableManager Gets the TableManager that is being replicated.  "},{"title":"GetServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetServerId","content":"&lt;/&gt; BaseTableReplicator:GetServerId() → Id Returns the server id for this replicator. On the Server this is equivalent to :GetId()  "},{"title":"GetTokenName​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTokenName","content":"&lt;/&gt; BaseTableReplicator:GetTokenName() → string Fetches the name of the class token that this replicator is using.  "},{"title":"IsTopLevel​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsTopLevel","content":"&lt;/&gt; BaseTableReplicator:IsTopLevel() → boolean Returns whether or not this replicator is a top level replicator. A top level replicator is a replicator that has no parent. Only top level replicators can have their ReplicationTargets set.  "},{"title":"GetParent​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetParent","content":"&lt;/&gt; BaseTableReplicator:GetParent() → BaseTableReplicator? Returns the parent of this replicator if it has one. If this replicator is a top level replicator then this will return nil.  "},{"title":"GetChildren​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetChildren","content":"&lt;/&gt; BaseTableReplicator:GetChildren() → {BaseTableReplicator} Returns the immediate children of this replicator.  "},{"title":"GetDescendants​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetDescendants","content":"&lt;/&gt; BaseTableReplicator:GetDescendants() → {BaseTableReplicator} Returns the descendants of this replicator.  "},{"title":"FindFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#FindFirstChild","content":"&lt;/&gt; BaseTableReplicator:FindFirstChild( condition: SearchCondition, recursive: boolean? ) → BaseTableReplicator? Finds the first child that satisfies the given condition. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If recursive is true then it will search through all descendants. local child = tr:FindFirstChild(function(child) local manager = child:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 })   "},{"title":"PromiseFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#PromiseFirstChild","content":"&lt;/&gt; BaseTableReplicator:PromiseFirstChild(condition: SearchCondition) → Promise&lt;BaseTableReplicator&gt; Returns a promise that resolves when the first child that satisfies the given function is found. tr:PromiseFirstChild(function(replicator) local manager = replicator:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 }):andThen(function(replicator) print(&quot;Found child with data key 'Test' equal to 1!&quot;) end) tr:PromiseFirstChild(&quot;Test&quot;):andThen(function(replicator) print(&quot;Found child with classtoken 'Test'!&quot;) end) tr:PromiseFirstChild({UserId == 12345}):andThen(function(replicator) print(&quot;Found child with UserId Tag matching 12345!&quot;) end)   "},{"title":"GetTag​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTag","content":"&lt;/&gt; BaseTableReplicator:GetTag(tagKey: string) → any Returns the value of the given tag for this replicator.  "},{"title":"GetTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTags","content":"&lt;/&gt; BaseTableReplicator:GetTags() → Tags Returns the tags dictionary for this replicator.  "},{"title":"IsSupersetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSupersetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSupersetOfTags(tags: Tags) → boolean Checks whether or not the given tags are a subset of this replicator's tags. ELI5: Are all the given tags also on this replicator? Aliased as :ContainsAllTags(tags) ```lua local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSupersetOfTags({ Test1 = 1, }) -- true tr:IsSupersetOfTags({ Test2 = 2, }) -- true  "},{"title":"IsSubsetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSubsetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSubsetOfTags(tags: Tags) → boolean Checks whether or not this replicator's tags are a subset of the given tags. ELI5: Are all the tags on this replicator also on the given tags? Aliased as :IsWithinTags(tags) local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSubsetOfTags({ Test1 = 1, Test2 = 2, Test3 = 3, }) -- true tr:IsSubsetOfTags({ Test1 = 1, }) -- false  "},{"title":"PlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerDataManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#types","content":" "},{"title":"ServerPlayerDataManager​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#ServerPlayerDataManager","content":"&lt;/&gt; type ServerPlayerDataManager = ServerPlayerDataManager   "},{"title":"ClientPlayerDataManager​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#ClientPlayerDataManager","content":"&lt;/&gt; type ClientPlayerDataManager = ClientPlayerDataManager  "},{"title":"Properties​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#Server","content":"This item only works when running on the server. Server &lt;/&gt; PlayerDataManager.Server: ServerPlayerDataManager The ServerPlayerDataManager class.  "},{"title":"Client​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#Client","content":"This item only works when running on the client. Client &lt;/&gt; PlayerDataManager.Client: ClientPlayerDataManager The ClientPlayerDataManager class. "},{"title":"NetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/NetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Server","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.Server: ServerNetWire Access point for server-side NetWire functionality. Can also be called as a function to create/access a new server wire instance. local myWire = NetWire.Server(&quot;MyWire&quot;) local myWireOther = NetWire.Server.new(&quot;MyWire&quot;) print(myWire == myWireOther) -- true info NetWire memoizes the created wire instance so any subsequent calls with the same name will return the same wire instance.  "},{"title":"Client​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Client","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.Client: ClientNetWire Access point for client-side NetWire functionality. Can also be called as a function to create/access a new client wire instance. local myWire = NetWire.Client(&quot;MyWire&quot;) local myWireOther = NetWire.Client.new(&quot;MyWire&quot;) print(myWire == myWireOther) -- true  "},{"title":"Functions​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#functions","content":" "},{"title":"createEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createEvent","content":"&lt;/&gt; NetWire.createEvent( inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyEvent = NetWire.createEvent() MyWire.MyEvent:Connect(function(plr: Player, msg: string) print(plr, &quot;said:&quot;, msg) end)   "},{"title":"createUnreliableEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createUnreliableEvent","content":"&lt;/&gt; NetWire.createUnreliableEvent( inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteEvent Returns an EventMarker that is used to mark where an unreliable remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyEvent = NetWire.createUnreliableEvent() MyWire.MyEvent:FireAll(&quot;Hello, world!&quot;)   "},{"title":"createProperty​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createProperty","content":"&lt;/&gt; NetWire.createProperty( initialValue: any?,-- Initial value for the property inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteProperty Returns a PropertyMarker that is used to mark where a remoteProperty should be created. NetWire will transform this marker into an actual ServerRemoteProperty. The returned value of this is actually a symbol and only becomes usable when set to the index of a ServerNetWire. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyProperty = NetWire.createProperty(&quot;Initial Value&quot;) MyWire.MyProperty:Set(&quot;New Value&quot;) print(MyWire.MyProperty:Get())  "},{"title":"PromValue","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PromValue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#ClassName","content":"&lt;/&gt; PromValue.ClassName: &quot;PromValue&quot; The name of the class.  "},{"title":"Changed​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Changed","content":"&lt;/&gt; PromValue.Changed: Signal&lt;new: any,old: any&gt; A signal that fires when the value of the PromValue changes. "},{"title":"Functions​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#new","content":"Static &lt;/&gt; PromValue.new( initialValue: any?-- an optional initial value to set the PromValue to. ) → PromValue Creates a new PromValue  "},{"title":"Set​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Set","content":"&lt;/&gt; PromValue:Set(newValue: any) → () Sets the value of the PromValue and fires the Changed signal.  "},{"title":"Get​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Get","content":"&lt;/&gt; PromValue:Get() → any Immediately returns the stored value.  "},{"title":"IsReady​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#IsReady","content":"&lt;/&gt; PromValue:IsReady() → boolean Returns whether or not the value has been set yet  "},{"title":"OnReady​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#OnReady","content":"&lt;/&gt; PromValue:OnReady( fn: ((value: any) → ...any)?-- an optional function to call when the value is set. ) → Promise&lt;any&gt; Returns a promise that resolves with the value when it has been set atleast once. If given a function then it will run it the first time it is set, this is equivalent to just chaining :andThen(). Alias for :Promise()  "},{"title":"Promise​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Promise","content":"&lt;/&gt; PromValue:Promise( fn: ((value: any) → ...any)?-- an optional function to call when the value is set. ) → Promise&lt;any&gt; Alias for :OnReady() "},{"title":"ScriptConnection","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ScriptConnection","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#properties","content":" "},{"title":"Connected​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#Connected","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ScriptConnection.Connected: boolean A boolean which determines if a ScriptConnection is active or not. "},{"title":"Functions​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#functions","content":" "},{"title":"Disconnect​","type":1,"pageTitle":"ScriptConnection","url":"/ModulesOnRails/api/ScriptConnection#Disconnect","content":"&lt;/&gt; ScriptConnection:Disconnect() → () Disconnects a connection, any :Fire calls from now on will not invoke this connection's handler. local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; true connection:Disconnect() connection.Connected -&gt; false  "},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal&lt;any&gt; Fires when the property receives an updated value from the server. clientRemoteProperty.Changed:Connect(function(value) print(&quot;New value&quot;, value) end)   "},{"title":"Changed​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal&lt;any&gt; Fires when the property receives an updated value from the server. clientRemoteProperty.Changed:Connect(function(value) print(&quot;New value&quot;, value) end)   "},{"title":"Changed​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal&lt;any&gt; Fires when the property receives an updated value from the server. clientRemoteProperty.Changed:Connect(function(value) print(&quot;New value&quot;, value) end)  "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#functions","content":" "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Gets the value of the property object. caution This value might not be ready right away. Use OnReady() or IsReady() before calling Get(). If not ready, this value will return nil.  "},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty:OnReady() → Promise&lt;any&gt; Returns a Promise which resolves once the property object is ready to be used. The resolved promise will also contain the value of the property. -- Use andThen clause: clientRemoteProperty:OnReady():andThen(function(initialValue) print(initialValue) end) -- Use await: local success, initialValue = clientRemoteProperty:OnReady():await() if success then print(initialValue) end   "},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty:IsReady() → boolean Returns true if the property object is ready to be used. In other words, it has successfully gained connection to the server-side version and has synced in the initial value. if clientRemoteProperty:IsReady() then local value = clientRemoteProperty:Get() end   "},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty:Observe(observer: (any) → nil) → Connection Observes the value of the property. The observer will be called right when the value is first ready, and every time the value changes. This is safe to call immediately (i.e. no need to use IsReady or OnReady before using this method). Observing is essentially listening to Changed, but also sends the initial value right away (or at least once OnReady is completed). local function ObserveValue(value) print(value) end clientRemoteProperty:Observe(ObserveValue)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the ClientRemoteProperty object.  "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Gets the value of the property object. caution This value might not be ready right away. Use OnReady() or IsReady() before calling Get(). If not ready, this value will return nil.  "},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty:OnReady() → Promise&lt;any&gt; Returns a Promise which resolves once the property object is ready to be used. The resolved promise will also contain the value of the property. -- Use andThen clause: clientRemoteProperty:OnReady():andThen(function(initialValue) print(initialValue) end) -- Use await: local success, initialValue = clientRemoteProperty:OnReady():await() if success then print(initialValue) end   "},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty:IsReady() → boolean Returns true if the property object is ready to be used. In other words, it has successfully gained connection to the server-side version and has synced in the initial value. if clientRemoteProperty:IsReady() then local value = clientRemoteProperty:Get() end   "},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty:Observe(observer: (any) → nil) → Connection Observes the value of the property. The observer will be called right when the value is first ready, and every time the value changes. This is safe to call immediately (i.e. no need to use IsReady or OnReady before using this method). Observing is essentially listening to Changed, but also sends the initial value right away (or at least once OnReady is completed). local function ObserveValue(value) print(value) end clientRemoteProperty:Observe(ObserveValue)   "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Gets the value of the property object. caution This value might not be ready right away. Use OnReady() or IsReady() before calling Get(). If not ready, this value will return nil.  "},{"title":"OnReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#OnReady","content":"&lt;/&gt; ClientRemoteProperty:OnReady() → Promise&lt;any&gt; Returns a Promise which resolves once the property object is ready to be used. The resolved promise will also contain the value of the property. -- Use andThen clause: clientRemoteProperty:OnReady():andThen(function(initialValue) print(initialValue) end) -- Use await: local success, initialValue = clientRemoteProperty:OnReady():await() if success then print(initialValue) end   "},{"title":"IsReady​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#IsReady","content":"&lt;/&gt; ClientRemoteProperty:IsReady() → boolean Returns true if the property object is ready to be used. In other words, it has successfully gained connection to the server-side version and has synced in the initial value. if clientRemoteProperty:IsReady() then local value = clientRemoteProperty:Get() end   "},{"title":"Observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Observe","content":"&lt;/&gt; ClientRemoteProperty:Observe(observer: (any) → nil) → Connection Observes the value of the property. The observer will be called right when the value is first ready, and every time the value changes. This is safe to call immediately (i.e. no need to use IsReady or OnReady before using this method). Observing is essentially listening to Changed, but also sends the initial value right away (or at least once OnReady is completed). local function ObserveValue(value) print(value) end clientRemoteProperty:Observe(ObserveValue)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"/ModulesOnRails/api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the ClientRemoteProperty object. "},{"title":"ScriptSignal","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ScriptSignal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#new","content":"&lt;/&gt; ScriptSignal.new() → ScriptSignal Creates a ScriptSignal object.  "},{"title":"Is​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Is","content":"&lt;/&gt; ScriptSignal.Is(object: any) → boolean Returns a boolean determining if the object is a ScriptSignal. local janitor = Janitor.new() local signal = ScriptSignal.new() ScriptSignal.Is(signal) -&gt; true ScriptSignal.Is(janitor) -&gt; false   "},{"title":"IsActive​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#IsActive","content":"&lt;/&gt; ScriptSignal:IsActive() → boolean Returns a boolean which determines if a ScriptSignal object is active. ScriptSignal:IsActive() -&gt; true ScriptSignal:Destroy() ScriptSignal:IsActive() -&gt; false   "},{"title":"Connect​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Connect","content":"&lt;/&gt; ScriptSignal:Connect(handler: (...: any) → ()) → ScriptConnection Connects a handler to a ScriptSignal object. ScriptSignal:Connect(function(text) print(text) end) ScriptSignal:Fire(&quot;Something&quot;) ScriptSignal:Fire(&quot;Something else&quot;) -- &quot;Something&quot; and then &quot;Something else&quot; are printed   "},{"title":"Once​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Once","content":"&lt;/&gt; ScriptSignal:Once(handler: (...: any) → ()) → ScriptConnection Connects a handler to a ScriptSignal object, but only allows that connection to run once. Any :Fire calls called afterwards won't trigger anything. ScriptSignal:Once(function() print(&quot;Connection fired&quot;) end) ScriptSignal:Fire() ScriptSignal:Fire() -- &quot;Connection fired&quot; is only fired once   "},{"title":"Wait​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; ScriptSignal:Wait() → ...any Yields the thread until a :Fire call occurs, returns what the signal was fired with. task.spawn(function() print( ScriptSignal:Wait() ) end) ScriptSignal:Fire(&quot;Arg&quot;, nil, 1, 2, 3, nil) -- &quot;Arg&quot;, nil, 1, 2, 3, nil are printed   "},{"title":"Fire​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Fire","content":"&lt;/&gt; ScriptSignal:Fire(...: any) → () Fires a ScriptSignal object with the arguments passed. ScriptSignal:Connect(function(text) print(text) end) ScriptSignal:Fire(&quot;Some Text...&quot;) -- &quot;Some Text...&quot; is printed twice   "},{"title":"DisconnectAll​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#DisconnectAll","content":"&lt;/&gt; ScriptSignal:DisconnectAll() → () Disconnects all connections from a ScriptSignal object without making it unusable. local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; true ScriptSignal:DisconnectAll() connection.Connected -&gt; false   "},{"title":"Destroy​","type":1,"pageTitle":"ScriptSignal","url":"/ModulesOnRails/api/ScriptSignal#Destroy","content":"&lt;/&gt; ScriptSignal:Destroy() → () Destroys a ScriptSignal object, disconnecting all connections and making it unusable. ScriptSignal:Destroy() local connection = ScriptSignal:Connect(function() end) connection.Connected -&gt; false  "},{"title":"ClientComm","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#types","content":" "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions.  "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#new","content":"&lt;/&gt; ClientComm.new( parent: Instance , usePromise: boolean, namespace: string? ) → ClientComm Constructs a ClientComm object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds. local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true) -- If using a unique namespace with ServerComm, include it as second argument: local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true, &quot;MyNamespace&quot;)   "},{"title":"new​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#new","content":"&lt;/&gt; ClientComm.new( parent: Instance , usePromise: boolean, namespace: string? ) → ClientComm Constructs a ClientComm object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds. local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true) -- If using a unique namespace with ServerComm, include it as second argument: local clientComm = ClientComm.new(game:GetService(&quot;ReplicatedStorage&quot;), true, &quot;MyNamespace&quot;)   "},{"title":"GetFunction​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetFunction","content":"&lt;/&gt; ClientComm:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerComm. The function can then be called to invoke the server. If this ClientComm object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverComm = ServerComm.new(someParent) serverComm:BindFunction(&quot;MyFunction&quot;, function(player, msg) return msg:upper() end) -- Client-side: local clientComm = ClientComm.new(someParent) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientComm = ClientComm.new(someParent, true) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetSignal","content":"&lt;/&gt; ClientComm:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerComm with the same matching name. local mySignal = clientComm:GetSignal(&quot;MySignal&quot;) -- Listen for data from the server: mySignal:Connect(function(message) print(&quot;Received message from server:&quot;, message) end) -- Send data to the server: mySignal:Fire(&quot;Hello!&quot;)   "},{"title":"GetProperty​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetProperty","content":"&lt;/&gt; ClientComm:GetProperty( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteProperty Returns a new ClientRemoteProperty that mirrors the matching RemoteProperty created by ServerComm with the same matching name. Take a look at the ClientRemoteProperty documentation for more info, such as understanding how to wait for data to be ready. local mapInfo = clientComm:GetProperty(&quot;MapInfo&quot;) -- Observe the initial value of mapInfo, and all subsequent changes: mapInfo:Observe(function(info) print(&quot;Current map info&quot;, info) end) -- Check to see if data is initially ready: if mapInfo:IsReady() then -- Get the data: local info = mapInfo:Get() end -- Get a promise that resolves once the data is ready (resolves immediately if already ready): mapInfo:OnReady():andThen(function(info) print(&quot;Map info is ready with info&quot;, info) end) -- Same as above, but yields thread: local success, info = mapInfo:OnReady():await()   "},{"title":"BuildObject​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#BuildObject","content":"&lt;/&gt; ClientComm:BuildObject( inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → table Returns an object which maps RemoteFunctions as methods and RemoteEvents as fields. -- Server-side: serverComm:BindFunction(&quot;Test&quot;, function(player) end) serverComm:CreateSignal(&quot;MySignal&quot;) serverComm:CreateProperty(&quot;MyProperty&quot;, 10) -- Client-side local obj = clientComm:BuildObject() obj:Test() obj.MySignal:Connect(function(data) end) obj.MyProperty:Observe(function(value) end)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#Destroy","content":"&lt;/&gt; ClientComm:Destroy() → () Destroys the ClientComm object. Sets the objects to be a table that errors if you attempt to access any property.  "},{"title":"GetFunction​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetFunction","content":"&lt;/&gt; ClientComm:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerComm. The function can then be called to invoke the server. If this ClientComm object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverComm = ServerComm.new(someParent) serverComm:BindFunction(&quot;MyFunction&quot;, function(player, msg) return msg:upper() end) -- Client-side: local clientComm = ClientComm.new(someParent) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientComm = ClientComm.new(someParent, true) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetSignal","content":"&lt;/&gt; ClientComm:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerComm with the same matching name. local mySignal = clientComm:GetSignal(&quot;MySignal&quot;) -- Listen for data from the server: mySignal:Connect(function(message) print(&quot;Received message from server:&quot;, message) end) -- Send data to the server: mySignal:Fire(&quot;Hello!&quot;)   "},{"title":"GetProperty​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#GetProperty","content":"&lt;/&gt; ClientComm:GetProperty( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteProperty Returns a new ClientRemoteProperty that mirrors the matching RemoteProperty created by ServerComm with the same matching name. Take a look at the ClientRemoteProperty documentation for more info, such as understanding how to wait for data to be ready. local mapInfo = clientComm:GetProperty(&quot;MapInfo&quot;) -- Observe the initial value of mapInfo, and all subsequent changes: mapInfo:Observe(function(info) print(&quot;Current map info&quot;, info) end) -- Check to see if data is initially ready: if mapInfo:IsReady() then -- Get the data: local info = mapInfo:Get() end -- Get a promise that resolves once the data is ready (resolves immediately if already ready): mapInfo:OnReady():andThen(function(info) print(&quot;Map info is ready with info&quot;, info) end) -- Same as above, but yields thread: local success, info = mapInfo:OnReady():await()   "},{"title":"BuildObject​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#BuildObject","content":"&lt;/&gt; ClientComm:BuildObject( inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → table Returns an object which maps RemoteFunctions as methods and RemoteEvents as fields. -- Server-side: serverComm:BindFunction(&quot;Test&quot;, function(player) end) serverComm:CreateSignal(&quot;MySignal&quot;) serverComm:CreateProperty(&quot;MyProperty&quot;, 10) -- Client-side local obj = clientComm:BuildObject() obj:Test() obj.MySignal:Connect(function(data) end) obj.MyProperty:Observe(function(value) end)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientComm","url":"/ModulesOnRails/api/ClientComm#Destroy","content":"&lt;/&gt; ClientComm:Destroy() → () Destroys the ClientComm object. "},{"title":"AdjustableTimerManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/AdjustableTimerManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#types","content":" "},{"title":"TimerId​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#TimerId","content":"&lt;/&gt; type TimerId = string A unique identifier for the replication of an AdjustableTimer.  "},{"title":"Tags​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#Tags","content":"&lt;/&gt; type Tags = {[any]: any} Represents a dictionary of tags associated with a timer. Tags can be used to categorize or filter timers based on specific attributes. local tags = { Category = &quot;Game&quot;, Level = 5 }   "},{"title":"TagMatchType​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#TagMatchType","content":"&lt;/&gt; type TagMatchType = &quot;exact&quot; | &quot;any&quot; | &quot;superset&quot; | &quot;subset&quot; Defines the type of matching to perform when comparing tags. &quot;exact&quot;: All key-value pairs in the tags must match exactly. &quot;any&quot;: At least one key-value pair in the tags must match. &quot;superset&quot;: The timer's tags must contain all key-value pairs of the given tags. &quot;subset&quot;: The timer's tags must be contained within the key-value pairs of the given tags. "},{"title":"Properties​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#properties","content":" "},{"title":"TimerRegistered​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#TimerRegistered","content":"&lt;/&gt; AdjustableTimerManager.TimerRegistered: Signal&lt;AdjustableTimer,TimerId&gt; Signal that fires when a timer is registered with the manager. local connection = AdjustableTimerManager.TimerRegistered:Connect(function(timer, id) print(&quot;Timer registered:&quot;, timer, id) end)   "},{"title":"TimerDisconnected​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#TimerDisconnected","content":"&lt;/&gt; AdjustableTimerManager.TimerDisconnected: Signal&lt;AdjustableTimer,TimerId&gt; Signal that fires when a timer is disconnected from the manager. local connection = AdjustableTimerManager.TimerDisconnected:Connect(function(timer, id) print(&quot;Timer disconnected:&quot;, timer, id) end)  "},{"title":"Functions​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#functions","content":" "},{"title":"ReplicateTimer​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#ReplicateTimer","content":"This item only works when running on the server. Server &lt;/&gt; AdjustableTimerManager:ReplicateTimer( timer: AdjustableTimer,-- The timer to replicate. tags: Tags?-- Optional tags to associate with the timer. ) → TimerId-- The ID of the replicated timer. Replicates a timer to all clients. local id = AdjustableTimerManager:ReplicateTimer(timer, { Tag = &quot;Example&quot; }) Memory Leaks Ensure to call AdjustableTimerManager:DisconnectTimer(timer) when the timer is no longer needed to prevent memory leaks.  "},{"title":"DisconnectTimer​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#DisconnectTimer","content":"This item only works when running on the server. Server &lt;/&gt; AdjustableTimerManager:DisconnectTimer( timer: AdjustableTimer-- The timer to disconnect. ) → () Disconnects a timer from the manager and stops replicating it to clients. AdjustableTimerManager:DisconnectTimer(timer)   "},{"title":"GetTimerFromId​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetTimerFromId","content":"&lt;/&gt; AdjustableTimerManager:GetTimerFromId(id: TimerId) → AdjustableTimer? Returns the timer associated with the given ID, or nil if it doesn't exist. local timer = AdjustableTimerManager:GetTimerFromId(timerId)   "},{"title":"GetTimerId​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetTimerId","content":"&lt;/&gt; AdjustableTimerManager:GetTimerId(timer: AdjustableTimer) → TimerId? Returns the ID of the timer if it is registered, otherwise returns nil. local id = AdjustableTimerManager:GetTimerId(timer)   "},{"title":"GetTimerTags​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetTimerTags","content":"&lt;/&gt; AdjustableTimerManager:GetTimerTags( timer: AdjustableTimer | TimerId-- The timer or timer ID to get tags for. ) → Tags?-- The tags associated with the timer. Returns the tags associated with the given timer or timer ID. Tags are defined on the server when initially replicating the timer. local tags = AdjustableTimerManager:GetTimerTags(timer)   "},{"title":"GetTimersWithTags​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetTimersWithTags","content":"&lt;/&gt; AdjustableTimerManager:GetTimersWithTags( tagsToMatch: Tags,-- The tags to match against. matchType: TagMatchType?-- The type of tag matching to perform. Defaults to &quot;exact&quot;. ) → {AdjustableTimer}-- An array of timers that satisfy the tag match. Returns an array of timers that match the given tags. local timers = AdjustableTimerManager:GetTimersWithTags({ Tag = &quot;Example&quot; })   "},{"title":"PromiseFirstTimerWithTags​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#PromiseFirstTimerWithTags","content":"&lt;/&gt; AdjustableTimerManager:PromiseFirstTimerWithTags( tagsToMatch: Tags,-- The tags to match against. matchType: TagMatchType?-- The type of tag matching to perform. Defaults to &quot;exact&quot;. ) → Promise&lt;AdjustableTimer&gt;-- A promise that resolves with the first matching timer. Returns a promise that resolves with the first timer that matches the given tags. If no timer is found, it will wait for a timer to be registered that matches the tags. AdjustableTimerManager:PromiseFirstTimerWithTags({ Tag = &quot;Example&quot; }):andThen(function(timer) print(timer) end)   "},{"title":"PromiseTimerWithId​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#PromiseTimerWithId","content":"&lt;/&gt; AdjustableTimerManager:PromiseTimerWithId( id: TimerId-- The ID of the timer to find. ) → Promise&lt;AdjustableTimer&gt;-- A promise that resolves with the timer. Returns a promise that resolves with the timer associated with the given ID. Example Code AdjustableTimerManager:PromiseTimerWithId(someTimerId):andThen(function(timer) print(timer) end)   "},{"title":"GetAllReplicatedTimers​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetAllReplicatedTimers","content":"&lt;/&gt; AdjustableTimerManager:GetAllReplicatedTimers() → {AdjustableTimer} Returns an array of all replicated timers. local timers = AdjustableTimerManager:GetAllReplicatedTimers()   "},{"title":"SyncTimer​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#SyncTimer","content":"&lt;/&gt; AdjustableTimerManager:SyncTimer( timer: TimerId | AdjustableTimer,-- The timer or ID of the timer to sync. player: Player? -- Optional player to sync the timer with. If not provided, syncs with all clients. (SERVER ONLY) ) → Promise&lt;TimerId,SerializedAdjustableTimer&gt;-- A promise that resolves with the timer ID and its serialized state. If called on the client, it will request the server to sync the timer so that their states match. If called on the server, it will sync the timer with all clients or a specific player. This method should only need to be used if you perform some manual changes to the timer on the client side, such as pausing it. You will need to call this to resync the timer state with the server. AdjustableTimerManager:SyncTimer(timerId):andThen(function(timerId, snapshot) print(&quot;Timer synced:&quot;, timerId, snapshot) end)  "},{"title":"ObjectCache","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ObjectCache","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#functions","content":" "},{"title":"setupModelForCacheMovement​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#setupModelForCacheMovement","content":"&lt;/&gt; ObjectCache.setupModelForCacheMovement(model: Model ) → () Sets up a model for cache movement by welding all of its descendant BaseParts to its PrimaryPart.  "},{"title":"isModelSetupForCacheMovement​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#isModelSetupForCacheMovement","content":"&lt;/&gt; ObjectCache.isModelSetupForCacheMovement(model: Model ) → boolean Checks if a model is setup for cache movement.  "},{"title":"new​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#new","content":"&lt;/&gt; ObjectCache.new(config: CacheConfig) → () "},{"title":"Types","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache##","content":""},{"title":"​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#CacheConfig","content":"interface CacheConfig { Template: T | () → T-- The template object to use for the cache. Must be a PVInstance or a function that returns a PVInstance. InitialSize: number?-- The initial size of the cache. Defaults to 10. ExpansionSize: number?-- The amount to expand the cache by. Defaults to 50. ObjectsParent: Instance? -- The parent to put the objects in. CacheParent: Instance? -- The parent to put the cache in. Name: string?-- The name of the cache. }  Creates a new ObjectCache. local myCache: ObjectCache&lt;Part&gt; = ObjectCache.new({ Template = function() local part = Instance.new(&quot;Part&quot;) part.Anchored = true return part end, }) Anchored Parts Make sure that your template object is anchored. Otherwise when it returns to the cache it will fall out of existence. info Luau LSP type inference for the template is not yet robust enough to properly infer the type of the template object. As a result, you should properly assign the right type to your cache object.  "},{"title":"Get​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Get","content":"&lt;/&gt; ObjectCache:Get(moveTo: CFrame? ) → T Gets an object from the cache, moving it to the specified CFrame if provided. Moving the returned object If you provide a CFrame, the movement is deferred so it can be bulk moved. Keep this in mind if you need to do other operations on the object immediately after moving it.  "},{"title":"Return​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Return","content":"&lt;/&gt; ObjectCache:Return(obj: T) → () Returns an object to the cache.  "},{"title":"ExpandCache​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#ExpandCache","content":"&lt;/&gt; ObjectCache:ExpandCache( Amount: number-- The amount to expand the cache by. ) → () Expands the cache by the specified amount.  "},{"title":"SetExpandAmount​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#SetExpandAmount","content":"&lt;/&gt; ObjectCache:SetExpandAmount( Amount: number-- The amount to expand the cache by. ) → () Sets the default amount to expand the cache by.  "},{"title":"IsInUse​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#IsInUse","content":"&lt;/&gt; ObjectCache:IsInUse(obj: PVInstance ) → boolean Returns whether the specified object is currently in use.  "},{"title":"BelongsTo​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#BelongsTo","content":"&lt;/&gt; ObjectCache:BelongsTo(obj: PVInstance ) → boolean Checks if an object belongs to this cache.  "},{"title":"Update​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Update","content":"&lt;/&gt; ObjectCache:Update() → () Forces an immediate position update for all objects in the cache.  "},{"title":"Destroy​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Destroy","content":"&lt;/&gt; ObjectCache:Destroy() → () Destroys the cache and all objects within it.  "},{"title":"ConnectOnReturn​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#ConnectOnReturn","content":"&lt;/&gt; ObjectCache:ConnectOnReturn( fn: (obj: T) → ()-- The function to run. ) → () → boolean-- A cleaner function to disconnect the connection. Sets a function to run when an object is returned to the cache. Passes the object that was returned as an argument. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil Connected: boolean }   "},{"title":"Connection​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil Connected: boolean } Represents a connection. "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player , ...: any ) → nil-- The function to connect ) → Connection Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireExcept","content":"&lt;/&gt; RemoteSignal:FireExcept( ignorePlayer: Player ,-- The client to ignore ...: any-- Arguments passed to the other clients ) → () Fires the signal to all clients except the specified client. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireFor","content":"&lt;/&gt; RemoteSignal:FireFor( players: {Player }, ...: any ) → () Fires a signal at the clients within the players table. This is useful when signals need to fire for a specific set of players. For more complex firing, see FireFilter. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. local players = {somePlayer1, somePlayer2, somePlayer3} remoteSignal:FireFor(players, &quot;Hello, players!&quot;)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object.  "},{"title":"IsUnreliable​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#IsUnreliable","content":"&lt;/&gt; RemoteSignal:IsUnreliable() → boolean Returns true if the underlying RemoteSignal is bound to an UnreliableRemoteEvent object.  "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player , ...: any ) → nil-- The function to connect ) → Connection Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireExcept​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireExcept","content":"&lt;/&gt; RemoteSignal:FireExcept( ignorePlayer: Player ,-- The client to ignore ...: any-- Arguments passed to the other clients ) → () Fires the signal to all clients except the specified client. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"FireFor​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#FireFor","content":"&lt;/&gt; RemoteSignal:FireFor( players: {Player }, ...: any ) → () Fires a signal at the clients within the players table. This is useful when signals need to fire for a specific set of players. For more complex firing, see FireFilter. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. local players = {somePlayer1, somePlayer2, somePlayer3} remoteSignal:FireFor(players, &quot;Hello, players!&quot;)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"/ModulesOnRails/api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object. "},{"title":"Heap","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Heap","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#functions","content":" "},{"title":"min​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#min","content":"static &lt;/&gt; Heap.min() → Heap&lt;T&gt;-- A min-heap instance. Creates a min-heap where the smallest element is always on top.  "},{"title":"max​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#max","content":"static &lt;/&gt; Heap.max() → Heap&lt;T&gt;-- A max-heap instance. Creates a max-heap where the largest element is always on top.  "},{"title":"Peek​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Peek","content":"&lt;/&gt; Heap:Peek() → ( T?,-- The top value from the heap. number?-- The cost of the top value. ) Returns the top value from the heap without removing it. The top value is the value with the lowest cost in a min-heap and the value with the highest cost in a max-heap. If the heap is empty, nil is returned for both values. Time Complexity: Runs in O(1) time.  "},{"title":"Push​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Push","content":"&lt;/&gt; Heap:Push( value: T, cost: number? ) → () Inserts a value into the heap. Time Complexity: Runs in worst case O(log n) time. local minHeap = Heap.min() minHeap:Push(&quot;A&quot;, 5) minHeap:Push(&quot;B&quot;, 2) minHeap:Push(&quot;C&quot;, 8) local minValue, minCost = minHeap:Peek() print(minValue, minCost) -- B 2 Cost If no cost is given, the value itself is used as the cost. Ensure that the given value is comparable with relational operators. local minHeap = Heap.min() minHeap:Push(2) -- uses 2 for both value and cost print(minHeap:Peek()) -- 2 2   "},{"title":"Pop​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Pop","content":"&lt;/&gt; Heap:Pop() → ( T?, number? ) Removes and returns the top value from the heap. Time Complexity: Runs in worst case O(log n) time.  "},{"title":"Size​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Size","content":"&lt;/&gt; Heap:Size() → number Returns the number of elements in the heap. Equivalent to using the # operator on the heap. Time Complexity: Runs in O(1) time.  "},{"title":"Has​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Has","content":"&lt;/&gt; Heap:Has( valueToCheckFor: T, cost: number? ) → boolean Takes a value or function and checks if the heap contains it. If a cost is provided then it will also ensure the cost matches. Returns true if the heap contains a specified value. Time Complexity: Runs in worst case O(n) time.  "},{"title":"UpdateCost​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#UpdateCost","content":"unreleased &lt;/&gt; Heap:UpdateCost( valueToUpdate: T | (value: T) → (boolean),-- The value to update the cost of. newCost: number | ( value: T, oldCost: number ) → number,-- The new cost to assign to the value. Can also be a function that takes the old cost and returns a new cost. updateAll: boolean?-- If true, all occurrences of the value will be updated. Defaults to false. ) → boolean-- True if the cost was updated, false otherwise. Updates the cost of a value in the heap. If no value is found, false is returned. Repeated Values If you have multiple instances of the same value, this method will only update the cost of the first valid instance found, unless the third parameter updateAll is set to true. There is no guarantee of which instance will be found first. Using updateAll can be expensive as it may need to perform a large resorting of the heap to ensure proper ordering. local minHeap = Heap.min() minHeap:Push(&quot;A&quot;, 5) minHeap:Push(&quot;B&quot;, 2) minHeap:Push(&quot;C&quot;, 8) minHeap:Push(&quot;D&quot;, 10) print(minHeap:Peek()) -- B 2 minHeap:UpdateCost(&quot;A&quot;, 1) print(minHeap:Peek()) -- A 1 -- update the cost of the first value that matches either &quot;A&quot; or &quot;B&quot; to 15 minHeap:UpdateCost(function(value) return value == &quot;A&quot; or value == &quot;B&quot; end, 15, false) -- update the cost of all values that match &quot;A&quot; or &quot;B&quot; to 30 minHeap:UpdateCost(function(value) return value == &quot;A&quot; or value == &quot;B&quot; end, 30, true)   "},{"title":"RemoveFirstOccurrence​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#RemoveFirstOccurrence","content":"&lt;/&gt; Heap:RemoveFirstOccurrence(valueToRemove: T) → boolean Removes the first occurrence of a given value from the heap. Heaps are not optimized for search removals, so this method should be used sparingly.  "},{"title":"RemoveAllOccurrences​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#RemoveAllOccurrences","content":"&lt;/&gt; Heap:RemoveAllOccurrences(valueToRemove: T) → number Removes all occurrences of a value from the heap and returns the number of occurrences removed. Heaps are not optimized for search removals, so this method should be used sparingly.  "},{"title":"ToTree​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#ToTree","content":"&lt;/&gt; Heap:ToTree() → Branch&lt;T&gt;?-- A tree representation of the heap. A utility method that converts the heap into a tree structure. This is useful for debugging and visualizing the heap. type Branch&lt;T&gt; = {Value: T, Left: Branch&lt;T&gt;?, Right: Branch&lt;T&gt;?}  "},{"title":"iterating over Heap​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#__iter","content":"metamethod &lt;/&gt; for value: T, cost: number in Heap do MetaMethod for iterating over the heap. In a for loop, the first variable is the Value and the second variable is the Cost. local minHeap = Heap.min() minHeap:Push(&quot;A&quot;, 5) minHeap:Push(&quot;B&quot;, 2) minHeap:Push(&quot;C&quot;, 8) minHeap:Push(&quot;A&quot;, 4) minHeap:Push(&quot;D&quot;, 10) for value: string, cost: number in minHeap do print(value, cost) end -- Output: the order may vary B 2 A 4 C 8 A 5 D 10 Manipulating the Heap during iteration It is not recommended to modify the Heap during iteration as it may cause undefined behavior. Internal orders may change and the iterator may not be able to find the next value. Iteration Order There is no guaranteed order of iteration. You should assume you will receive the values in a random order. "},{"title":"Option","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Option","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#properties","content":" "},{"title":"None​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#None","content":"&lt;/&gt; Option.None: Option&lt;None&gt; Represents no value. "},{"title":"Functions​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#functions","content":" "},{"title":"Some​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Some","content":"&lt;/&gt; Option.Some(value: T) → Option&lt;T&gt; Creates an Option instance with the given value. Throws an error if the given value is nil.  "},{"title":"Wrap​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Wrap","content":"&lt;/&gt; Option.Wrap(value: T) → Option&lt;T&gt; | Option&lt;None&gt; Safely wraps the given value as an option. If the value is nil, returns Option.None, otherwise returns Option.Some(value).  "},{"title":"Is​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Is","content":"&lt;/&gt; Option.Is(obj: any) → boolean Returns true if obj is an Option.  "},{"title":"Assert​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Assert","content":"&lt;/&gt; Option.Assert(obj: any) → () Throws an error if obj is not an Option.  "},{"title":"Deserialize​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Deserialize","content":"&lt;/&gt; Option.Deserialize(data: table) → Option Deserializes the data into an Option. This data should have come from the option:Serialize() method.  "},{"title":"Serialize​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Serialize","content":"&lt;/&gt; Option:Serialize() → table Returns a serialized version of the option.  "},{"title":"Match​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Match","content":"&lt;/&gt; Option:Match(matches: { Some: (value: any) → any, None: () → any }) → any Matches against the option. local opt = Option.Some(32) opt:Match { Some = function(num) print(&quot;Number&quot;, num) end, None = function() print(&quot;No value&quot;) end, }   "},{"title":"IsSome​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#IsSome","content":"&lt;/&gt; Option:IsSome() → boolean Returns true if the option has a value.  "},{"title":"IsNone​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#IsNone","content":"&lt;/&gt; Option:IsNone() → boolean Returns true if the option is None.  "},{"title":"Expect​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Expect","content":"&lt;/&gt; Option:Expect(msg: string) → value: any Unwraps the value in the option, otherwise throws an error with msg as the error message. local opt = Option.Some(10) print(opt:Expect(&quot;No number&quot;)) -&gt; 10 print(Option.None:Expect(&quot;No number&quot;)) -- Throws an error &quot;No number&quot;   "},{"title":"ExpectNone​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#ExpectNone","content":"&lt;/&gt; Option:ExpectNone(msg: string) → () Throws an error with msg as the error message if the value is not None.  "},{"title":"Unwrap​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Unwrap","content":"&lt;/&gt; Option:Unwrap() → value: any Returns the value in the option, or throws an error if the option is None.  "},{"title":"UnwrapOr​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#UnwrapOr","content":"&lt;/&gt; Option:UnwrapOr(default: any) → value: any If the option holds a value, returns the value. Otherwise, returns default.  "},{"title":"UnwrapOrElse​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#UnwrapOrElse","content":"&lt;/&gt; Option:UnwrapOrElse(defaultFn: () → any) → value: any If the option holds a value, returns the value. Otherwise, returns the result of the defaultFn function.  "},{"title":"And​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#And","content":"&lt;/&gt; Option:And(optionB: Option) → Option Returns optionB if the calling option has a value, otherwise returns None. local optionA = Option.Some(32) local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == optionB local optionA = Option.None local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == Option.None   "},{"title":"AndThen​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#AndThen","content":"&lt;/&gt; Option:AndThen(andThenFn: (value: any) → Option) → value: Option If the option holds a value, then the andThenFn function is called with the held value of the option, and then the resultant Option returned by the andThenFn is returned. Otherwise, None is returned. local optA = Option.Some(32) local optB = optA:AndThen(function(num) return Option.Some(num * 2) end) print(optB:Expect(&quot;Expected number&quot;)) --&gt; 64   "},{"title":"Or​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Or","content":"&lt;/&gt; Option:Or(optionB: Option) → Option If caller has a value, returns itself. Otherwise, returns optionB.  "},{"title":"OrElse​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#OrElse","content":"&lt;/&gt; Option:OrElse(orElseFn: () → Option) → Option If caller has a value, returns itself. Otherwise, returns the option generated by the orElseFn function.  "},{"title":"XOr​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#XOr","content":"&lt;/&gt; Option:XOr(optionB: Option) → Option If both self and optionB have values or both don't have a value, then this returns None. Otherwise, it returns the option that does have a value.  "},{"title":"Filter​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Filter","content":"&lt;/&gt; Option:Filter(predicate: (value: any) → boolean) → Option Returns self if this option has a value and the predicate returns `true. Otherwise, returns None.  "},{"title":"Contains​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#Contains","content":"&lt;/&gt; Option:Contains(value: any) → boolean Returns true if this option contains value.  "},{"title":"__tostring​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#__tostring","content":"&lt;/&gt; Option:__tostring() → string Metamethod to transform the option into a string. local optA = Option.Some(64) local optB = Option.None print(optA) --&gt; Option&lt;number&gt; print(optB) --&gt; Option&lt;None&gt;   "},{"title":"__eq​","type":1,"pageTitle":"Option","url":"/ModulesOnRails/api/Option#__eq","content":"&lt;/&gt; Option:__eq(opt: Option) → boolean Metamethod to check equality between two options. Returns true if both options hold the same value or both options are None. local o1 = Option.Some(32) local o2 = Option.Some(32) local o3 = Option.Some(64) local o4 = Option.None local o5 = Option.None print(o1 == o2) --&gt; true print(o1 == o3) --&gt; false print(o1 == o4) --&gt; false print(o4 == o5) --&gt; true  "},{"title":"ServerRemoteProperty","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerRemoteProperty","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#Set","content":"&lt;/&gt; ServerRemoteProperty:Set(value: any) → () Sets the top-level value of all clients to the same value. Override Per-Player Data This will override any per-player data that was set usingSetFor or SetFilter. To avoid overriding this data, SetTop can be used instead. -- Examples remoteProperty:Set(10) remoteProperty:Set({SomeData = 32}) remoteProperty:Set(&quot;HelloWorld&quot;)   "},{"title":"SetTop​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#SetTop","content":"&lt;/&gt; ServerRemoteProperty:SetTop(value: any) → () Set the top-level value of the property, but does not override any per-player data (e.g. set with SetFor or SetFilter). Any player without custom-set data will receive this new data. This is useful if certain players have specific values that should not be changed, but all other players should receive the same new value. -- Using just 'Set' overrides per-player data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Using 'SetTop' does not override: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot;   "},{"title":"SetFor​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#SetFor","content":"&lt;/&gt; ServerRemoteProperty:SetFor( player: Player , value: any ) → () Set the value of the property for a specific player. This will override the value used by Set (and the initial value set for the property when created). This value can be nil. In order to reset the value for a given player and let the player use the top-level value held by this property, either use Set to set all players' data, or use ClearFor. remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;)   "},{"title":"SetForList​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#SetForList","content":"&lt;/&gt; ServerRemoteProperty:SetForList( players: {Player }, value: any ) → () Set the value of the property for specific players. This just loops through the players given and calls SetFor. local players = {player1, player2, player3} remoteProperty:SetForList(players, &quot;CustomData&quot;)   "},{"title":"SetFilter​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#SetFilter","content":"&lt;/&gt; ServerRemoteProperty:SetFilter( predicate: ( Player , any ) → boolean, value: any-- Value to set for the clients (and to the predicate) ) → () Sets the value for specific clients that pass the predicate function test. This can be used to finely set the values based on more control logic (e.g. setting certain values per team). -- Set the value of &quot;NewValue&quot; to players with a name longer than 10 characters: remoteProperty:SetFilter(function(player) return #player.Name &gt; 10 end, &quot;NewValue&quot;)   "},{"title":"ClearFor​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#ClearFor","content":"&lt;/&gt; ServerRemoteProperty:ClearFor(player: Player ) → () Clears the custom property value for the given player. When this occurs, the player will reset to use the top-level value held by this property (either the value set when the property was created, or the last value set by Set). remoteProperty:Set(&quot;DATA&quot;) remoteProperty:SetFor(somePlayer, &quot;CUSTOM_DATA&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CUSTOM_DATA&quot; -- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL: remoteProperty:SetFor(somePlayer, nil) print(remoteProperty:GetFor(somePlayer)) --&gt; nil -- CLEAR: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;DATA&quot;   "},{"title":"ClearForList​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#ClearForList","content":"&lt;/&gt; ServerRemoteProperty:ClearForList(players: {Player }) → () Clears the custom value for the given players. This just loops through the list of players and calls the ClearFor method for each player.  "},{"title":"ClearFilter​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#ClearFilter","content":"&lt;/&gt; ServerRemoteProperty:ClearFilter(predicate: (Player ) → boolean) → () The same as SetFilter, except clears the custom value for any player that passes the predicate.  "},{"title":"Get​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#Get","content":"&lt;/&gt; ServerRemoteProperty:Get() → any Returns the top-level value held by the property. This will either be the initial value set, or the last value set with Set(). remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:Get()) --&gt; &quot;Data&quot;   "},{"title":"GetFor​","type":1,"pageTitle":"ServerRemoteProperty","url":"/ModulesOnRails/api/ServerRemoteProperty#GetFor","content":"&lt;/&gt; ServerRemoteProperty:GetFor(player: Player ) → any Returns the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). -- Set top level data: remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Set custom data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Set top level again, overriding custom data: remoteProperty:Set(&quot;NewData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;NewData&quot; -- Set custom data again, and set top level without overriding: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Clear custom data to use top level data: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot;  "},{"title":"Janitor","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Janitor","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#properties","content":" "},{"title":"CurrentlyCleaning​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#CurrentlyCleaning","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Janitor.CurrentlyCleaning: boolean Whether or not the Janitor is currently cleaning up.  "},{"title":"SuppressInstanceReDestroy​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#SuppressInstanceReDestroy","content":"since 1.15.4 &lt;/&gt; Janitor.SuppressInstanceReDestroy: boolean Whether or not you want to suppress the re-destroying of instances. Default is false, which is the original behavior.  "},{"title":"UnsafeThreadCleanup​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#UnsafeThreadCleanup","content":"since 1.18.0 &lt;/&gt; Janitor.UnsafeThreadCleanup: boolean Whether or not to use the unsafe fast defer function for cleaning up threads. This might be able to throw, so be careful. If you're getting any thread related errors, chances are it is this. "},{"title":"Functions​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#new","content":"&lt;/&gt; Janitor.new() → Janitor Instantiates a new Janitor object.  "},{"title":"Is​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Is","content":"&lt;/&gt; Janitor.Is( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. Determines if the passed object is a Janitor. This checks the metatable directly.  "},{"title":"instanceof​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#instanceof","content":"&lt;/&gt; Janitor.instanceof( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. An alias for Janitor.Is. This is intended for roblox-ts support.  "},{"title":"Add​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Add","content":"&lt;/&gt; Janitor:Add( object: T,-- The object you want to clean up. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown-- The index that can be used to clean up the object manually. ) → T-- The object that was passed as the first argument. Adds an object to Janitor for later cleanup, where methodName is the key of the method within object which should be called at cleanup time. If the methodName is true the object itself will be called if it's a function or have task.cancel called on it if it is a thread. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Returns the object. Note Objects not given an explicit methodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to &quot;Disconnect&quot;, functions and threads will be assigned to true, and everything else will default to &quot;Destroy&quot;. Not recommended, but hey, you do you. Luau: local Workspace = game:GetService(&quot;Workspace&quot;) local TweenService = game:GetService(&quot;TweenService&quot;) local obliterator = Janitor.new() local part = Workspace:FindFirstChild(&quot;Part&quot;) :: Part -- Queue the Part to be Destroyed at Cleanup time obliterator:Add(part, &quot;Destroy&quot;) -- Queue function to be called with `true` methodName obliterator:Add(print, true) -- Close a thread. obliterator:Add(task.defer(function() while true do print(&quot;Running!&quot;) task.wait(0.5) end end), true) -- This implementation allows you to specify behavior for any object obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Cancel&quot;) -- By passing an index, the object will occupy a namespace -- If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Destroy&quot;, &quot;CurrentTween&quot;) TypeScript: import { Workspace, TweenService } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ CurrentTween: Tween }&gt;(); const part = Workspace.FindFirstChild(&quot;Part&quot;) as Part; // Queue the part to be Destroyed at Cleanup time obliterator.Add(part, &quot;Destroy&quot;); // Queue function to be called with `true` methodName obliterator.Add(print, true); // Close a thread. obliterator.Add(task.defer(() =&gt; { while (true) { print(&quot;Running!&quot;); task.wait(0.5); } }), true); // This implementation allows you to specify behavior for any object obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Cancel&quot;); // By passing an index, the object will occupy a namespace // If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Destroy&quot;, &quot;CurrentTween&quot;);   "},{"title":"AddObject​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#AddObject","content":"since v1.16.0 &lt;/&gt; Janitor:AddObject( constructor: {new: (A...) → T},-- The constructor for the object you want to add to the Janitor. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown,-- The index that can be used to clean up the object manually. ...: A...-- The arguments that will be passed to the constructor. ) → T-- The object that was passed as the first argument. Constructs an object for you and adds it to the Janitor. It's really just shorthand for Janitor:Add(object.new(), methodName, index). Luau: local obliterator = Janitor.new() local subObliterator = obliterator:AddObject(Janitor, &quot;Destroy&quot;) -- subObliterator is another Janitor! TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); const subObliterator = obliterator.AddObject(Janitor, &quot;Destroy&quot;);   "},{"title":"Get​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Get","content":"&lt;/&gt; Janitor:Get( index: unknown-- The index that the object is stored under. ) → unknown?-- This will return the object if it is found, but it won't return anything if it doesn't exist. Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using __index. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:Get(&quot;Baseplate&quot;)) -- Returns Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.Get(&quot;Baseplate&quot;)); // Returns Baseplate.   "},{"title":"AddPromise​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#AddPromise","content":"&lt;/&gt; Janitor:AddPromise( promiseObject: Promise,-- The promise you want to add to the Janitor. index?: unknown-- The index that can be used to clean up the object manually. ) → Promise Adds a Promise to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled. Luau: local obliterator = Janitor.new() obliterator:AddPromise(Promise.delay(3)):andThenCall(print, &quot;Finished!&quot;):catch(warn) task.wait(1) obliterator:Cleanup() TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.AddPromise(Promise.delay(3)).andThenCall(print, &quot;Finished!&quot;).catch(warn); task.wait(1); obliterator.Cleanup();  "},{"title":"Errors","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor##","content":"Type\tDescriptionNotAPromiseError\tThrown if the promise is not a Promise.  "},{"title":"Remove​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Remove","content":"&lt;/&gt; Janitor:Remove( index: unknown-- The index you want to remove. ) → Janitor Cleans up whatever Object was set to this namespace by the 3rd parameter of Janitor.Add. Luau: local obliterator = Janitor.new() obliterator:Add(workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) obliterator:Remove(&quot;Baseplate&quot;) TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); obliterator.Remove(&quot;Baseplate&quot;);   "},{"title":"RemoveNoClean​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveNoClean( index: unknown-- The index you are removing. ) → Janitor Removes an object from the Janitor without running a cleanup. Luau local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed!&quot;) end, true, &quot;Function&quot;) obliterator:RemoveNoClean(&quot;Function&quot;) -- Does not print. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Function: () =&gt; void }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed!&quot;), true, &quot;Function&quot;); obliterator.RemoveNoClean(&quot;Function&quot;); // Does not print.   "},{"title":"RemoveList​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveList","content":"since v1.14.0 &lt;/&gt; Janitor:RemoveList( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot; TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOp = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOp, Two: NoOp, Three: NoOp }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot;   "},{"title":"RemoveListNoClean​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#RemoveListNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveListNoClean( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once without running their cleanup. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Nothing is printed. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOperation = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOperation, Two: NoOperation, Three: NoOperation }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Nothing is printed.   "},{"title":"GetAll​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#GetAll","content":"since v1.15.1 &lt;/&gt; Janitor:GetAll() → {[any]: any} Returns a frozen copy of the Janitor's indices. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:GetAll().Baseplate) -- Prints Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.GetAll().Baseplate); // Prints Baseplate.   "},{"title":"Cleanup​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Cleanup","content":"&lt;/&gt; Janitor:Cleanup() → () Calls each object's methodName (or calls the object if methodName == true) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor object (so it can be used as a destructor callback). Luau: obliterator:Cleanup() -- Valid. obliterator() -- Also valid. TypeScript: obliterator.Cleanup() // TypeScript version doesn't support the __call method of cleaning.   "},{"title":"Destroy​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#Destroy","content":"&lt;/&gt; Janitor:Destroy() → () Calls Janitor.Cleanup and renders the Janitor unusable. Metatable Removal Running this will make any further attempts to call a method of Janitor error.  "},{"title":"LinkToInstance​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#LinkToInstance","content":"&lt;/&gt; Janitor:LinkToInstance( object: Instance ,-- The instance you want to link the Janitor to. allowMultiple?: boolean-- Whether or not to allow multiple links on the same Janitor. ) → RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance. &quot;Links&quot; this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroy()d and garbage collected. A Janitor may only be linked to one instance at a time, unless allowMultiple is true. When called with a truthy allowMultiple parameter, the Janitor will &quot;link&quot; the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy allowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy allowMultiple parameter, if applicable. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Cleaning up!&quot;) end, true) do local folder = Instance.new(&quot;Folder&quot;) obliterator:LinkToInstance(folder) folder:Destroy() end TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.Add(() =&gt; print(&quot;Cleaning up!&quot;), true); { const folder = new Instance(&quot;Folder&quot;); obliterator.LinkToInstance(folder, false); folder.Destroy(); }   "},{"title":"LinkToInstances​","type":1,"pageTitle":"Janitor","url":"/ModulesOnRails/api/Janitor#LinkToInstances","content":"&lt;/&gt; Janitor:LinkToInstances( ...: Instance -- All the Instances you want linked. ) → Janitor-- A new Janitor that can be used to manually disconnect all LinkToInstances. Links several instances to a new Janitor, which is then returned. "},{"title":"Signal","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/ModulesOnRails/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  "},{"title":"PlayerProfileManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerProfileManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#types","content":" "},{"title":"DataMigrator​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#DataMigrator","content":"&lt;/&gt; interface DataMigrator { FromVersion: string ToVersion: string Migrate: ( profileData: table, profileOwner: Player ) → (table) } Used to Transform data from one version to another -- Turn all the deprecated currency 'Candy' into the new currency 'Gems' at a 1:10 rate local migrator = { FromVersion = &quot;0.0.1&quot;, ToVersion = &quot;0.0.2&quot; Migrate = function(data: table, plr: Player) if not data.Gems then data.Gems = 0 end local candy = data.Candy or 0 data.Gems += candy * 10 data.Candy = nil return data end }   "},{"title":"PPM_Config​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PPM_Config","content":"&lt;/&gt; interface PPM_Config { DataStoreKey: string DefaultDataSchema: table UseMock: boolean? Migrator: {DataMigrator} GetPlayerKeyCallback: ((player: Player ) → (string))? ReconcileCallback: (( player: Player , profile: Profile ) → ())? OnProfileLoadFailureCallback: (( player: Player , err: string ) → ())? }  DataStoreKey is the internal Key used for the PlayerData's DataStore. DefaultDataSchema is a template table that is used for reconciling the player's profile with. It is what new players are given if they dont have existing data. UseMock determines whether or not a Mock ProfileStore will be used. Migrator is a table of DataMigrators that are used to transform data from one version to another. GetPlayerKeyCallback is a callback that is used to fetch the Key that each player's data is mapped to. ReconcileCallback is a callback that is called when the system attempts to reconcile the players profile. It will default to calling Profile:Reconcile if not provided. OnProfileLoadFailureCallback is a callback that is called if the player's data fails to load. It will default to kicking the player if not provided.  "},{"title":"Functions​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#new","content":"&lt;/&gt; PlayerProfileManager.new(config: PPM_Config) → PlayerProfileManager Creates a new PlayerProfileManager. This is a singleton class, so calling this function multiple times will return the same instance. Takes a config table, see PPM_Config for more info on the individual fields it supports. PlayerProfileManager.new({ DataStoreKey = &quot;PlayerData&quot;; DefaultDataSchema = { __VERSION = &quot;0.0.0&quot;; Currency = 0; }; })   "},{"title":"IsLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#IsLoaded","content":"&lt;/&gt; PlayerProfileManager:IsLoaded(player: Player ) → boolean Returns whether or not the player's profile is currently loaded. local isLoaded = PlayerProfileManager:IsLoaded(player)   "},{"title":"OnLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#OnLoaded","content":"&lt;/&gt; PlayerProfileManager:OnLoaded(player: Player ) → Promise&lt;()&gt; Returns a promise that will resolve when the player's profile is loaded. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:OnLoaded(player):andThen(function() print(&quot;Profile loaded for &quot; .. player.Name) end)   "},{"title":"GetProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#GetProfile","content":"&lt;/&gt; PlayerProfileManager:GetProfile(player: Player ) → Profile? Returns the player's profile, if it exists. May return nil if this players profile is not loaded. local profile: Profile? = PlayerProfileManager:GetProfile(player)   "},{"title":"PromiseProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PromiseProfile","content":"&lt;/&gt; PlayerProfileManager:PromiseProfile(player: Player ) → Promise&lt;Profile&gt; Returns a promise that resolves with the player's profile when it is ready. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:PromiseProfile(player):andThen(function(profile: Profile) print(&quot;Profile loaded for &quot; .. player.Name) end)  "},{"title":"CmdrServer","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrServer","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#functions","content":" "},{"title":"PromiseCmdr​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#PromiseCmdr","content":"&lt;/&gt; CmdrServer:PromiseCmdr() → Promise&lt;Cmdr&gt; Promise that resolves to the Cmdr module data  "},{"title":"RegisterCommandFromModule​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#RegisterCommandFromModule","content":"&lt;/&gt; CmdrServer:RegisterCommandFromModule( module: ModuleScript -- The module to register the command from ) → Promise&lt;nil&gt; Registers a command from a module with Cmdr. Command modules must return a table of type CommandModuleData. -- Commands/Kill.lua return { Name = &quot;kill&quot;; Aliases = {&quot;slay&quot;}; Description = &quot;Kills a player or set of players.&quot;; Group = &quot;DefaultAdmin&quot;; -- The permission group required to run this command Args = { { Type = &quot;players&quot;; Name = &quot;victims&quot;; Description = &quot;The players to kill.&quot;; }, }; -- Executors ClientRun = nil, -- No client side needed ServerRun = function (_, players) for _, player in pairs(players) do if player.Character then player.Character:BreakJoints() end end return (&quot;Killed %d players.&quot;):format(#players) end } CmdrServer:RegisterCommandFromModule(script.Parent.Commands.Kill)   "},{"title":"ExecuteCommand​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#ExecuteCommand","content":"&lt;/&gt; CmdrServer:ExecuteCommand( commandText: string, executor: Player? , options: { Data: any?, IsHuman: boolean }? ) → Promise&lt;string&gt; Executes a command with Cmdr from the server CmdrServer:ExecuteCommand(&quot;kill Raildex&quot;):andThen(function(result) print(result) end)   "},{"title":"ExecuteCommandAsClient​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#ExecuteCommandAsClient","content":"&lt;/&gt; CmdrServer:ExecuteCommandAsClient( executor: Player , ...: string ) → () Executes a command with Cmdr as if it were run by a client CmdrServer:ExecuteCommandAsClient(Players.Raildex, &quot;kill&quot;, &quot;*&quot;) CmdrServer:ExecuteCommandAsClient(Players.Raildex, &quot;kill *&quot;)   "},{"title":"HasPermission​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#HasPermission","content":"&lt;/&gt; CmdrServer:HasPermission( plr: Player ,-- The player to check commandName: string-- The name of the command to check ) → boolean Checks if a player has permission to run a command  "},{"title":"GetPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetPermissions","content":"&lt;/&gt; CmdrServer:GetPermissions(plr: Player ) → {any} Gets the permissions for a player  "},{"title":"SetPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#SetPermissions","content":"&lt;/&gt; CmdrServer:SetPermissions( plr: Player , permissions: string | {string} ) → () Sets the direct permissions for a player. Does not override inherited permissions or group permissions. CmdrServer:SetPermissions(Players.Raildex, &quot;Admin&quot;) info The 'Creator' permission grants all permissions regardless of group inheritance.  "},{"title":"GivePermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GivePermissions","content":"&lt;/&gt; CmdrServer:GivePermissions( plr: Player ,-- The player to grant permissions to permissions: string | {string}-- The permissions to grant ) → () Grants a player a permission group(s). Adds the given permissions to the player's current permissions. CmdrServer:GivePermissions(Players.Raildex, &quot;Admin&quot;)   "},{"title":"GetGroupRankPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetGroupRankPermissions","content":"&lt;/&gt; CmdrServer:GetGroupRankPermissions( groupId: number,-- The Roblox group id to get permissions for rank: number-- The rank to get permissions for ) → {string}-- The permissions granted to the rank Gets the permissions granted to a particular rank in a group. local permissions = CmdrServer:GetGroupRankPermissions(15905255, 230)   "},{"title":"GiveGroupPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GiveGroupPermissions","content":"&lt;/&gt; CmdrServer:GiveGroupPermissions( groupId: number,-- The Roblox group id to grant permissions to ranks: number | NumberRange ,-- The ranks to apply the permissions to. Can be a single rank or a range of ranks. permissions: string | {string}-- The permissions to grant to the group ) → function-- A function that can be called to remove the permissions Grants a Roblox group permissions to run a command. Takes the ranks to apply the permissions to, and the permissions to grant. local revoke = CmdrServer:GiveGroupPermissions(15905255, 230, &quot;Admin&quot;)   "},{"title":"SetPermissionInheritance​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#SetPermissionInheritance","content":"&lt;/&gt; CmdrServer:SetPermissionInheritance( permissionGroup: string,-- The permission group to set the inheritance for inheritedGroups: string | {string}-- The groups to inherit permissions from ) → nil Sets the permission inheritance for a permission group. This will override any previous inheritance. CmdrServer:SetPermissionInheritance(&quot;Admin&quot;, &quot;DefaultAdmin&quot;) CmdrServer:SetPermissionInheritance(&quot;Admin&quot;, {&quot;DefaultAdmin&quot;, &quot;Moderator&quot;})   "},{"title":"GetPermissionInheritance​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetPermissionInheritance","content":"&lt;/&gt; CmdrServer:GetPermissionInheritance(permissionGroup: string) → {string} Fetches the inherited permission group for a permission group  "},{"title":"RegisterType​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#RegisterType","content":"&lt;/&gt; CmdrServer:RegisterType( name: string,-- The name of the type typeData: TypeDefinition&lt;T&gt;-- The type data to register ) → Promise Registers a type with Cmdr "},{"title":"BaseComponent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseComponent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#functions","content":" "},{"title":"GetAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetAttribute","content":"&lt;/&gt; BaseComponent:GetAttribute( attributeName: string-- The name of the attribute to fetch ) → any?-- The current value of the attribute Fetches the current Value of an attribute on the Component Instance  "},{"title":"SetAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#SetAttribute","content":"&lt;/&gt; BaseComponent:SetAttribute( attributeName: string,-- The name of the attribute to set value: any-- The value to set the attribute to ) → () Sets an attribute of this Component's instance to a value  "},{"title":"IncrementAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#IncrementAttribute","content":"&lt;/&gt; BaseComponent:IncrementAttribute( attributeName: string,-- The name of the attribute to increment increment: number?-- The amount to increment the attribute by. Defaults to 1 ) → number-- The new value of the attribute Increments the current value of the attribute by the increment. If no increment is provided, it defaults to 1  "},{"title":"UpdateAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#UpdateAttribute","content":"&lt;/&gt; BaseComponent:UpdateAttribute( attributeName: string,-- The name of the attribute to mutate mutator: ((value: any) → (any))-- The function to mutate the attribute with ) → any-- The new value of the attribute Updates the current value of the attribute into a new value from the return of the mutator function  "},{"title":"ObserveAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#ObserveAttribute","content":"&lt;/&gt; BaseComponent:ObserveAttribute( attributeName: string,-- The name of the attribute to observe callback: ((newValue: any) → ())-- The function to call when the attribute changes ) → function-- A function to disconnect the observer Watches for when the attribute changes and calls the callback. Also calls the callback initially with the current value  "},{"title":"OutAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#OutAttribute","content":"&lt;/&gt; BaseComponent:OutAttribute( attributeName: string-- The name of the attribute to fetch ) → Value&lt;any&gt;-- The synchronized fusion value of the attribute Fetches an attribute and turns into into a synchronized usable value  "},{"title":"DefaultAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#DefaultAttribute","content":"&lt;/&gt; BaseComponent:DefaultAttribute( attributeName: string,-- The name of the attribute to set value: any,-- The value to set the attribute to validDataTypes: {string}?-- A list of valid data types for the attribute ) → any-- The value of the attribute Sets an attribute to a default value if it is not already set, allows for type checking of the initial value  "},{"title":"AttributeChanged​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AttributeChanged","content":"&lt;/&gt; BaseComponent:AttributeChanged( attributeName: string,-- The name of the attribute to observe fn: ((...any) → ())?-- The function to call when the attribute changes ) → RBXScriptConnection | RBXScriptSignal -- A function to disconnect the observer or the signal Fetches the AttributeChanged signal for the attribute if no function is given. If a function is provided, it will connect the function to the attribute changed signal and return the connection  "},{"title":"GetScope​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetScope","content":"&lt;/&gt; BaseComponent:GetScope() → Scope&lt;any&gt; Returns a scope associated with the lifecycle of the component. Inherits methods from RailUtil.Fusion and Fusion.  "},{"title":"AddPromise​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AddPromise","content":"&lt;/&gt; BaseComponent:AddPromise(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Adds a promise to the component's janitor. Returns the same promise that was given.  "},{"title":"AddTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AddTask","content":"&lt;/&gt; BaseComponent:AddTask( task: T, cleanupMethod: (string | true)?, index: any? ) → T-- The same task that was given Adds a task to the component's janitor.  "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RemoveTaskNoClean","content":"&lt;/&gt; BaseComponent:RemoveTaskNoClean( index: any-- The index of the task to remove. ) → () Removes a task from the component's janitor without cleaning it.  "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RemoveTask","content":"&lt;/&gt; BaseComponent:RemoveTask( index: any,-- The id of the task to remove. dontClean: boolean?-- Optional flag to not clean the task. ) → () Removes a task from the component's janitor.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetTask","content":"&lt;/&gt; BaseComponent:GetTask( index: any-- The id of the task to get. ) → any-- The task that was retrieved. Gets a task from the janitor.  "},{"title":"ObserveProperty​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#ObserveProperty","content":"&lt;/&gt; BaseComponent:ObserveProperty( propertyName: string,-- The name of the property to observe callback: ((newValue: any) → ())-- The function to call when the property changes ) → function-- A function to disconnect the observer Watches for when the property changes and calls the callback. Also calls the callback initially with the current value  "},{"title":"OutProperty​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#OutProperty","content":"&lt;/&gt; BaseComponent:OutProperty( propertyName: string-- The name of the property to fetch ) → Value&lt;any&gt;-- The synchronized fusion value of the property Fetches an property and turns into into a synchronized usable value  "},{"title":"PropertyChanged​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#PropertyChanged","content":"&lt;/&gt; BaseComponent:PropertyChanged( propertyName: string,-- The name of the property to observe fn: ((...any) → ())?,-- The function to call when the property changes connectOnce: boolean?-- If true, the function will only be called the first time the property changes ) → RBXScriptConnection | RBXScriptSignal -- A connection or signal Fetches the PropertyChanged signal for the property if no function is given. If a function is provided, it will connect the function to the property changed signal and return the connection  "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RegisterSignal","content":"&lt;/&gt; BaseComponent:RegisterSignal( signalName: string-- The name of the signal to register. ) → Signal-- The signal that was registered. Registers a signal to the component.  "},{"title":"GetSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetSignal","content":"&lt;/&gt; BaseComponent:GetSignal( signalName: string-- The name of the signal to get. ) → Signal-- The signal that was retrieved. Gets a signal from the component.  "},{"title":"FireSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#FireSignal","content":"&lt;/&gt; BaseComponent:FireSignal( signalName: string,-- The name of the signal to fire. ...: any-- The arguments to pass to the signal. ) → () Fires a signal from the component. "},{"title":"Queue","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Queue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#ClassName","content":"&lt;/&gt; Queue.ClassName: &quot;Queue&quot;  "},{"title":"Functions​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#new","content":"static &lt;/&gt; Queue.new() → Queue&lt;T&gt; Creates a new Queue  "},{"title":"iterating over Queue​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#__iter","content":"metamethod &lt;/&gt; for index: number, value: T in Queue do Iterates over the values in the Queue. local queue = Queue.new() queue:Push(50) queue:Push(100) for i, v in queue do print(i, v) end 1 50 2 100   "},{"title":"Peek​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Peek","content":"&lt;/&gt; Queue:Peek(index: number?) → T? Look at the first value in the queue. If there is an index provided, it will look at the value at that index instead. local queue = Queue.new() queue:Push(50) queue:Push(100) queue:Push(150) print(queue:Peek()) -- 50 print(queue:Peek(2)) -- 100 queue:Pop() print(queue:Peek()) -- 100   "},{"title":"Pop​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Pop","content":"&lt;/&gt; Queue:Pop() → T? Remove the value at the front of the queue if there is one.  "},{"title":"Push​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Push","content":"&lt;/&gt; Queue:Push(value: T) → () Add a value to the back of the queue.  "},{"title":"Prepend​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Prepend","content":"&lt;/&gt; Queue:Prepend(value: T) → () Add a value to the front of the queue.  "},{"title":"Size​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Size","content":"&lt;/&gt; Queue:Size() → number Get the number of items in the Queue.  "},{"title":"IsEmpty​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#IsEmpty","content":"&lt;/&gt; Queue:IsEmpty() → boolean Check if the queue is empty.  "},{"title":"ToArray​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#ToArray","content":"&lt;/&gt; Queue:ToArray() → {T} Converts the Queue into an iterable array.  "},{"title":"Has​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Has","content":"&lt;/&gt; Queue:Has(value: T) → boolean Checks to see if a given value exists within the Queue.  "},{"title":"CountOccurrences​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#CountOccurrences","content":"&lt;/&gt; Queue:CountOccurrences(value: T) → number Returns the number of occurrences of a given value in the queue.  "},{"title":"RemoveFirstOccurrence​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#RemoveFirstOccurrence","content":"&lt;/&gt; Queue:RemoveFirstOccurrence(value: T) → boolean Removes the first occurrence of a given value in the queue. Returns whether or not it did remove something.  "},{"title":"RemoveAllOccurrences​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#RemoveAllOccurrences","content":"&lt;/&gt; Queue:RemoveAllOccurrences(value: T) → number Removes all occurrences of a given value in the queue. Returns the number of items removed.  "},{"title":"RemoveValueAt​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#RemoveValueAt","content":"&lt;/&gt; Queue:RemoveValueAt( index: number-- The index of the item to remove. ) → T | nil-- The item that was removed, or nil if the index was out of bounds or the queue is empty. Removes the item at the given index. Returns whether or not it did remove something. If it did, it will also return the item that was removed. This method should typically only be used in conjunction with the iterator metamethod. "},{"title":"Symbol","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Symbol","content":"On this page Symbol Represents a unique object. Symbols are often used as unique keys in tables. This is useful to avoid possible collisions with a key in a table, since the symbol will always be unique and cannot be reconstructed. All Unique Every creation of a symbol is unique, even if the given names are the same. local Symbol = require(packages.Symbol) -- Create a symbol: local symbol = Symbol(&quot;MySymbol&quot;) -- The name is optional: local anotherSymbol = Symbol() -- Comparison: print(symbol == symbol) --&gt; true -- All symbol constructions are unique, regardless of the name: print(Symbol(&quot;Hello&quot;) == Symbol(&quot;Hello&quot;)) --&gt; false -- Commonly used as unique keys in a table: local DATA_KEY = Symbol(&quot;Data&quot;) local t = { -- Can only be accessed using the DATA_KEY symbol: [DATA_KEY] = {} } print(t[DATA_KEY]) --&gt; {} ","keywords":""},{"title":"BaseObject","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseObject","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#types","content":" "},{"title":"BaseObject​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BaseObject","content":"&lt;/&gt; type BaseObject = BaseObject  "},{"title":"Properties​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; BaseObject.ClassName: string  "},{"title":"Functions​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#functions","content":" "},{"title":"getObjectFromId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#getObjectFromId","content":"static &lt;/&gt; BaseObject.getObjectFromId(id: number) → BaseObject? Fetches the object with the given ID if it exists. local obj = BaseObject.new() local id = obj:GetId() print(BaseObject.getObjectFromId(id) == obj) -- true   "},{"title":"isDestroyed​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#isDestroyed","content":"static &lt;/&gt; BaseObject.isDestroyed(self: BaseObject) → boolean Checks whether or not the object is destroyed. local obj = BaseObject.new() print(BaseObject.isDestroyed(obj)) -- false obj:Destroy() print(BaseObject.isDestroyed(obj)) -- true   "},{"title":"new​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#new","content":"static &lt;/&gt; BaseObject.new( tbl: {[any]: any}?-- Table to construct the BaseObject with ) → BaseObject Constructs a new BaseObject local obj = BaseObject.new({ X = 1, Y = 2, }) obj.Z = 3 print(obj.X, obj.Y, obj.Z) -- 1, 2, 3 local SuperClass = BaseObject local MyClass = setmetatable({}, SuperClass) MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() local self = setmetatable(SuperClass.new(), MyClass) -- Custom logic here return self end function MyClass:Destroy() -- Overwrite the BaseObject Destroy method SuperClass.Destroy(self) -- If you overwrite the BaseObject Destroy method you need to have this line to call the original. end function MyClass:Print() print(&quot;Hello, World!&quot;) end return MyClass   "},{"title":"Destroy​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#Destroy","content":"&lt;/&gt; BaseObject:Destroy() → () Marks the Object as Destroyed, fires the Destroyed Signal, cleans up the BaseObject, and sets the metatable to nil/a special locked MT. Overriding If you override this method, you need to make sure you callSuperClass.Destroy(self) to call the superclass methods. function MyCustomClass:Destroy() SuperClass.Destroy(self) -- calls the superclass method to clean up events, tasks, etc.. end   "},{"title":"GetId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetId","content":"&lt;/&gt; BaseObject:GetId() → number Returns the ID of the BaseObject Can be used to fetch the object with BaseObject.getObjectFromId(id)  "},{"title":"IsA​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#IsA","content":"&lt;/&gt; BaseObject:IsA(classOrClassName: {[any]: any} | string) → boolean Returns true if the given object is of a given class. Takes a class name or class object.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetTask","content":"&lt;/&gt; BaseObject:GetTask(taskId: any) → Task? Fetches the task with the given ID if it exists. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:AddTask(part, nil, &quot;Test&quot;) print(obj:GetTask(&quot;Test&quot;) == part) -- true   "},{"title":"AddTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddTask","content":"&lt;/&gt; BaseObject:AddTask( task: Task, taskCleanupMethod: (string | true | nil)?,-- (if none is given it will try to infer; Passing true tells it to call it as a function) taskId: any? ) → Task-- The task that was given Adds a task to the janitor. If a taskId is provided, it will be used as the key for the task in the janitor and can then be fetched later with :GetTask(). If an ID is provided and there already exists a task with that ID, it will clean up the existing task and then replace the index with the new one. It will return the task that was added/given. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end) obj:Destroy() -- Prints &quot;Hello, World!&quot;   "},{"title":"AddPromise​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddPromise","content":"&lt;/&gt; BaseObject:AddPromise(prom: Promise) → Promise Adds a promise to the janitor. Similar to :AddTask(). Returns the same Promise that was given to it. local prom = Promise.delay(math.random(10)) local obj = BaseObject.new() obj:AddPromise(prom) task.wait(math.random(10)) obj:Destroy() -- Cancels the promise if it hasn't resolved yet   "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTask","content":"&lt;/&gt; BaseObject:RemoveTask( taskId: any, dontClean: boolean? ) → () Removes a task from the janitor. Cleans the task as if :DoCleaning was called. If dontClean is true, it will not clean up the task, it will just remove it from the janitor. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTask(&quot;Test&quot;) -- Prints &quot;Hello, World!&quot;   "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTaskNoClean","content":"&lt;/&gt; BaseObject:RemoveTaskNoClean(taskId: any) → () Removes a task from the janitor without cleaning it. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTaskNoClean(&quot;Test&quot;) -- Does NOT print &quot;Hello, World!&quot;   "},{"title":"FireSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#FireSignal","content":"&lt;/&gt; BaseObject:FireSignal( signalName: string,-- The name of the signal to fire ...: any-- Arguments to pass to the signal ) → () Fires the signal with the given name, if it exists. Equivalent to calling :GetSignal(signalName):Fire(...) except this does not require the signal to exist first. local obj = BaseObject.new() local SignalName = &quot;Test&quot; obj:RegisterSignal(SignalName) obj:GetSignal(SignalName):Connect(print) obj:FireSignal(SignalName, &quot;Hello, World!&quot;) -- Fires the signal with the argument &quot;Hello, World!&quot;   "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RegisterSignal","content":"&lt;/&gt; BaseObject:RegisterSignal( signalName: string-- Name of signal to register ) → () Marks a signal with the given name as registered. Does not actually build a new signal, it sets the index to a SignalMarker to identify it as registered so that it can be fetched later.  "},{"title":"HasSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#HasSignal","content":"&lt;/&gt; BaseObject:HasSignal(signalName: string) → boolean Checks whether or not a signal with the given name is registered. local obj = BaseObject.new() local SignalName = &quot;Test&quot; print(obj:HasSignal(SignalName)) -- false obj:RegisterSignal(SignalName) print(obj:HasSignal(SignalName)) -- true   "},{"title":"GetSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetSignal","content":"&lt;/&gt; BaseObject:GetSignal(signalName: string) → Signal Fetches a signal with the given name. Creates the Signal JIT.  "},{"title":"ConnectSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ConnectSignal","content":"&lt;/&gt; BaseObject:ConnectSignal( signalName: string, func: (...any) → () ) → () Connects a function to a signal with the given name. Creates the signal JIT. Shorthand for :GetSignal(signalName):Connect(func).  "},{"title":"GetDestroyedSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetDestroyedSignal","content":"&lt;/&gt; BaseObject:GetDestroyedSignal() → Signal Returns a signal that fires when the object is destroyed. Creates the signal JIT. Kept for backwards compatibility. local obj = BaseObject.new() obj:GetDestroyedSignal():Connect(function() print(&quot;Object Destroyed!&quot;) end) obj:Destroy() -- Prints &quot;Object Destroyed!&quot;   "},{"title":"BindToInstance​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BindToInstance","content":"&lt;/&gt; BaseObject:BindToInstance( obj: Instance , destroyOnNilParent: boolean?-- Whether or not to destroy the object when the parent is nil'd ) → function-- Disconnects the binding Binds the object to the given instance. When the object is destroyed, it will destroy the instance. When the instance is destroyed, it will destroy the object. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:BindToInstance(part) do -- setup prints on destroy obj:AddTask(function() print(&quot;Object Destroyed!&quot;) end) part.Destroying:Connect(function() print(&quot;Part Destroyed!&quot;) end) end local X = if math.random(1,2) == 1 then obj or part X:Destroy() -- Prints &quot;Object Destroyed!&quot; and &quot;Part Destroyed!&quot; (Destroying one will destroy the other)  "},{"title":"LooseTightDoubleGrid","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/LooseTightDoubleGrid","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#types","content":" "},{"title":"EntityId​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#EntityId","content":"&lt;/&gt; type EntityId = number An identifier for an entity in the grid. This is a unique number assigned to each entity upon insertion into the grid. Ids are not unique between different grids, so they should be used only within the context of a single grid instance.  "},{"title":"ShapeType​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#ShapeType","content":"&lt;/&gt; type ShapeType = string The type of shape for an entity in the grid. Use the ShapeType enum for comparisions as the raw values are subject to change.  "},{"title":"FilterParams​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#FilterParams","content":"&lt;/&gt; interface FilterParams { FilterList: {EntityId}? CustomFilter: ((EntityId) → boolean)? FilterType: Enum.RaycastFilterType? } Controls the filtering of entities during queries. You can use either a list of entity IDs or a custom filter function to specify which entities to include or exclude from the query results. The FilterType determines whether the filter is inclusive or exclusive. Uses RaycastFilterType for consistency with Roblox's raycasting system. "},{"title":"Properties​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#properties","content":" "},{"title":"ShapeType​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#ShapeType","content":"&lt;/&gt; LooseTightDoubleGrid.ShapeType: { Circle: ShapeType, Rect: ShapeType, Point: ShapeType } Circle: Represents a circular entity. Rect: Represents a rectangular entity. Point: Represents a point entity. "},{"title":"Functions​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#functions","content":" "},{"title":"new​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#new","content":"&lt;/&gt; LooseTightDoubleGrid.new(config: { Position: Vector2? , Size: Vector2? , CellSize: number? }) → LTDG Creates a new instance of LooseTightDoubleGrid with the given configuration. Position is the center origin of the grid. (Default: Vector2.new(0, 0)) Size is the number of cells in the x and y directions. (Default: Vector2.new(32, 32)) CellSize is the size of each cell in studs. Adjust this number based on the average sizes of your provided entities in order to optimize performance. (Default: 4) local grid = LooseTightDoubleGrid.new({ Position = Vector2.new(0, 0), Size = Vector2.new(32, 32), CellSize = 4 })   "},{"title":"iterating over LooseTightDoubleGrid​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#__iter","content":"&lt;/&gt; for id: EntityId in LooseTightDoubleGrid do Iterates over the entities in the grid. local grid = LooseTightDoubleGrid.new() grid:InsertRect(Vector2.new(10, 10), Vector2.new(5, 5)) for id in grid do print(grid:GetPosition(id)) -- Prints the position of each entity in the grid end   "},{"title":"GetEntities​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntities","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntities() → {EntityId} Gets an array of all currently registered entity IDs in the grid. If you need to iterate over the grid then you should use the __iter metamethod instead.  "},{"title":"InsertRect​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#InsertRect","content":"&lt;/&gt; LooseTightDoubleGrid:InsertRect( position: Vector2 , size: Vector2 ) → EntityId Inserts a rectangular entity into the grid. -- Example Code for generating some parts and registering them in the grid local function V3ToV2(v3: Vector3): Vector2 return Vector2.new(v3.X, v3.Z) end local IdToPart = {} for i = 1, 10 do local part = Instance.new(&quot;Part&quot;) part.Size = Vector3.new(math.random(1, 5), 1, math.random(1, 5)) part.Position = Vector3.new(math.random(-20, 20), 1, math.random(-20, 20)) part.Anchored = true part.Parent = workspace local entityId = grid:InsertRect(V3ToV2(part.Position), V3ToV2(part.Size)) -- Some potential ways you could identify the connection between the part and the entityId: IdToPart[entityId] = part -- A: store the part in a table for later reference part:SetAttribute(&quot;EntityId&quot;, entityId) -- B: store the entity ID in the part's attribute for lookup print(&quot;Inserted Rect Entity ID:&quot;, entityId) end   "},{"title":"InsertCircle​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#InsertCircle","content":"&lt;/&gt; LooseTightDoubleGrid:InsertCircle( position: Vector2 , radius: number ) → EntityId Inserts a circular entity into the grid. local entityId = grid:InsertCircle(Vector2.new(5, 5), 2) print(&quot;Inserted Circle Entity ID:&quot;, entityId)   "},{"title":"InsertPoint​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#InsertPoint","content":"&lt;/&gt; LooseTightDoubleGrid:InsertPoint(position: Vector2 ) → EntityId Inserts a point entity into the grid. local entityId = grid:InsertPoint(Vector2.new(10, 10)) print(&quot;Inserted Point Entity ID:&quot;, entityId)   "},{"title":"UpdateRect​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#UpdateRect","content":"&lt;/&gt; LooseTightDoubleGrid:UpdateRect( entityId: EntityId, newPosition: Vector2 , newSize: Vector2 ) → () Updates the position and size of a rectangular entity. grid:UpdateRect(entityId, Vector2.new(12, 12), Vector2.new(5, 7)) print(&quot;Updated Rect Entity ID:&quot;, entityId)   "},{"title":"UpdateCircle​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#UpdateCircle","content":"&lt;/&gt; LooseTightDoubleGrid:UpdateCircle( entityId: EntityId, newPosition: Vector2 , newRadius: number ) → () Updates the position and radius of a circular entity. grid:UpdateCircle(entityId, Vector2.new(8, 8), 3) print(&quot;Updated Circle Entity ID:&quot;, entityId)   "},{"title":"UpdatePoint​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#UpdatePoint","content":"&lt;/&gt; LooseTightDoubleGrid:UpdatePoint( entityId: EntityId, newPosition: Vector2 ) → () Updates the position of a point entity. grid:UpdatePoint(entityId, Vector2.new(15, 15)) print(&quot;Updated Point Entity ID:&quot;, entityId)   "},{"title":"Remove​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#Remove","content":"&lt;/&gt; LooseTightDoubleGrid:Remove(entityId: EntityId) → boolean Removes an entity from the grid. Return true if the entity was found and removed. Return false if the entity was not found. local entityId = grid:InsertRect(Vector2.new(10, 10), Vector2.new(5, 5)) local didRemove = grid:Remove(entityId)   "},{"title":"Has​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#Has","content":"&lt;/&gt; LooseTightDoubleGrid:Has(entityId: EntityId) → boolean Checks if an entity exists in the grid. local exists = grid:Has(entityId) print(&quot;Entity exists:&quot;, exists)   "},{"title":"GetEntitySize​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntitySize","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntitySize(id: EntityId) → Vector2  Returns the size of an entity. Errors if no entity with the id is in the grid. local size = grid:GetEntitySize(entityId) print(&quot;Entity Size:&quot;, size)   "},{"title":"GetEntityPosition​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntityPosition","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntityPosition(id: EntityId) → Vector2  Returns the position of an entity. Errors if no entity with the id is in the grid.. local position = grid:GetEntityPosition(entityId) print   "},{"title":"GetEntityPositionAndSize​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntityPositionAndSize","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntityPositionAndSize(id: EntityId) → ( Vector2 , Vector2 ) Gets the position and size of an entity. Faster than calling GetEntityPosition and GetEntitySize separately. Errors if no entity with the id is in the grid. local position, size = grid:GetEntityPositionAndSize(entityId) print(&quot;Entity Position:&quot;, position, &quot;Size:&quot;, size)   "},{"title":"GetEntityShape​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntityShape","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntityShape(id: EntityId) → ShapeType Returns the shape type of an entity. Errors if no entity with the id is in the grid. local shapeType = grid:GetEntityShape(entityId) print(&quot;Entity Shape Type:&quot;, shapeType)   "},{"title":"QueryRect​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#QueryRect","content":"&lt;/&gt; LooseTightDoubleGrid:QueryRect( pos: Vector2 , size: Vector2 , filterParams: FilterParams? ) → {EntityId} Queries entities within a rectangular region. local entityIds = grid:QueryRect(Vector2.new(10, 10), Vector2.new(6, 6)) print(&quot;Entities in Rect:&quot;, entityIds)   "},{"title":"QueryCircle​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#QueryCircle","content":"&lt;/&gt; LooseTightDoubleGrid:QueryCircle( pos: Vector2 , radius: number, filterParams: FilterParams? ) → {EntityId} Queries entities within a circular region. local entities = grid:QueryCircle(Vector2.new(15, 15), 5) print(&quot;Entities in Circle:&quot;, entities)   "},{"title":"QueryPoint​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#QueryPoint","content":"&lt;/&gt; LooseTightDoubleGrid:QueryPoint( pos: Vector2 , filterParams: FilterParams? ) → {EntityId} Queries entities at a specific point. local entitiesIds = grid:QueryPoint(Vector2.new(20, 20)) print(&quot;Entities at Point:&quot;, entitiesIds)   "},{"title":"QueryClosestToPoint​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#QueryClosestToPoint","content":"&lt;/&gt; LooseTightDoubleGrid:QueryClosestToPoint( point: Vector2 , filterParams: FilterParams? ) → EntityId? Queries the closest entity to a given point. Closeness is determined by the distance to the edge of the entity's shape. This method searches for the entity that is closest to the specified point in the grid. It considers all shapes (circles, rectangles, and points) and uses a two-tier comparison: Primary Metric: Distance to the edge of the shape. Secondary Metric: Distance to the center of the shape (used to break ties when the point is inside multiple shapes). Under this two-tier metric, the method will return an entity if the point is inside the entity, even if another entities's center is technically closer to the point. Point entities are treated as circles with a radius of 0. The method uses an expanding search algorithm, starting from the tight cell containing the point and gradually expanding outward until the closest entity is found. -- Insert some entities local rectId = grid:InsertRect(Vector2.new(10, 10), Vector2.new(5, 5)) local circleId = grid:InsertCircle(Vector2.new(15, 15), 3) local pointId = grid:InsertPoint(Vector2.new(20, 20)) -- Query the closest entity to a point local closestEntityId = grid:QueryClosestToPoint(Vector2.new(12, 12)) print(&quot;Closest Entity ID:&quot;, closestEntityId)   "},{"title":"Raycast​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#Raycast","content":"&lt;/&gt; LooseTightDoubleGrid:Raycast( origin: Vector2 , direction: Vector2 , filterParams: FilterParams? ) → { Normal: Vector2 , Position: Vector2 , Distance: number, EntityId: EntityId, }? Performs a raycast through the grid, checking for intersections with entities. The ray starts at origin and travels in the direction. The magnitude of the direction vector determines the length of the ray. Returns the closest intersection, including the hit position, normal, distance, and the intersected entity ID. If nothing was hit then it returns nil. local id1 = grid:InsertRect(Vector2.new(5, 0), Vector2.new(2, 2)) local id2 = grid:InsertCircle(Vector2.new(8, 0), 1) local hit = grid:Raycast(Vector2.new(0, 0), Vector2.new(10, 0), { FilterList = {id1}, -- ignore the rect FilterType = Enum.RaycastFilterType.Exclude, }) if hit then print(&quot;Hit entity:&quot;, hit.EntityId) end   "},{"title":"Draw​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#Draw","content":"debug &lt;/&gt; LooseTightDoubleGrid:Draw() → Instance  Renders the grid and its entities for debugging purposes. Subsequent calls will destroy the previous render model. local renderModel = grid:Draw() print(&quot;Render Model:&quot;, renderModel)  "},{"title":"ServerTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#types","content":" "},{"title":"ReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicationTargets","content":"&lt;/&gt; type ReplicationTargets = &quot;All&quot; | Player | {Player } The Player(s) that the STR should replicate to. If &quot;All&quot; is given then the STR will replicate to all current and future players.  "},{"title":"ReplicationToken​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicationToken","content":"&lt;/&gt; type ReplicationToken = {Name: string} A unique symbol that identifies the STR Class. This is used to identify the STR Class when it is replicated to the client. Use .Token to generate an object of this type. Do NOT manually create the table. "},{"title":"Properties​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#properties","content":" "},{"title":"AddedActivePlayer​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#AddedActivePlayer","content":"&lt;/&gt; ServerTableReplicator.AddedActivePlayer: Signal&lt;Player &gt; A signal that fires whenever a player starts being replicated to. This happens when their client requests the current data from the server.  "},{"title":"All​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#All","content":"&lt;/&gt; ServerTableReplicator.All: ServerTableReplicator A STR that replicates to all current and future players. Used as a global parent for child STRs that need a home and should be replicated to all current and future players. Do not modify anything about this STR, only use it as a Parent.  "},{"title":"None​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#None","content":"&lt;/&gt; ServerTableReplicator.None: ServerTableReplicator A STR that doesnt replicate to anyone. Used as a global parent for child STRs that shouldnt be replicated. Do not modify anything about this STR, only use it as a Parent. "},{"title":"Functions​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#functions","content":" "},{"title":"Token​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Token","content":"&lt;/&gt; ServerTableReplicator.Token(tokenName: string) → ReplicationToken Returns a Token Symbol that is used for identifying the ServerTableReplicator Class. We use unique symbols instead of strings to prevent accidental collisions on the server. warning This may only be called once per unique string. The returned symbol should be used repeatedly instead of calling this function again. Calling this function again with the same string will result in an error.  "},{"title":"new​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#new","content":"&lt;/&gt; ServerTableReplicator.new(config: { Token: ReplicationToken, TableManager: TableManager, ReplicationTargets: ReplicationTargets?, Parent: ServerTableReplicator?, Tags: {[string]: any}?, Client: {[string]: any}?, }) → () Creates a new ServerTableReplicator instance. The config must be given a TableManager instance and a Token Symbol. A list of replication targets can be provided to specify which players the STR should replicate to immediately. If no replication targets are specified, the STR will not replicate to any players. You can specify a Parent STR instead of giving ReplicationTargets and it will inherit the replication targets of the top level STR. Optionally, a list of tags can be provided to help identify the STR. The tags list will become immutable internally after the STR is created. EXAMPLE: -- Some Server Script local token = ServerTableReplicator.Token(&quot;PlayerData&quot;) Players.PlayerAdded:Connect(function(player) local manager = TableManager.new({ Money = math.random(1, 100); }) local replicator = ServerTableReplicator.new({ TableManager = manager, Token = token, ReplicationTargets = &quot;All&quot;, Tags = {UserId = player.UserId}, }) end) -- Some Client Script ClientTableReplicator.onNew(&quot;PlayerData&quot;, function(replicator) print(&quot;New PlayerData STR: &quot;, replicator:GetTag(&quot;UserId&quot;)) print(&quot;Money: &quot;, replicator:GetTableManager():Get(&quot;Money&quot;)) end) Top Level Replicators A replicator must be given either a Parent Replicator or a list of ReplicationTargets. If both are given then it will produce an error. If you give ReplicationTargets then that Replicator will be known as TopLevel. Only TopLevel Replicators can have their ReplicationTargets manually changed. If a Parent Replicator is given, the Child Replicator will inherit the replication targets of the Ancestor TopLevel Replicator.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Destroy","content":"&lt;/&gt; ServerTableReplicator:Destroy() → () Destroys the Replicator on both the Server and any replicated Clients  "},{"title":"Subscribe​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Subscribe","content":"&lt;/&gt; ServerTableReplicator:Subscribe(targets: ReplicationTargets) → () Adds a player or list of players to the replication targets.  "},{"title":"Unsubscribe​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Unsubscribe","content":"&lt;/&gt; ServerTableReplicator:Unsubscribe(targets: ReplicationTargets) → () Removes a player or list of players from the replication targets.  "},{"title":"SetSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetSubscribers","content":"&lt;/&gt; ServerTableReplicator:SetSubscribers(targets: ReplicationTargets) → () Overwrites the current replication targets with the new targets.  "},{"title":"IsSubscribed​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsSubscribed","content":"&lt;/&gt; ServerTableReplicator:IsSubscribed(player: Player ) → boolean Checks whether the player is a valid target for replication. Not whether the player is currently being replicated to.  "},{"title":"IsSubscribedToAll​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsSubscribedToAll","content":"&lt;/&gt; ServerTableReplicator:IsSubscribedToAll() → boolean Returns whether or not this STR is replicating to all current and future players.  "},{"title":"GetSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetSubscribers","content":"&lt;/&gt; ServerTableReplicator:GetSubscribers() → {Player } Gets the list of Players that this Replicator is attempting to replicate to.  "},{"title":"GetActiveSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetActiveSubscribers","content":"&lt;/&gt; ServerTableReplicator:GetActiveSubscribers() → {Player } Gets the list of Players that this Replicator is currently replicating to. This is different from GetReplicationTargets as it does not include pending replication targets.  "},{"title":"SetParent​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetParent","content":"&lt;/&gt; ServerTableReplicator:SetParent(newParent: ServerTableReplicator) → () Sets the Parent of this STR to the given STR. "},{"title":"TableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableReplicator","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#properties","content":" "},{"title":"Client​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#Client","content":"This item only works when running on the client. Client &lt;/&gt; TableReplicator.Client: ClientTableReplicator   "},{"title":"Server​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#Server","content":"This item only works when running on the server. Server &lt;/&gt; TableReplicator.Server: ServerTableReplicator  "},{"title":"ServerPlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerPlayerDataManager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#properties","content":" "},{"title":"DEFAULT_MANAGER_NAME​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#DEFAULT_MANAGER_NAME","content":"&lt;/&gt; ServerPlayerDataManager.DEFAULT_MANAGER_NAME: string The default internal manager name.  "},{"title":"PlayerDataReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#PlayerDataReady","content":"&lt;/&gt; ServerPlayerDataManager.PlayerDataReady: Signal&lt;Player &gt; A signal that fires when a Player's data is ready to be used. "},{"title":"Functions​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#new","content":"Constructor Singleton Static &lt;/&gt; ServerPlayerDataManager.new(ppm: PlayerProfileManager?) → ServerPlayerDataManager Constructs a new ServerPlayerDataManager instance. local PPM = PlayerProfileManager.new() local PlayerDataManager = PlayerDataManager.Server.new(PPM) PlayerProfileManager The ServerPlayerDataManager requires a PlayerProfileManager instance in order to properly function. You must provide a PlayerProfileManager instance before you call the :Start method. Optimally you should provide it during the constructor phase.  "},{"title":"OnReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#OnReady","content":"&lt;/&gt; ServerPlayerDataManager:OnReady(player: Player ) → Promise Promise that resolves when the player's data is ready to be used.  "},{"title":"IsReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#IsReady","content":"&lt;/&gt; ServerPlayerDataManager:IsReady(player: Player ) → boolean Checks whether or not a given player's data is ready  "},{"title":"IsManagerRegistered​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#IsManagerRegistered","content":"&lt;/&gt; ServerPlayerDataManager:IsManagerRegistered(managerName: string?) → boolean Checks whether or not a given manager is registered. If one is not specified then it will assume the default one.  "},{"title":"GetManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#GetManager","content":"&lt;/&gt; ServerPlayerDataManager:GetManager( player: Player , managerName: string? ) → TableManager? Fetches one of the given Player's DataManagers. If one is not specified then it will assume the default one.  "},{"title":"PromiseManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#PromiseManager","content":"&lt;/&gt; ServerPlayerDataManager:PromiseManager( player: Player , managerName: string? ) → Promise Promises a TableManager for a given player. If a managerName is not specified then it will assume the default one. ServerPlayerDataManager:PromiseManager(Players.Raildex, &quot;Settings&quot;):andThen(function(manager) manager:Set(&quot;Volume&quot;, 0.5) end)   "},{"title":"ForEachPlayer​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#ForEachPlayer","content":"&lt;/&gt; ServerPlayerDataManager:ForEachPlayer(fn: ( player: Player , data: any ) → ()) → Connection Runs a function for all existing loaded player data and all future player data. ServerPlayerDataManager:ForEachPlayer(function(player) local defaultManager = ServerPlayerDataManager:GetManager(player) defaultManager:Set(&quot;Volume&quot;, 0.5) end)   "},{"title":"GetReplicator​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#GetReplicator","content":"&lt;/&gt; ServerPlayerDataManager:GetReplicator( player: Player , replicatorName: string? ) → TableReplicator? Returns the TableReplicator for a given player. If a replicatorName is not specified then it will assume the default one. local replicator = ServerPlayerDataManager:GetReplicator(Players.Raildex, &quot;Settings&quot;)   "},{"title":"RegisterManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#RegisterManager","content":"&lt;/&gt; ServerPlayerDataManager:RegisterManager(config: { Name: string, GetData: ( player: Player , profile: Profile ) → table, ReplicationTargets: (&quot;All&quot; | &quot;Self&quot; | Player | {Player })?, Tags: table?, Parent: table?, Client: table?, } | string) → () Registers a config table for new managers to use for construction. ServerPlayerDataManager:RegisterManager({ Name = &quot;Settings&quot;, GetData = function(player, profile) return profile.Data.Settings end, ReplicationTargets = &quot;Self&quot;, Tags = {UserId = player.UserId}, }) Modifying the given table DO NOT MODIFY THE TABLE AFTER PASSING IT. Treat it as frozen. Doing so can cause potential desyncs between players.  "},{"title":"Start​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#Start","content":"&lt;/&gt; ServerPlayerDataManager:Start(ppm: PlayerProfileManager?) → () Starts the service and sets up all the Player's data managers. local PlayerDataManager = PlayerDataManager.Server.new() local PPM = PlayerProfileManager.new() PlayerDataManager:Start(PPM)  "},{"title":"ServerRemoteEvent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerRemoteEvent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ServerRemoteEvent","url":"/ModulesOnRails/api/ServerRemoteEvent#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"ServerRemoteEvent","url":"/ModulesOnRails/api/ServerRemoteEvent#Connect","content":"&lt;/&gt; ServerRemoteEvent:Connect(fn: ( player: Player , ...: any ) → nil) → Connection Connect a function to the signal. Anytime a matching ClientRemoteEvent on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"ServerRemoteEvent","url":"/ModulesOnRails/api/ServerRemoteEvent#Fire","content":"&lt;/&gt; ServerRemoteEvent:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireAll​","type":1,"pageTitle":"ServerRemoteEvent","url":"/ModulesOnRails/api/ServerRemoteEvent#FireAll","content":"&lt;/&gt; ServerRemoteEvent:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireExcept​","type":1,"pageTitle":"ServerRemoteEvent","url":"/ModulesOnRails/api/ServerRemoteEvent#FireExcept","content":"&lt;/&gt; ServerRemoteEvent:FireExcept( ignorePlayer: Player ,-- The client to ignore ...: any-- Arguments passed to the other clients ) → () Fires the signal to all clients except the specified client. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"ServerRemoteEvent","url":"/ModulesOnRails/api/ServerRemoteEvent#FireFilter","content":"&lt;/&gt; ServerRemoteEvent:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"FireFor​","type":1,"pageTitle":"ServerRemoteEvent","url":"/ModulesOnRails/api/ServerRemoteEvent#FireFor","content":"&lt;/&gt; ServerRemoteEvent:FireFor( players: {Player }, ...: any ) → () Fires a signal at the clients within the players table. This is useful when signals need to fire for a specific set of players. For more complex firing, see FireFilter. Outbound Middleware All arguments pass through any outbound middleware (if any) before being sent to the clients. local players = {somePlayer1, somePlayer2, somePlayer3} remoteSignal:FireFor(players, &quot;Hello, players!&quot;)   "},{"title":"IsUnreliable​","type":1,"pageTitle":"ServerRemoteEvent","url":"/ModulesOnRails/api/ServerRemoteEvent#IsUnreliable","content":"&lt;/&gt; ServerRemoteEvent:IsUnreliable() → boolean Returns whether this remote event is unreliable (uses UnreliableRemoteEvent). "},{"title":"TableState","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableState","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#new","content":"&lt;/&gt; TableState.new( manager: TableManager, Path: Path ) → TableState Creates a new TableState. This is used to observe and modify values in a TableManager easier. Equivalent to tblMngr:ToState(Path) local tbl = { Coins = 0; Inventory = { &quot;Sword&quot;; &quot;Shield&quot;; }; } local tblMngr = TableManager.new(tbl) local coinsState = TableState.new(tblMngr, &quot;Coins&quot;) print( coinsState == tblMngr:ToTableState(&quot;Coins&quot;) ) -- true coinsState:Set(100) -- equivalent to `tblMngr:SetValue(&quot;Coins&quot;, 100)` local inventoryState = TableState.new(tblMngr, &quot;Inventory&quot;) inventoryState:Insert(&quot;Potion&quot;) -- equivalent to `tblMngr:ArrayInsert(&quot;Inventory&quot;, &quot;Potion&quot;)` States with array values You should avoid setting states to be a particular index in array because if the array is shifted then the state can potentially be pointing to the wrong value.  "},{"title":"Set​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Set","content":"&lt;/&gt; TableState:Set(...: any) → () Sets the value this state is associated with. :Set(999) -- Sets the value itself to 999 :Set(1, 999) -- Sets the value at index 1 to 999 (State must be an array)   "},{"title":"Get​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Get","content":"&lt;/&gt; TableState:Get(index: number?) → any Gets the value this state is associated with. Takes an optional argument to specify the index of the array to get. :Get() -- Gets the value itself :Get(1) -- Gets the value at index 1 of the state (State must be an array) (Equivalent to :Get()[1])   "},{"title":"Increment​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Increment","content":"&lt;/&gt; TableState:Increment(...: any) → any Increments the value this state is associated with. :Increment(999) -- Increments the value itself by 999 :Increment(1, 999) -- Increments the value at index 1 by 999 (State must be an array)   "},{"title":"Insert​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Insert","content":"&lt;/&gt; TableState:Insert(...: any) → () Inserts a value into the array this state is associated with. :Insert(999) -- Appends 999 onto the array :Insert(5, 999) -- Inserts 999 at index 5 of the array   "},{"title":"Remove​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Remove","content":"&lt;/&gt; TableState:Remove(index: number) → any-- The removed value. Removes the value at the given index from the array this state is associated with.  "},{"title":"RemoveFirstValue​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#RemoveFirstValue","content":"&lt;/&gt; TableState:RemoveFirstValue(valueToFind: any) → number-- The index of the removed value. Removes the first value that matches the given value from the array this state is associated with.  "},{"title":"Observe​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Observe","content":"&lt;/&gt; TableState:Observe(fn: (new: any) → ()) → () → () Observes changes to the value this state is associated with. Also fires immediately. See TableManager:Observe for more information. "},{"title":"TableReplicatorSingleton","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableReplicatorSingleton","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#new","content":"&lt;/&gt; TableReplicatorSingleton.new(config: Config) → () "},{"title":"Types","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton##","content":""},{"title":"​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Config","content":"interface Config { ClassTokenName: string-- The name of the class token to listen for. DefaultDataSchema: table?-- The default schema to use if the replicator is not ready yet. ConditionFn: ((replicator: ClientTableReplicator) → boolean)?-- A function that returns whether or not the replicator is valid and should be bound. }  Creates a new TableReplicatorSingleton. local ClientPlayerData = TableReplicatorSingleton.new { ClassTokenName = &quot;PlayerData&quot;; DefaultDataSchema = Import(&quot;PlayerDataSchema&quot;); ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end; } return ClientPlayerData   "},{"title":"Get​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Get","content":"&lt;/&gt; TableReplicatorSingleton:Get( path: Path, index: number? ) → any? Fetches the value at the path. An index can be provided to fetch the value at that index. If the value is not ready yet, it will return the value rom the default schema if one was given. If the path is untraversable, it will return nil. local coins = ClientPlayerData:Get(&quot;Coins&quot;) local thirdItem = ClientPlayerData:Get(&quot;Inventory&quot;, 3) -- Equivalent to `ClientPlayerData:Get(&quot;Inventory&quot;)[3]`   "},{"title":"Observe​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Observe","content":"&lt;/&gt; TableReplicatorSingleton:Observe( path: Path, callback: (newValue: any?) → () ) → () → () Called immediately and then whenever the value at the path changes. The callback will be called with the new value. ClientPlayerData:Observe(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToValueChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToValueChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToValueChange( path: Path, callback: (...any) → () ) → function-- A function that, when called, will disconnect the listener. Called when the value at the path is changed. The callback will be called with the new value. ClientPlayerData:ListenToValueChange(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToAnyChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToAnyChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToAnyChange( path: Path, callback: (...any) → () ) → () → () Called when the value at the path is changed through any means. This includes if the value is an array and a value in the array is changed, inserted, or removed.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ToFusionState","content":"&lt;/&gt; TableReplicatorSingleton:ToFusionState(path: Path) → State&lt;any&gt; Returns a Fusion State object that will automatically update when the value at the path changes. This is useful for when you want to use Fusion dependents to respond to changes in the value. local coinsState = ClientPlayerData:ToFusionState(&quot;Coins&quot;) New &quot;TextLabel&quot; { Text = coinsState; }   "},{"title":"GetTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableManager","content":"&lt;/&gt; TableReplicatorSingleton:GetTableManager() → TableManager Gets the TableManager for the TableReplicatorSingleton. This will error if the TableManager is not ready yet. local TM = ClientPlayerData:GetTableManager()   "},{"title":"GetTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:GetTableReplicator() → ClientTableReplicator Gets the TableReplicator for the TableReplicatorSingleton. This will error if the TableReplicator is not ready yet. local TR = ClientPlayerData:GetTableReplicator()   "},{"title":"PromiseTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableManager","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableManager() → Promise&lt;TableManager&gt; Returns a promise that resolves with the TableManager when it is ready. ClientPlayerData:PromiseTableManager():andThen(function(TM: TableManager) print(&quot;TableManager is ready!&quot;) end)   "},{"title":"PromiseTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableReplicator() → Promise&lt;ClientTableReplicator&gt; Returns a promise that resolves with the TableReplicator when it is ready. ClientPlayerData:PromiseTableReplicator():andThen(function(TR: ClientTableReplicator) print(&quot;TableReplicator is ready!&quot;) end)   "},{"title":"IsReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#IsReady","content":"&lt;/&gt; TableReplicatorSingleton:IsReady() → boolean Returns whether or not a valid Replicator has been found and hooked into. if ClientPlayerData:IsReady() then print(&quot;We have a valid Replicator!&quot;) end   "},{"title":"OnReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#OnReady","content":"&lt;/&gt; TableReplicatorSingleton:OnReady() → Promise&lt;()&gt; Returns a promise that resolves when the TableReplicatorSingleton is ready. ClientPlayerData:OnReady():andThen(function() print(&quot;Found a valid Replicator!&quot;) end)  "},{"title":"ServerComm","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#types","content":" "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions.  "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#new","content":"&lt;/&gt; ServerComm.new( parent: Instance , namespace: string? ) → ServerComm Constructs a ServerComm object. The namespace parameter is used in cases where more than one ServerComm object may be bound to the same object. Otherwise, a default namespace is used. local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) -- If many might exist in the given parent, use a unique namespace: local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;), &quot;MyNamespace&quot;)   "},{"title":"new​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#new","content":"&lt;/&gt; ServerComm.new( parent: Instance , namespace: string? ) → ServerComm Constructs a ServerComm object. The namespace parameter is used in cases where more than one ServerComm object may be bound to the same object. Otherwise, a default namespace is used. local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) -- If many might exist in the given parent, use a unique namespace: local serverComm = ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;), &quot;MyNamespace&quot;)   "},{"title":"BindFunction​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#BindFunction","content":"&lt;/&gt; ServerComm:BindFunction( name: string, fn: ( player: Player , ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired. local function GetSomething(player: Player) return &quot;Something&quot; end serverComm:BindFunction(&quot;GetSomething&quot;, GetSomething)   "},{"title":"WrapMethod​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#WrapMethod","content":"&lt;/&gt; ServerComm:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Binds a function to a table method. The name must match the name of the method in the table. The same name will be used on the client to access the given function. local MyObject = { _Data = 10, } function MyObject:GetData(player: Player) return self._Data end serverComm:WrapMethod(MyObject, &quot;GetData&quot;)   "},{"title":"CreateSignal​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#CreateSignal","content":"&lt;/&gt; ServerComm:CreateSignal( name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal Creates a signal that can be used to fire data to the clients or receive data from the clients. local mySignal = serverComm:CreateSignal(&quot;MySignal&quot;) -- Examples of firing in different ways (see docs for RemoteSignal for further info): mySignal:Fire(somePlayer, &quot;Hello world&quot;) mySignal:FireAll(&quot;Hi there&quot;) mySignal:FireExcept(somePlayer, &quot;Hello everyone except &quot; .. somePlayer.Name) mySignal:FireFilter(function(player) return player.Team == someCoolTeam end, &quot;Hello cool team&quot;) -- Example of listening for clients to send data: mySignal:Connect(function(player, message) print(&quot;Got a message from &quot; .. player.Name .. &quot;:&quot;, message) end)   "},{"title":"CreateProperty​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#CreateProperty","content":"&lt;/&gt; ServerComm:CreateProperty( name: string, initialValue: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteProperty Create a property object which will replicate its property value to the clients. Optionally, specific clients can be targeted with different property values. local comm = Comm.ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) local mapInfo = comm:CreateProperty(&quot;MapInfo&quot;, { MapName = &quot;TheAwesomeMap&quot;, MapDuration = 60, }) -- Change the data: mapInfo:Set({ MapName = &quot;AnotherMap&quot;, MapDuration = 30, }) -- Change the data for one player: mapInfo:SetFor(somePlayer, { MapName = &quot;ASpecialMapForYou&quot;, MapDuration = 90, }) -- Change data based on a predicate function: mapInfo:SetFilter(function(player) return player.Team == game.Teams.SomeSpecialTeam end, { MapName = &quot;TeamMap&quot;, MapDuration = 20, })   "},{"title":"Destroy​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#Destroy","content":"&lt;/&gt; ServerComm:Destroy() → () Destroy the ServerComm object.  "},{"title":"BindFunction​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#BindFunction","content":"&lt;/&gt; ServerComm:BindFunction( name: string, fn: ( player: Player , ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired. local function GetSomething(player: Player) return &quot;Something&quot; end serverComm:BindFunction(&quot;GetSomething&quot;, GetSomething)   "},{"title":"WrapMethod​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#WrapMethod","content":"&lt;/&gt; ServerComm:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Binds a function to a table method. The name must match the name of the method in the table. The same name will be used on the client to access the given function. local MyObject = { _Data = 10, } function MyObject:GetData(player: Player) return self._Data end serverComm:WrapMethod(MyObject, &quot;GetData&quot;)   "},{"title":"CreateSignal​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#CreateSignal","content":"&lt;/&gt; ServerComm:CreateSignal( name: string, unreliable: boolean?, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal Creates a signal that can be used to fire data to the clients or receive data from the clients. By default, signals use RemoteEvents internally. However, if the unreliable argument is set to true, then an UnreliableRemoteEvent will be used instead. local mySignal = serverComm:CreateSignal(&quot;MySignal&quot;) -- Examples of firing in different ways (see docs for RemoteSignal for further info): mySignal:Fire(somePlayer, &quot;Hello world&quot;) mySignal:FireAll(&quot;Hi there&quot;) mySignal:FireExcept(somePlayer, &quot;Hello everyone except &quot; .. somePlayer.Name) mySignal:FireFilter(function(player) return player.Team == someCoolTeam end, &quot;Hello cool team&quot;) -- Example of listening for clients to send data: mySignal:Connect(function(player, message) print(&quot;Got a message from &quot; .. player.Name .. &quot;:&quot;, message) end)   "},{"title":"CreateProperty​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#CreateProperty","content":"&lt;/&gt; ServerComm:CreateProperty( name: string, initialValue: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteProperty Create a property object which will replicate its property value to the clients. Optionally, specific clients can be targeted with different property values. local comm = Comm.ServerComm.new(game:GetService(&quot;ReplicatedStorage&quot;)) local mapInfo = comm:CreateProperty(&quot;MapInfo&quot;, { MapName = &quot;TheAwesomeMap&quot;, MapDuration = 60, }) -- Change the data: mapInfo:Set({ MapName = &quot;AnotherMap&quot;, MapDuration = 30, }) -- Change the data for one player: mapInfo:SetFor(somePlayer, { MapName = &quot;ASpecialMapForYou&quot;, MapDuration = 90, }) -- Change data based on a predicate function: mapInfo:SetFilter(function(player) return player.Team == game.Teams.SomeSpecialTeam end, { MapName = &quot;TeamMap&quot;, MapDuration = 20, })   "},{"title":"Destroy​","type":1,"pageTitle":"ServerComm","url":"/ModulesOnRails/api/ServerComm#Destroy","content":"&lt;/&gt; ServerComm:Destroy() → () Destroy the ServerComm object. "},{"title":"Component","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? Extensions: {Extension}? Methods: {[string]: function}? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end In this forked version of component, extensions can also add methods to the component class and extend other extensions via giving an extension a Methods table. For example: local ExtendedComponentMethods = {} function ExtendedComponentMethods.DoSomething(component) print(&quot;Hello World!&quot;) end local MyComponentExtension = {} MyComponentExtension.Methods = ExtendedComponentMethods This will add a method called DoSomething to the component class. Be careful when using with ShouldExtend It is important to note that these methods are added to the Component Class and not the Component Instance. This means that these methods will be availible regardless of whether the extension passes its shouldExtend function or not. If your code is dependent on extension methods existing only when they pass their shouldExtend function, you may want to avoid using this feature. If you want to utilize other extensions within your extension or guarantee that the given extension is loaded onto the component before your extension, you can use the Extensions table. For example: local SomeOtherExtension = require(somewhere.SomeOtherExtension) local MyComponentExtension = {} MyComponentExtension.Extensions = {SomeOtherExtension} This will guarantee that SomeOtherExtension is added to the component and loaded before MyComponentExtension. info The ShouldExtend function of SomeOtherExtension will still be called independently of the ShouldExtend function of MyExtension. Under the hood this just adds the extension to the components original extension array.  "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects DelaySetup: boolean?-- Optional flag to delay the setup of the component until a later specified time. If true, :_setup() must be called manually. } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#properties","content":" "},{"title":"Started​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)   "},{"title":"DelaySetup​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#DelaySetup","content":"Component &lt;/&gt; Component.DelaySetup: boolean Controls the global default for whether or not components should delay their setup. Overridden by the DelaySetup property if set in the component configuration table passed to Component.new. This is useful for when you want to ensure some other systems that the components may utilize are set up before the components themselves. This value is initialized to the DelaySetup attribute of the script, which defaults to false. caution When set to true, the component class will not automatically call :_setup() when created and expects you to call it when desired. Failing to do so will result in the component never starting to listen for tagged instances and thus never starting any component instances.  "},{"title":"Tag​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Tag","content":"Component &lt;/&gt; Component.Tag: string The tag used to identify the component class. This is used with CollectionService to bind component instances to Roblox instances. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) print(MyComponent.Tag) -- &quot;MyComponent&quot;  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#new","content":"Component &lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:Construct() self.MyData = &quot;Hello&quot; end function MyComponent:Start() local another = self:GetComponent(AnotherComponent) another:DoSomething() end function MyComponent:Stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:HeartbeatUpdate(dt) end function MyComponent:SteppedUpdate(dt) end function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"getUnsetupComponents​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#getUnsetupComponents","content":"Component &lt;/&gt; Component.getUnsetupComponents() → {ComponentClass} Gets a table array of all unsetup component classes. This allows you to call :_setup() on them later. local unsetupComponents = Component.getUnsetupComponents() for _, componentClass in unsetupComponents do Component._setup(componentClass) end   "},{"title":"HeartbeatUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#HeartbeatUpdate","content":"Component Class &lt;/&gt; Component.HeartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:HeartbeatUpdate(dt) end   "},{"title":"SteppedUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#SteppedUpdate","content":"Component Class &lt;/&gt; Component.SteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:SteppedUpdate(dt) end   "},{"title":"RenderSteppedUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#RenderSteppedUpdate","content":"This item only works when running on the client. Client Component Class &lt;/&gt; Component.RenderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:RenderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"_setup​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#_setup","content":"Component Class &lt;/&gt; Component:_setup() → () This is an internal method that is called to set up the component class. It is automatically called when the component class is created, unless theDelaySetup option is set to true in the component configuration. If DelaySetup is true, then this method must be called manually.  "},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetAll","content":"Component Class &lt;/&gt; Component:GetAll() → {Component} Gets a table array of all existing component objects. For example, if there was a component class linked to the &quot;MyComponent&quot; tag, and three Roblox instances in your game had that same tag, then calling GetAll would return the three component instances. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- ... local components = MyComponent:GetAll() for _,component in ipairs(components) do component:DoSomethingHere() end   "},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#FromInstance","content":"Component Class &lt;/&gt; Component:FromInstance(instance: Instance ) → Component? Gets an instance of a component class from the given Roblox instance. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = MyComponent:FromInstance(workspace.SomeInstance)   "},{"title":"WaitForInstance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#WaitForInstance","content":"Component Class &lt;/&gt; Component:WaitForInstance( instance: Instance , timeout: number? ) → Promise&lt;ComponentInstance&gt; Resolves a promise once the component instance is present on a given Roblox instance. An optional timeout can be provided to reject the promise if it takes more than timeout seconds to resolve. If no timeout is supplied, timeout defaults to 60 seconds. local MyComponent = require(somewhere.MyComponent) MyComponent:WaitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance) -- Do something with the component class end)   "},{"title":"UpdateAncestors​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#UpdateAncestors","content":"Component Class &lt;/&gt; Component:UpdateAncestors(newAncestors: {Instance }) → () Allows for you to update the valid ancestors of a component class. This is useful if you want to give a valid ancestor that may not exist when the component is first created. local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, }) task.defer(function() local newAncestors = {workspace:WaitForChild(&quot;SomeFolder&quot;)} MyComponent:UpdateAncestors(newAncestors) end)   "},{"title":"GetAncestors​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetAncestors","content":"Component Class &lt;/&gt; Component:GetAncestors() → {Instance } Gets the current valid ancestors of a component class.  "},{"title":"Construct​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Construct","content":"Component Class &lt;/&gt; Component:Construct() → () Construct is called before the component is started, and should be used to construct the component instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"Start​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Start","content":"Component Class &lt;/&gt; Component:Start() → () Start is called when the component is started. At this point in time, it is safe to grab other components also bound to the same instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() -- e.g., grab another component: local another = self:GetComponent(AnotherComponent) end   "},{"title":"Stop​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Stop","content":"Component Class &lt;/&gt; Component:Stop() → () Stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.Instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Stop() self.SomeStuff:Destroy() end   "},{"title":"GetComponent​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetComponent","content":"Component Instance &lt;/&gt; Component:GetComponent(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() local another = self:GetComponent(AnotherComponent) end   "},{"title":"WhileHasComponent​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#WhileHasComponent","content":"Component Instance &lt;/&gt; Component:WhileHasComponent( componentClassOrClasses: ComponentClass | {ComponentClass}, fn: ( components: Component | {Component}, jani: Janitor ) → () ) → Connection Ties a function to the lifecycle of the calling component and the equivalent component of the givencomponentClass. The function is run whenever a component of the given class is started. The given function passes the sibling component of the given class and a janitor to handle any connections you may make within it. The Janitor is cleaned up whenever either compenent is stopped. local AnotherComponentClass = require(somewhere.AnotherComponent) local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Start() self:WhileHasComponent(AnotherComponentClass, function(siblingComponent, jani) print(siblingComponent.SomeProperty) jani:Add(function() print(&quot;Sibling component stopped&quot;) end) end) end  "},{"title":"ServerNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerNetWire","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#types","content":" "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...any ) Middleware function for server-side operations. Returns whether to continue processing and any modified arguments. "},{"title":"Functions​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#new","content":"constructor static &lt;/&gt; ServerNetWire.new( nameSpace: string | Service-- The namespace for the NetWire or a Service object ) → ServerNetWire Constructs a new ServerNetWire. If a ServerNetWire with the same nameSpace already exists, it will be returned instead.  "},{"title":"setupServiceNetworking​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#setupServiceNetworking","content":"constructor static &lt;/&gt; ServerNetWire.setupServiceNetworking(service: Service) → ServerNetWire Creates a ServerNetWire from a Roam Service. This method will read the service's Name and Client table to create the NetWire. The goal of this function is to recreate the simplicity of Knit's networking features without the systems being coupled together. In order to access the service on the client, use NetWire.Client(&quot;SERVICE_NAME&quot;). local NetWire = require(Packages.NetWire).Server local Roam = require(Packages.Roam) ---------------------------------------------------------------- local ExampleService = {} ExampleService.Client = { TestEvent = NetWire.createEvent() } function ExampleService.Client:Greeting(plr: Player, msg: string) print(plr.Name, &quot;said&quot;, msg) end ---------------------------------------------------------------- function ExampleService:RoamInit() -- Build the NetWire from the service Client table and replace it NetWire.setupServiceNetworking(self) end function ExampleService:RoamStart() task.wait(10) -- send a message to all clients self.Client.TestEvent:FireAll(&quot;Hello from ExampleService!&quot;) end ---------------------------------------------------------------- Roam.registerService(ExampleService, &quot;ExampleService&quot;) return ExampleService Client Table Overwrite Calling this function will overwrite the service's Client table with the NetWire. You should not store anything aside from supported NetWire objects in the Client table. Where to call This function should be called within the init method of the service. This is to prevent netwires from being created outside of a running game.  "},{"title":"RegisterEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterEvent","content":"&lt;/&gt; ServerNetWire:RegisterEvent( eventName: string, isUnreliable: boolean?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote event with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteSignal Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteSignal -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestEvent = NetWire.createEvent() myWire.TestEvent:Connect(function(plr: Player, someArg) print(someArg) end) myWire.TestEvent:FireAll(&quot;Hello from the server!&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire.TestEvent:Connect(function(someArg) print(someArg) end) myWire.TestEvent:Fire(&quot;Hello from the client!&quot;)   "},{"title":"RegisterProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterProperty","content":"&lt;/&gt; ServerNetWire:RegisterProperty( propertyName: string, initialValue: any?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote property with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteProperty Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteProperty -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestProperty = NetWire.createProperty(&quot;Hello&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) if myWire.TestProperty:IsReady() then -- Check if its ready first print( myWire.TestProperty:Get() ) -- &quot;Hello&quot; end   "},{"title":"RegisterMethod​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterMethod","content":"&lt;/&gt; ServerNetWire:RegisterMethod( functionName: string, callback: ( self: any, plr: Player , ...any ) → (...any), tbl: {}?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote function with the given name. This is not suggested to be used by end users; instead you should just append a function to a netwire object and it will properly wrap it for you. -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) function myWire:TestMethod(plr: Player, arg: number) return arg * 2 end --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire:TestMethod(5):andThen(function(result) print(result) -- 10 end)  "},{"title":"Roam","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Roam","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#types","content":" "},{"title":"ServiceConfig​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#ServiceConfig","content":"&lt;/&gt; interface ServiceConfig { Name: string-- Name of the Service. Must be unique. Used when accessing via .getService RequiredServices: {Service}?-- The Services that this Service depends on. Roam will ensure that these Services are initialized before this Service. StartMethodName: string?-- Overrides default StartMethodName of &quot;RoamStart&quot; InitMethodName: string?-- Overrides default InitMethodName of &quot;RoamInit&quot; } local myOtherService = require(ReplicatedStorage.MyOtherService) ------------------------------------------------- local MyService = {} function MyService:CustomStartMethod() print(&quot;MyService started!&quot;) end ------------------------------------------------- Roam.registerService(MyService, { Name = &quot;MyService&quot;, RequiredServices = {myOtherService}, StartMethodName = &quot;CustomStartMethod&quot;, }) return MyService Deffering RequiredServices Do NOT add services to the RequiredServices after you have created or registered the service. This will cause undefined behavior. "},{"title":"Properties​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#properties","content":" "},{"title":"Debug​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#Debug","content":"&lt;/&gt; Roam.Debug: boolean Whether or not to print debug messages. Default is false.  "},{"title":"Bootstrappers​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#Bootstrappers","content":"&lt;/&gt; Roam.Bootstrappers: { Server: (script: Script ) → (), Client: (script: Script ) → () } A table of generic bootstrappers for Roam that you can use to quickly setup new projects. local Roam = require(Packages.Roam) Roam.Bootstrappers.Server(script) :andThenCall(print, &quot;Roam Server Bootstrapped!&quot;)  "},{"title":"Functions​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#functions","content":" "},{"title":"registerService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#registerService","content":"&lt;/&gt; Roam.registerService( service: Service, serviceConfig: (ServiceConfig | string)? ) → Service Registers a Service/Table with Roam to be Initialized and Started when Roam starts. Cannot be called after Roam has been started. local MyRegisteredService = {} function MyRegisteredService:RoamStart() print(&quot;MyRegisteredService started!&quot;) end function MyRegisteredService:RoamInit() print(&quot;MyRegisteredService initialized!&quot;) end ---------------------------------------------------------------- local Roam = require(Packages.Roam) Roam.registerService(MyRegisteredService, &quot;MyRegisteredService&quot;) return MyRegisteredService   "},{"title":"start​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#start","content":"&lt;/&gt; Roam.start(postInitPreStart: (() → (Promise?))?) → Promise Starts Roam. Should only be called once. Calling multiple times will result in a promise rejection. Optional argument postInitPreStart is a function that is called after all services have been initialized, but before they are started. Roam.start() :andThenCall(print, &quot;Roam started!&quot;) :catch(warn) caution Be sure that all services have been created before calling Start. Services cannot be added later. Bootstrapping You can use the Roam.Bootstrappers table/methods to quickly bootstrap Roam in your project. This is reccomended as it will provide a consistent starting point for your projects.  "},{"title":"onStart​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#onStart","content":"&lt;/&gt; Roam.onStart() → Promise Returns a promise that is resolved once Roam has started. This is useful for any code that needs to tie into Roam services but is not the script that called Start. Roam.onStart():andThen(function() local MyService = Roam.Services.MyService MyService:DoSomething() end):catch(warn)   "},{"title":"isReady​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#isReady","content":"&lt;/&gt; Roam.isReady() → boolean Returns whether or not Roam has been successfully started and is ready for external access.  "},{"title":"requireModules​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#requireModules","content":"&lt;/&gt; Roam.requireModules( parents: Instance | {Instance }, config: { DeepSearch: boolean?, RequirePredicate: ((obj: ModuleScript ) → boolean)?, IgnoreDescendantsPredicate: ((obj: Instance ) → boolean)?, }? ) → {Service} Requires all the modules that are children of the given parent. This is an easy way to quickly load all services that might be in a folder. Takes an optional predicate function to filter which modules are loaded. Services collected this way must not yield. DeepSearch -&gt; whether it checks descendants or just children RequirePredicate -&gt; a predicate function that determines whether a module should be required IgnoreDescendantsPredicate -&gt; A Predicate for whether the Descendants of the Module should be Searched (Only matters if DeepSearch is true) local pred = function(obj: ModuleScript): boolean return obj.Name:match(&quot;Service$&quot;) ~= nil end Roam.requireModules(ReplicatedStorage.Shared, { DeepSearch = true, RequirePredicate = pred, IgnoreDescendantsPredicate = function(obj: Instance): boolean return obj.Name == &quot;Ignore&quot; end, })   "},{"title":"getNameFromService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#getNameFromService","content":"&lt;/&gt; Roam.getNameFromService(service: Service) → string Fetches the name of a registered Service. "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RemoteProperty","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the top-level value of all clients to the same value. Override Per-Player Data This will override any per-player data that was set usingSetFor or SetFilter. To avoid overriding this data, SetTop can be used instead. -- Examples remoteProperty:Set(10) remoteProperty:Set({SomeData = 32}) remoteProperty:Set(&quot;HelloWorld&quot;)   "},{"title":"SetTop​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetTop","content":"&lt;/&gt; RemoteProperty:SetTop(value: any) → () Set the top-level value of the property, but does not override any per-player data (e.g. set with SetFor or SetFilter). Any player without custom-set data will receive this new data. This is useful if certain players have specific values that should not be changed, but all other players should receive the same new value. -- Using just 'Set' overrides per-player data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Using 'SetTop' does not override: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot;   "},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetFilter","content":"&lt;/&gt; RemoteProperty:SetFilter( predicate: ( Player , any ) → boolean, value: any-- Value to set for the clients (and to the predicate) ) → () Sets the value for specific clients that pass the predicate function test. This can be used to finely set the values based on more control logic (e.g. setting certain values per team). -- Set the value of &quot;NewValue&quot; to players with a name longer than 10 characters: remoteProperty:SetFilter(function(player) return #player.Name &gt; 10 end, &quot;NewValue&quot;)   "},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetFor","content":"&lt;/&gt; RemoteProperty:SetFor( player: Player , value: any ) → () Set the value of the property for a specific player. This will override the value used by Set (and the initial value set for the property when created). This value can be nil. In order to reset the value for a given player and let the player use the top-level value held by this property, either use Set to set all players' data, or use ClearFor. remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;)   "},{"title":"SetForList​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetForList","content":"&lt;/&gt; RemoteProperty:SetForList( players: {Player }, value: any ) → () Set the value of the property for specific players. This just loops through the players given and calls SetFor. local players = {player1, player2, player3} remoteProperty:SetForList(players, &quot;CustomData&quot;)   "},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearFor","content":"&lt;/&gt; RemoteProperty:ClearFor(player: Player ) → () Clears the custom property value for the given player. When this occurs, the player will reset to use the top-level value held by this property (either the value set when the property was created, or the last value set by Set). remoteProperty:Set(&quot;DATA&quot;) remoteProperty:SetFor(somePlayer, &quot;CUSTOM_DATA&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CUSTOM_DATA&quot; -- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL: remoteProperty:SetFor(somePlayer, nil) print(remoteProperty:GetFor(somePlayer)) --&gt; nil -- CLEAR: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;DATA&quot;   "},{"title":"ClearForList​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearForList","content":"&lt;/&gt; RemoteProperty:ClearForList(players: {Player }) → () Clears the custom value for the given players. This just loops through the list of players and calls the ClearFor method for each player.  "},{"title":"ClearFilter​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearFilter","content":"&lt;/&gt; RemoteProperty:ClearFilter(predicate: (Player ) → boolean) → () The same as SetFiler, except clears the custom value for any player that passes the predicate.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → any Returns the top-level value held by the property. This will either be the initial value set, or the last value set with Set(). remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:Get()) --&gt; &quot;Data&quot;   "},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#GetFor","content":"&lt;/&gt; RemoteProperty:GetFor(player: Player ) → any Returns the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). -- Set top level data: remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Set custom data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Set top level again, overriding custom data: remoteProperty:Set(&quot;NewData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;NewData&quot; -- Set custom data again, and set top level without overriding: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Clear custom data to use top level data: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot;   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the RemoteProperty object.  "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the top-level value of all clients to the same value. Override Per-Player Data This will override any per-player data that was set usingSetFor or SetFilter. To avoid overriding this data, SetTop can be used instead. -- Examples remoteProperty:Set(10) remoteProperty:Set({SomeData = 32}) remoteProperty:Set(&quot;HelloWorld&quot;)   "},{"title":"SetTop​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetTop","content":"&lt;/&gt; RemoteProperty:SetTop(value: any) → () Set the top-level value of the property, but does not override any per-player data (e.g. set with SetFor or SetFilter). Any player without custom-set data will receive this new data. This is useful if certain players have specific values that should not be changed, but all other players should receive the same new value. -- Using just 'Set' overrides per-player data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Using 'SetTop' does not override: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot;   "},{"title":"SetFilter​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetFilter","content":"&lt;/&gt; RemoteProperty:SetFilter( predicate: ( Player , any ) → boolean, value: any-- Value to set for the clients (and to the predicate) ) → () Sets the value for specific clients that pass the predicate function test. This can be used to finely set the values based on more control logic (e.g. setting certain values per team). -- Set the value of &quot;NewValue&quot; to players with a name longer than 10 characters: remoteProperty:SetFilter(function(player) return #player.Name &gt; 10 end, &quot;NewValue&quot;)   "},{"title":"SetFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetFor","content":"&lt;/&gt; RemoteProperty:SetFor( player: Player , value: any ) → () Set the value of the property for a specific player. This will override the value used by Set (and the initial value set for the property when created). This value can be nil. In order to reset the value for a given player and let the player use the top-level value held by this property, either use Set to set all players' data, or use ClearFor. remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;)   "},{"title":"SetForList​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#SetForList","content":"&lt;/&gt; RemoteProperty:SetForList( players: {Player }, value: any ) → () Set the value of the property for specific players. This just loops through the players given and calls SetFor. local players = {player1, player2, player3} remoteProperty:SetForList(players, &quot;CustomData&quot;)   "},{"title":"ClearFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearFor","content":"&lt;/&gt; RemoteProperty:ClearFor(player: Player ) → () Clears the custom property value for the given player. When this occurs, the player will reset to use the top-level value held by this property (either the value set when the property was created, or the last value set by Set). remoteProperty:Set(&quot;DATA&quot;) remoteProperty:SetFor(somePlayer, &quot;CUSTOM_DATA&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CUSTOM_DATA&quot; -- DOES NOT CLEAR, JUST SETS CUSTOM DATA TO NIL: remoteProperty:SetFor(somePlayer, nil) print(remoteProperty:GetFor(somePlayer)) --&gt; nil -- CLEAR: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;DATA&quot;   "},{"title":"ClearForList​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearForList","content":"&lt;/&gt; RemoteProperty:ClearForList(players: {Player }) → () Clears the custom value for the given players. This just loops through the list of players and calls the ClearFor method for each player.  "},{"title":"ClearFilter​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#ClearFilter","content":"&lt;/&gt; RemoteProperty:ClearFilter(predicate: (Player ) → boolean) → () The same as SetFiler, except clears the custom value for any player that passes the predicate.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → any Returns the top-level value held by the property. This will either be the initial value set, or the last value set with Set(). remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:Get()) --&gt; &quot;Data&quot;   "},{"title":"GetFor​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#GetFor","content":"&lt;/&gt; RemoteProperty:GetFor(player: Player ) → any Returns the current value for the given player. This value will depend on if SetFor or SetFilter has affected the custom value for the player. If so, that custom value will be returned. Otherwise, the top-level value will be used (e.g. value from Set). -- Set top level data: remoteProperty:Set(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot; -- Set custom data: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Set top level again, overriding custom data: remoteProperty:Set(&quot;NewData&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;NewData&quot; -- Set custom data again, and set top level without overriding: remoteProperty:SetFor(somePlayer, &quot;CustomData&quot;) remoteProperty:SetTop(&quot;Data&quot;) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;CustomData&quot; -- Clear custom data to use top level data: remoteProperty:ClearFor(somePlayer) print(remoteProperty:GetFor(somePlayer)) --&gt; &quot;Data&quot;   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"/ModulesOnRails/api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the RemoteProperty object. "},{"title":"Promise","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Promise","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#types","content":" "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#Status","content":"enum &lt;/&gt; interface Status { Started: &quot;Started&quot;-- The Promise is executing, and not settled yet. Resolved: &quot;Resolved&quot;-- The Promise finished successfully. Rejected: &quot;Rejected&quot;-- The Promise was rejected. Cancelled: &quot;Cancelled&quot;-- The Promise was cancelled before it finished. } An enum value used to represent the Promise's status. "},{"title":"Properties​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#properties","content":" "},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#Status","content":"This item is read only and cannot be modified. Read Only enums &lt;/&gt; Promise.Status: Status A table containing all members of the Status enum, e.g., Promise.Status.Resolved. "},{"title":"Functions​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#new","content":"&lt;/&gt; Promise.new(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise Construct a new Promise that will be resolved or rejected with the given callbacks. If you resolve with a Promise, it will be chained onto. You can safely yield within the executor function and it will not block the creating thread. local myFunction() return Promise.new(function(resolve, reject, onCancel) wait(1) resolve(&quot;Hello world!&quot;) end) end myFunction():andThen(print) You do not need to use pcall within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If error() is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into Promise.Error(Promise.Error.Kind.ExecutionError) objects for tracking debug information. You may register an optional cancellation hook by using the onCancel argument: This should be used to abort any ongoing operations leading up to the promise being settled. Call the onCancel function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled. onCancel returns true if the Promise was already cancelled when you called onCancel. Calling onCancel with no argument will not override a previously set cancellation hook, but it will still return true if the Promise is currently cancelled. You can set the cancellation hook at any time before resolving. When a promise is cancelled, calls to resolve or reject will be ignored, regardless of if you set a cancellation hook or not. caution If the Promise is cancelled, the executor thread is closed with coroutine.close after the cancellation hook is called. You must perform any cleanup code in the cancellation hook: any time your executor yields, it may never resume.  "},{"title":"defer​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#defer","content":"&lt;/&gt; Promise.defer(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise The same as Promise.new, except execution begins after the next Heartbeat event. This is a spiritual replacement for spawn, but it does not suffer from the same issues as spawn. local function waitForChild(instance, childName, timeout) return Promise.defer(function(resolve, reject) local child = instance:WaitForChild(childName, timeout) ;(child and resolve or reject)(child) end) end   "},{"title":"resolve​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#resolve","content":"&lt;/&gt; Promise.resolve(...: any) → Promise&lt;...any&gt; Creates an immediately resolved Promise with the given value. -- Example using Promise.resolve to deliver cached values: function getSomething(name) if cache[name] then return Promise.resolve(cache[name]) else return Promise.new(function(resolve, reject) local thing = getTheThing() cache[name] = thing resolve(thing) end) end end   "},{"title":"reject​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#reject","content":"&lt;/&gt; Promise.reject(...: any) → Promise&lt;...any&gt; Creates an immediately rejected Promise with the given value. caution Something needs to consume this rejection (i.e. :catch() it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.  "},{"title":"try​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#try","content":"&lt;/&gt; Promise.try( callback: (...: T...) → ...any, ...: T...-- Additional arguments passed to callback ) → Promise Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback. info Promise.try is similar to Promise.promisify, except the callback is invoked immediately instead of returning a new function. Promise.try(function() return math.random(1, 2) == 1 and &quot;ok&quot; or error(&quot;Oh an error!&quot;) end) :andThen(function(text) print(text) end) :catch(function(err) warn(&quot;Something went wrong&quot;) end)   "},{"title":"all​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#all","content":"&lt;/&gt; Promise.all(promises: {Promise&lt;T&gt;}) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a new promise that: is resolved after all input promises resolve. is rejected if any input promises reject. info Only the first return value from each promise will be present in the resulting array. After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.all(promises)   "},{"title":"fold​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#fold","content":"since v3.1.0 &lt;/&gt; Promise.fold( list: {T | Promise&lt;T&gt;}, reducer: ( accumulator: U, value: T, index: number ) → U | Promise&lt;U&gt;, initialValue: U ) → () Folds an array of values or promises into a single value. The array is traversed sequentially. The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value. The folding will stop at the first rejection encountered. local basket = {&quot;blueberry&quot;, &quot;melon&quot;, &quot;pear&quot;, &quot;melon&quot;} Promise.fold(basket, function(cost, fruit) if fruit == &quot;blueberry&quot; then return cost -- blueberries are free! else -- call a function that returns a promise with the fruit price return fetchPrice(fruit):andThen(function(fruitCost) return cost + fruitCost end) end end, 0)   "},{"title":"some​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#some","content":"&lt;/&gt; Promise.some( promises: {Promise&lt;T&gt;}, count: number ) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as count Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers. count 0 results in an empty array. The resultant array will never have more than count elements. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve   "},{"title":"any​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#any","content":"&lt;/&gt; Promise.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as any of the input Promises resolves. It will reject only if all input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers. Resolves directly with the value of the first resolved Promise. This is essentially [Promise.some] with 1 count, except the Promise resolves with the value directly instead of an array with one element. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)   "},{"title":"allSettled​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#allSettled","content":"&lt;/&gt; Promise.allSettled(promises: {Promise&lt;T&gt;}) → Promise&lt;{Status}&gt; Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping promise:finally over the array of Promises. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.allSettled(promises)   "},{"title":"race​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#race","content":"&lt;/&gt; Promise.race(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects. warning If the first Promise to settle from the array settles with a rejection, the resulting Promise from race will reject. If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use Promise.any or Promise.some instead. All other Promises that don't win the race will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.race(promises) -- Only returns 1st value to resolve or reject   "},{"title":"each​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#each","content":"since 3.0.0 &lt;/&gt; Promise.each( list: {T | Promise&lt;T&gt;}, predicate: ( value: T, index: number ) → U | Promise&lt;U&gt; ) → Promise&lt;{U}&gt; Iterates serially over the given an array of values, calling the predicate callback on each value before continuing. If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item in the array. info Promise.each is similar to Promise.all, except the Promises are ran in order instead of all at once. But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time. The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value. Promise.each({ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot; }, function(value, index) return Promise.delay(1):andThen(function() print((&quot;%d) Got %s!&quot;):format(index, value)) end) end) --[[ (1 second passes) &gt; 1) Got foo! (1 second passes) &gt; 2) Got bar! (1 second passes) &gt; 3) Got baz! (1 second passes) &gt; 4) Got qux! ]] If the Promise a predicate returns rejects, the Promise from Promise.each is also rejected with the same value. If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value. If a Promise in the array of values is already Rejected when Promise.each is called, Promise.each rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when Promise.each is called, Promise.each rejects with Promise.Error(Promise.Error.Kind.AlreadyCancelled). If a Promise in the array of values is Started at first, but later rejects, Promise.each will reject with that value and iteration will not continue once iteration encounters that value. Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values. If this Promise returned from Promise.each rejects or is cancelled for any reason, the following are true: Iteration will not continue. Any Promises within the array of values will now be cancelled if they have no other consumers. The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.  "},{"title":"is​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#is","content":"&lt;/&gt; Promise.is(object: any) → boolean-- true if the given object is a Promise. Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an andThen method.  "},{"title":"promisify​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#promisify","content":"&lt;/&gt; Promise.promisify(callback: (...: any) → ...any) → (...: any) → Promise Wraps a function that yields into one that returns a Promise. Any errors that occur while executing the function will be turned into rejections. info Promise.promisify is similar to Promise.try, except the callback is returned as a callable function instead of being invoked immediately. local sleep = Promise.promisify(wait) sleep(1):andThen(print) local isPlayerInGroup = Promise.promisify(function(player, groupId) return player:IsInGroup(groupId) end)   "},{"title":"delay​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#delay","content":"&lt;/&gt; Promise.delay(seconds: number) → Promise&lt;number&gt; Returns a Promise that resolves after seconds seconds have passed. The Promise resolves with the actual amount of time that was waited. This function is not a wrapper around wait. Promise.delay uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler. warning Passing NaN, infinity, or a number less than 1/60 is equivalent to passing 1/60. Promise.delay(5):andThenCall(print, &quot;This prints after 5 seconds&quot;)   "},{"title":"retry​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#retry","content":"since 3.0.0 &lt;/&gt; Promise.retry( callback: (...: P) → Promise&lt;T&gt;, times: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise. local function canFail(a, b, c) return Promise.new(function(resolve, reject) -- do something that can fail local failed, thing = doSomethingThatCanFail(a, b, c) if failed then reject(&quot;it failed&quot;) else resolve(thing) end end) end local MAX_RETRIES = 10 local value = Promise.retry(canFail, MAX_RETRIES, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) -- args to send to canFail   "},{"title":"retryWithDelay​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#retryWithDelay","content":"since v3.2.0 &lt;/&gt; Promise.retryWithDelay( callback: (...: P) → Promise&lt;T&gt;, times: number, seconds: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, waiting seconds seconds between each retry, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise.  "},{"title":"fromEvent​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#fromEvent","content":"since 3.0.0 &lt;/&gt; Promise.fromEvent( event: Event,-- Any object with a Connect method. This includes all Roblox events. predicate?: (...: P) → boolean-- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again. ) → Promise&lt;P&gt; Converts an event into a Promise which resolves the next time the event fires. The optional predicate callback, if passed, will receive the event arguments and should return true or false, based on if this fired event should resolve the Promise or not. If true, the Promise resolves. If false, nothing happens and the predicate will be rerun the next time the event fires. The Promise will resolve with the event arguments. tip This function will work given any object with a Connect method. This includes all Roblox events. -- Creates a Promise which only resolves when `somePart` is touched -- by a part named `&quot;Something specific&quot;`. return Promise.fromEvent(somePart.Touched, function(part) return part.Name == &quot;Something specific&quot; end)   "},{"title":"onUnhandledRejection​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#onUnhandledRejection","content":"since v3.2.0 &lt;/&gt; Promise.onUnhandledRejection( callback: ( promise: Promise, ...: any )-- A callback that runs when an unhandled rejection happens. ) → () → ()-- Function that unregisters the callback when called Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise is rejected, and the rejection is not observed with :catch. The callback is called with the actual promise that rejected, followed by the rejection values.  "},{"title":"timeout​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#timeout","content":"&lt;/&gt; Promise:timeout( seconds: number, rejectionValue?: any-- The value to reject with if the timeout is reached ) → Promise Returns a new Promise that resolves if the chained Promise resolves within seconds seconds, or rejects if execution time exceeds seconds. The chained Promise will be cancelled if the timeout is reached. Rejects with rejectionValue if it is non-nil. If a rejectionValue is not given, it will reject with a Promise.Error(Promise.Error.Kind.TimedOut). This can be checked with [Error.isKind]. getSomething():timeout(5):andThen(function(something) -- got something and it only took at max 5 seconds end):catch(function(e) -- Either getting something failed or the time was exceeded. if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then warn(&quot;Operation timed out!&quot;) else warn(&quot;Operation encountered an error!&quot;) end end) Sugar for: Promise.race({ Promise.delay(seconds):andThen(function() return Promise.reject( rejectionValue == nil and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut }) or rejectionValue ) end), promise })   "},{"title":"getStatus​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#getStatus","content":"&lt;/&gt; Promise:getStatus() → Status Returns the current Promise status.  "},{"title":"andThen​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThen","content":"&lt;/&gt; Promise:andThen( successHandler: (...: any) → ...any, failureHandler?: (...: any) → ...any ) → Promise&lt;...any&gt; Chains onto an existing Promise and returns a new Promise. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. You can return a Promise from the success or failure handler and it will be chained onto. Calling andThen on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by andThen is cancelled, successHandler and failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"catch​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#catch","content":"&lt;/&gt; Promise:catch(failureHandler: (...: any) → ...any) → Promise&lt;...any&gt; Shorthand for Promise:andThen(nil, failureHandler). Returns a Promise that resolves if the failureHandler worked without encountering an additional error. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [Error] objects. If you want to treat it as a string for debugging, you should call tostring on it first. Calling catch on a cancelled Promise returns a cancelled Promise. tip If the Promise returned by catch is cancelled, failureHandler will not run. To run code no matter what, use Promise:finally.  "},{"title":"tap​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#tap","content":"&lt;/&gt; Promise:tap(tapHandler: (...: any) → ...any) → Promise&lt;...any&gt; Similar to Promise.andThen, except the return value is the same as the value passed to the handler. In other words, you can insert a :tap into a Promise chain without affecting the value that downstream Promises receive. getTheValue() :tap(print) :andThen(function(theValue) print(&quot;Got&quot;, theValue, &quot;even though print returns nil!&quot;) end) If you return a Promise from the tap handler callback, its value will be discarded but tap will still wait until it resolves before passing the original value through.  "},{"title":"andThenCall​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThenCall","content":"&lt;/&gt; Promise:andThenCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Attaches an andThen handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded. promise:andThenCall(someFunction, &quot;some&quot;, &quot;arguments&quot;) This is sugar for promise:andThen(function() return someFunction(&quot;some&quot;, &quot;arguments&quot;) end)   "},{"title":"andThenReturn​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#andThenReturn","content":"&lt;/&gt; Promise:andThenReturn( ...: any-- Values to return from the function ) → Promise Attaches an andThen handler to this Promise that discards the resolved value and returns the given value from it. promise:andThenReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:andThen(function() return &quot;some&quot;, &quot;values&quot; end) caution Promises are eager, so if you pass a Promise to andThenReturn, it will begin executing before andThenReturn is reached in the chain. Likewise, if you pass a Promise created from [Promise.reject] into andThenReturn, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [Promise.andThen].  "},{"title":"cancel​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#cancel","content":"&lt;/&gt; Promise:cancel() → () Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled. Cancellations will propagate upwards and downwards through chained promises. Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call andThen twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled. promise:cancel()   "},{"title":"finally​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finally","content":"&lt;/&gt; Promise:finally(finallyHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, or cancelled. Returns a new Promise that: resolves with the same values that this Promise resolves with. rejects with the same values that this Promise rejects with. is cancelled if this Promise is cancelled. If the value you return from the handler is a Promise: We wait for the Promise to resolve, but we ultimately discard the resolved value. If the returned Promise rejects, the Promise returned from finally will reject with the rejected value from the returned promise. If the finally Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too. Otherwise, the return value from the finally handler is entirely discarded. Cancellation As of Promise v4, Promise:finally does not count as a consumer of the parent Promise for cancellation purposes. This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is cancelled and the finally callbacks run then and there. Cancellation still propagates through the finally Promise though: if you cancel the finally Promise, it can cancel its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the finally Promise will also be cancelled. local thing = createSomething() doSomethingWith(thing) :andThen(function() print(&quot;It worked!&quot;) -- do something.. end) :catch(function() warn(&quot;Oh no it failed!&quot;) end) :finally(function() -- either way, destroy thing thing:Destroy() end)   "},{"title":"finallyCall​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finallyCall","content":"&lt;/&gt; Promise:finallyCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for finally. Attaches a finally handler to this Promise that calls the given callback with the predefined arguments.  "},{"title":"finallyReturn​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#finallyReturn","content":"&lt;/&gt; Promise:finallyReturn( ...: any-- Values to return from the function ) → Promise Attaches a finally handler to this Promise that discards the resolved value and returns the given value from it. promise:finallyReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:finally(function() return &quot;some&quot;, &quot;values&quot; end)   "},{"title":"awaitStatus​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#awaitStatus","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:awaitStatus() → ( Status,-- The Status representing the fate of the Promise ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.  "},{"title":"await​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:await() → ( boolean,-- true if the Promise successfully resolved ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with. caution If the Promise gets cancelled, this function will return false, which is indistinguishable from a rejection. If you need to differentiate, you should use [Promise.awaitStatus] instead. local worked, value = getTheValue():await() if worked then print(&quot;got&quot;, value) else warn(&quot;it failed&quot;) end   "},{"title":"expect​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#expect","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:expect() → ...any-- The values the Promise resolved with. Yields the current thread until the given Promise completes. Returns the values that the promise resolved with. local worked = pcall(function() print(&quot;got&quot;, getTheValue():expect()) end) if not worked then warn(&quot;it failed&quot;) end This is essentially sugar for: select(2, assert(promise:await())) Errors if the Promise rejects or gets cancelled. "},{"title":"Errors","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise##","content":"Type\tDescriptionany\tErrors with the rejection value if this Promise rejects or gets cancelled.  "},{"title":"now​","type":1,"pageTitle":"Promise","url":"/ModulesOnRails/api/Promise#now","content":"&lt;/&gt; Promise:now( rejectionValue?: any-- The value to reject with if the Promise isn't resolved ) → Promise Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling :now(). This can be used to ensure your andThen handler occurs on the same frame as the root Promise execution. doSomething() :now() :andThen(function(value) print(&quot;Got&quot;, value, &quot;synchronously.&quot;) end) If this Promise is still running, Rejected, or Cancelled, the Promise returned from :now() will reject with the rejectionValue if passed, otherwise with a Promise.Error(Promise.Error.Kind.NotResolvedInTime). This can be checked with [Error.isKind]. "},{"title":"TableManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#types","content":" "},{"title":"CanBeArray<T>​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#CanBeArray<T>","content":"&lt;/&gt; type CanBeArray&lt;T&gt; = T | {T} A type that could be an individual of the type or an array of the type.  "},{"title":"Path​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Path","content":"&lt;/&gt; type Path = string | {any} A path to a value in a table. Can be written as a string in dot format or an array of strings. :::Note The array format is faster to parse and should be used when possible. ::: local tbl = { MyPath = { To = { Value = 0; }; }; } local path1: Path = &quot;MyPath.To.Value&quot; -- Style 1 local path2: Path = {&quot;MyPath&quot;, &quot;To&quot;, &quot;Value&quot;} -- Style 2   "},{"title":"ValueListenerFn​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ValueListenerFn","content":"&lt;/&gt; type ValueListenerFn = ( newValue: any, oldValue: any?, changeMetadata: ChangeMetadata? ) → ()   "},{"title":"ListenerType​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenerType","content":"&lt;/&gt; type ListenerType = &quot;ValueChanged&quot; | &quot;ArraySet&quot; | &quot;ArrayInsert&quot; | &quot;ArrayRemove&quot; This information is mostly for internal use.  "},{"title":"DataChangeSource​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#DataChangeSource","content":"&lt;/&gt; type DataChangeSource = &quot;self&quot; | &quot;child&quot; | &quot;parent&quot; This information is mostly for internal use.  "},{"title":"ChangeMetadata​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ChangeMetadata","content":"&lt;/&gt; interface ChangeMetadata { ListenerType: ListenerType-- The listener type that was fired. SourceDirection: DataChangeSource-- The source direction of the change. SourcePath: {string}-- The origin path of the change. NewValue: any?-- [Only for value changes] The new value. OldValue: any?-- [Only for value changes] The old value. } Metadata about the change that fired a listener. Used to provide more context to listeners. Allows you to figure out where the change came from, if it wasnt a direct change. "},{"title":"Properties​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Enums","content":"&lt;/&gt; TableManager.Enums: { ListenerType: ListenerTypeEnum, DataChangeSource: DataChangeSourceEnum } A collection of enums used by the TableManager. "},{"title":"Functions​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#new","content":"Constructor &lt;/&gt; TableManager.new(data: table?) → TableManager Creates a new TableManager. Takes a table to manage, if one is not given then it will construct an empty table. Modifying the given table Once you give a table to a TableManager, you should never modify it directly. Doing so can result in the TableManager being unable to properly track changes and potentially cause data desyncs. Key/Value Rules The given table's keys should follow these rules: No Mixed Tables (Tables containing keys of different datatypes) Avoid using tables as keys. Keys must not contain periods. Keys must not be empty strings. Tables/Arrays should be assigned to only one key. (No shared references as this can cause desyncs) Nested tables/arrays should not be given to other TableManager instances. (Can cause desyncs) info Only one TableManager should be created for a given table. Attempting to create a TableManager for a table that is already being managed will return the existing TableManager. Call metamethod You can call the TableManager class to create a new instance of it. TableManager() is equivalent to TableManager.new(). local manager = TableManager { Coins = 0; Title = &quot;Knight&quot;; }   "},{"title":"Destroy​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Destroy","content":"&lt;/&gt; TableManager:Destroy() → () Disconnects any listeners and removes the table from the managed tables.  "},{"title":"Get​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Get","content":"&lt;/&gt; TableManager:Get( path: Path, idx: (number | string)? ) → any Fetches the value at the given path. Accepts a string path or an array path. Accepts an optional secondary argument to fetch a value at an index in an array. Aliases: GetValue local manager = TableManager.new({ Currency = { Coins = 100; Gems = 10; }; }) -- The following are all equivalent acceptable methods of fetching the value. print(manager:Get(&quot;Currency.Coins&quot;)) -- 100 print(manager:Get({&quot;Currency&quot;, &quot;Coins&quot;})) -- 100 print(manager:Get().Currency.Coins) -- 100 Getting the Root Table Calling :Get() with no arguments, an empty string, or an empty table will return the root table.  "},{"title":"Set​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Set","content":"&lt;/&gt; TableManager:Set( path: Path, ...: any ) → () Sets the value at the given path to the given value. :Set acts as a combined function for :SetValue and :ArraySet. :Set(myPathToValue, newValue) :Set(myPathToArray, index, newValue) Overwriting the root table Overwriting the root table is not recommended, but is technically possible by giving an empty table or string as a Path. Doing so has not been tested in depth and may result in unintended behavior. Setting array values You cannot set values to nil in an array with this method due to the way it parses args. Use ArraySet instead if you need to set values to nil.  "},{"title":"Increment​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Increment","content":"&lt;/&gt; TableManager:Increment( path: Path, ...: any ) → number? Increments the value at the given path by the given amount. If the value is not a number, it will throw an error. :Increment acts as a combined function for :IncrementValue and :ArrayIncrement. :Increment(myPathToValue, amountToIncrementBy) :Increment(myPathToArray, index, amountToIncrementBy)   "},{"title":"Update​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Update","content":"&lt;/&gt; TableManager:Update( path: Path, ...: any ) → any? Mutates the value at the given path by calling the given function with the current value. :Update(myPathToValue, function(currentValue) return currentValue + 1 end) Aliases :Mutate is an alias for :Update. This alias is consistent with all other 'Update' methods.  "},{"title":"SetValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetValue","content":"&lt;/&gt; TableManager:SetValue( path: Path, value: any ) → boolean Sets the value at the given path to the given value. This will fire the ValueChanged signal if the value is different. Returns a boolean indicating whether or not the value was changed. local didChange = manager:SetValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"IncrementValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#IncrementValue","content":"&lt;/&gt; TableManager:IncrementValue( path: Path, amount: Numeric ) → number Increments the value at the given path by the given amount. If the value at the path or the given amount is not a number, it will throw an error. Returns the newly incremeneted value. local newValue = manager:IncrementValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"UpdateValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#UpdateValue","content":"&lt;/&gt; TableManager:UpdateValue( path: Path, fn: (currentValue: any) → (any) ) → any Mutates the value at the given path by calling the given function with the current value. The function should return the new value. manager:SetValue(&quot;MyPath.To.Value&quot;, &quot;Hello World&quot;) local newValue = manager:UpdateValue(&quot;MyPath.To.Value&quot;, function(currentValue) return string.upper(currentValue) .. &quot;!&quot; end) print(newValue) -- HELLO WORLD! print(manager:GetValue(&quot;MyPath.To.Value&quot;)) -- HELLO WORLD!   "},{"title":"SetManyValues​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetManyValues","content":"&lt;/&gt; TableManager:SetManyValues( path: Path, valueDict: {[any]: any} ) → () Sets the values at the given path to the given values. This will fire the ValueChanged listener for each value that is different. caution Uses pairs to check through the given table and thus Does not support setting values to nil. local manager = TableManager.new({ Foo = { Bar = { Value1 = 0; Value2 = 0; Value3 = 0; }; }; }) manager:SetManyValues(&quot;Foo.Bar&quot;, { Value1 = 100; Value3 = 300; })   "},{"title":"ArrayUpdate​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayUpdate","content":"&lt;/&gt; TableManager:ArrayUpdate( path: Path,-- The path to the array to mutate. index: number | {number} | &quot;#&quot;,-- The index or indices to mutate. If &quot;#&quot; is given, it will mutate all indices. fn: (currentValue: any) → (any)-- The function to call with the current value. Should return the new value. ) → () Mutates an index or indices in the array at the given path by calling the given function with the current value. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayUpdate(&quot;MyArray&quot;, 3, function(currentValue) return currentValue * 2 }) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 6, 4, 5}   "},{"title":"ArrayIncrement​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayIncrement","content":"&lt;/&gt; TableManager:ArrayIncrement( path: Path,-- The path to the array to increment. index: number | {number},-- The index or indices to increment. amount: number?-- The amount to increment by. If not given, it will increment by 1. ) → () Increments the indices at the given path by the given amount. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayIncrement(&quot;MyArray&quot;, 3, 10) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 13, 4, 5}   "},{"title":"ArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArraySet","content":"&lt;/&gt; TableManager:ArraySet( path: Path, index: (CanBeArray&lt;number&gt; | '#')?, value: any ) → () Sets the value at the given index in the array at the given path. The index can be a number or an array of numbers. If an array is given then the value will be set at each of those indices in the array.  "},{"title":"ArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayInsert","content":"&lt;/&gt; TableManager:ArrayInsert( path: Path, ...: any ) → () Inserts the given value into the array at the given path at the given index. If no index is given, it will insert at the end of the array. This follows the convention of table.insert where the index is given in the middle only if there are 3 args. x:ArrayInsert(&quot;MyArray&quot;, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at index 1 x:ArrayInsert(&quot;MyArray&quot;, 1) -- appends 1 to the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, 2) -- Inserts 2 at index 1   "},{"title":"ArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemove","content":"&lt;/&gt; TableManager:ArrayRemove( path: Path, index: number? ) → any Removes the value at the given index from the array at the given path. If no index is given, it will remove the last value in the array. Returns the value that was removed if one was.  "},{"title":"ArrayRemoveFirstValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemoveFirstValue","content":"&lt;/&gt; TableManager:ArrayRemoveFirstValue( path: Path, value: any ) → number? Removes the first instance of the given value from the array at the given path. Returns a number indicating the index that it was was removed from if one was.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ToFusionState","content":"&lt;/&gt; TableManager:ToFusionState(path: Path) → FusionState&lt;any&gt; Returns a Fusion State object that is bound to the value at the given path. This method is memoized so calling it repeatedly with the same path will return the same State object and quickly. local path = &quot;MyPath.To.Value&quot; manager:SetValue(path, 100) local state = manager:ToFusionState(path) print(peek(state)) -- 100 manager:SetValue(path, 200) task.wait() -- If your signals are deffered then the state will update on the next frame print(peek(state)) -- 200 Deffered Signals The value of the Fusion State object is updated via the ValueChanged listener and thus may be deffered if your signals are deffered. Setting Although this currently returns a Fusion Value object, it is not recommended to set the value as this may be a Computed in the future. Setting the state will not actually change the value in the TableManager. Version This method uses Fusion 0.3.0 internally so it may not work with older versions.  "},{"title":"PromiseValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#PromiseValue","content":"&lt;/&gt; TableManager:PromiseValue( path: Path, condition: (value: any?) → (boolean) ) → Promise Creates a promise that resolves when the given condition is met. The condition is immediately and every time the value changes. If no condition is given then it will resolve with the current value unless it is nil, in which case it will resolve on the first change.  "},{"title":"Observe​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Observe","content":"&lt;/&gt; TableManager:Observe( path: Path,-- The path to the value to observe. fn: ValueListenerFn,-- The function to call when the value changes. runOnNil: boolean?-- Whether or not to fire the function when the value is nil. ) → Connection-- A connection used to disconnect the listener. Observes a value at a path and calls the function immediately with the current value, as well as when it changes. Listening to nil values It will NOT fire if the new/starting value is nil, unless runOnNil is true. When it changes from nil, the oldValue will be the last known non nil value. The binding call of the function is an exception and will give nil as the oldValue. This is done so that Observe can be used to execute instructions when a value is percieved as 'ready'. local path = &quot;MyPath.To.Value&quot; local connection = manager:Observe(path, function(newValue) print(&quot;Value at&quot;, path, &quot;is&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"OnKeyChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyChange","content":"unreleased &lt;/&gt; TableManager:OnKeyChange( parentPath: Path?, fn: ( keyChanged: any, newValue: any, oldValue: any, changeMetadata: ChangeMetadata? ) → () ) → () Listens to a change at a specified path and calls the function when the value changes. keys with table values This method is not yet fully implemented and may not work as expected when listening to keys with table values or changing data from parent table. manager:Set(&quot;Stats&quot;, { Health = 100; Mana = 50; }) local connection = manager:OnKeyChange(&quot;Stats&quot;, function(key, newValue) print(`{key} changed to {newValue}`) end) manager:SetValue(&quot;Stats.Health&quot;, 200) -- Health changed to 200 manager:SetValue(&quot;Stats.Mana&quot;, 100) -- Mana changed to 100   "},{"title":"OnKeyAdd​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyAdd","content":"unreleased &lt;/&gt; TableManager:OnKeyAdd( parentPath: Path?, fn: ( newKey: any, newValue: any ) → () ) → Connection Listens to when a new key is added (Changed from nil) to a table at a specified path and calls the function.  "},{"title":"OnKeyRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyRemove","content":"unreleased &lt;/&gt; TableManager:OnKeyRemove( parentPath: Path?, fn: ( removedKey: any, lastValue: any ) → () ) → Connection Listens to when a key is removed (Set to nil) from a table at a specified path and calls the function.  "},{"title":"OnValueChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnValueChange","content":"&lt;/&gt; TableManager:OnValueChange( path: Path, fn: ValueListenerFn ) → Connection Listens to a change at a specified path and calls the function when the value changes. This does NOT fire when the value is an array/dictionary and one of its children changes. local connection = manager:OnValueChange(&quot;MyPath.To.Value&quot;, function(newValue, oldValue) print(&quot;Value changed from&quot;, oldValue, &quot;to&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"OnArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArraySet","content":"&lt;/&gt; TableManager:OnArraySet( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when an index is set in an array at a specified path and calls the function. The function receives the index and the new value. caution The array listeners do not fire from changes to parent or child values.  "},{"title":"OnArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArrayInsert","content":"&lt;/&gt; TableManager:OnArrayInsert( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when a value is inserted into an array at a specified path and calls the function when the value changes.  "},{"title":"OnArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArrayRemove","content":"&lt;/&gt; TableManager:OnArrayRemove( path: Path, fn: ( oldIndex: number, oldValue: any ) → () ) → Connection Listens to when a value is removed from an array at a specified path and calls the function. "}]