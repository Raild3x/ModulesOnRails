"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2184],{74322:e=>{e.exports=JSON.parse('{"functions":[],"properties":[],"types":[],"name":"ExampleResourceTypeData","desc":"An Example ResourceTypeData file. This is used to define the general\\nbehavior of a droplet type.\\n\\n```lua\\nlocal GenericPart = Instance.new(\\"Part\\")\\nGenericPart.Name = \\"GenericPart\\"\\nGenericPart.Transparency = 1\\nGenericPart.Size = Vector3.one\\nGenericPart.Anchored = true\\nGenericPart.CanCollide = false\\nGenericPart.CanTouch = false\\nGenericPart.CanQuery = false\\nGenericPart.Massless = true\\n\\n\\n--------------------------------------------------------------------------------\\n    --// Data //--\\n--------------------------------------------------------------------------------\\n\\nreturn {\\n    \\n    Defaults = {\\n        Value = NumberRange.new(0.6, 1.4); -- The value you want the droplet to have. This can be anything.\\n        -- Metadata = {}; -- You typically shouldnt default metadata.\\n        \\n        Count = NumberRange.new(2, 5); -- Number of droplets to spawn\\n        LifeTime = NumberRange.new(50, 60); -- Time before the droplet dissapears\\n        EjectionDuration = 1; -- Time it takes to spew out all the droplets\\n        EjectionHorizontalVelocity = NumberRange.new(0, 25);\\n        EjectionVerticalVelocity = NumberRange.new(25, 50);\\n        CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector;\\n        \\n        Mass = 1; -- Mass of the droplet (Used in magnitization calculations)\\n        MaxForce = math.huge; -- Maximum steering force applied to the droplet when magnitized to a player\\n        MaxVelocity = 150; -- Maxiumum velocity of the droplet when magnitized to a player\\n        CollectionRadius = 1.5; -- Radius from center of player the droplet must be to be considered \'collected\'\\n        MagnetizationRadius = 12; -- Radius from player in which the droplet will start being attracted to the player\\n        MustSettleBeforeCollect = false; -- Whether the droplet must come to a complete stop before it can be collected\\n    };\\n\\n    --[[\\n        Called when a new droplet is created. Use this to setup your visuals and\\n        any variables you need to keep track of. All parts within this should be\\n        Anchored = false, CanCollide = false, and Massless = true.\\n        The return value of this function can be accessed via Droplet:GetSetupData()\\n    ]]\\n    SetupDroplet = function(droplet: Droplet)\\n        local Value = droplet:GetValue() :: number\\n\\n        local VisualModel = Instance.new(\\"Model\\")\\n        VisualModel.Name = \\"VisualModel\\"\\n\\n        local OuterPart = GenericPart:Clone()\\n        OuterPart.Name = \\"Outer\\"\\n        OuterPart.Material = Enum.Material.Glass\\n        OuterPart.Transparency = 0.5\\n        OuterPart.Color = Color3.fromRGB(16, 206, 16)\\n        OuterPart.Size = Vector3.one * Value\\n        OuterPart.Anchored = false\\n        OuterPart.Parent = VisualModel\\n        VisualModel.PrimaryPart = OuterPart\\n\\n        local NumGen = Random.new()\\n\\n        local InnerPart = OuterPart:Clone()\\n        InnerPart.Material = Enum.Material.Neon\\n        InnerPart.Name = \\"Inner\\"\\n        InnerPart.Color = Color3.fromRGB(219, 189, 18)\\n        InnerPart.Transparency = 0\\n        InnerPart.CastShadow = false\\n        InnerPart.Size *= 0.6 + NumGen:NextNumber(-0.1, 0.1)\\n        InnerPart.CFrame = OuterPart.CFrame + Vector3.new(\\n            NumGen:NextNumber(-0.1, 0.1),\\n            NumGen:NextNumber(-0.1, 0.1),\\n            NumGen:NextNumber(-0.1, 0.1)\\n        )\\n        InnerPart.Parent = VisualModel\\n\\n        local Weld = Instance.new(\\"WeldConstraint\\")\\n        Weld.Part0 = OuterPart\\n        Weld.Part1 = InnerPart\\n        Weld.Parent = VisualModel\\n\\n        droplet:AddTask(task.spawn(function()\\n            for i = 0.025, 1, 0.025 do\\n                VisualModel:ScaleTo(i)\\n                task.wait()\\n            end\\n            VisualModel:ScaleTo(1)\\n        end), nil, \\"GrowThread\\")\\n        \\n        droplet:Attach(VisualModel)  -- Important!\\n\\n        return {\\n            VisualModel = VisualModel;\\n            SpinDirection = if math.random() > 0.5 then 1 else -1;\\n        }\\n    end;\\n\\n    -- Ran when the droplet is within render range of the LocalPlayer\'s Camera\\n    OnRenderUpdate = function(droplet: Droplet, rendertimeElapsed: number)\\n        local SetupData = droplet:GetSetupData()\\n        local OffsetCFrame = CFrame.new()\\n\\n        do -- Bobbing\\n            local AMPLITUDE = 1 -- Studs of vertical movement (+- half of this)\\n            local FREQUENCY = 0.25 -- Cycles per second\\n        \\n            local Y = (AMPLITUDE * 0.5) * -math.cos((rendertimeElapsed*math.pi) * (FREQUENCY))\\n            OffsetCFrame *= CFrame.new(0, AMPLITUDE + Y, 0)\\n        end\\n\\n        do -- Rotating\\n            local TimeToMakeOneRotation = 4\\n            local RotationsPerSecond = 1/TimeToMakeOneRotation\\n            OffsetCFrame *= CFrame.Angles(0, (rendertimeElapsed*math.pi) * RotationsPerSecond * SetupData.SpinDirection , 0)\\n        end\\n\\n        return OffsetCFrame\\n    end;\\n\\n    OnDropletTimeout = function(droplet: Droplet)\\n        local VisualModel = droplet:GetSetupData().VisualModel\\n        droplet:RemoveTask(\\"GrowThread\\")\\n        for i = 1, 0.025, -0.025 do\\n            VisualModel:ScaleTo(i)\\n            task.wait()\\n        end\\n    end;\\n\\n    OnClientClaim = function(playerWhoClaimed: Player, droplet: Droplet)\\n        -- droplet:Collect(playerWhoClaimed)\\n    end;\\n\\n    --[[\\n        Called when the droplet hits the player and is considered collected.\\n        This is ran on the client only. It should be used for collection effects\\n        and other client side things.\\n    ]]\\n    OnClientCollect = function(playerWhoCollected: Player, droplet: Droplet)\\n        local Value = droplet:GetValue() :: number\\n\\n        local Part = GenericPart:Clone()\\n        Part.CFrame = droplet:GetPivot()\\n\\n        task.delay(2, function()\\n            Part:Destroy()\\n        end)\\n\\n        local CollectionSound = Instance.new(\\"Sound\\")\\n        CollectionSound.SoundId = \\"rbxassetid://402143943\\"\\n        CollectionSound.Volume = 0.25\\n        \\n        local PitchShift = Instance.new(\\"PitchShiftSoundEffect\\")\\n        PitchShift.Octave = 2 - Value/1.5\\n\\n        PitchShift.Parent = CollectionSound\\n        CollectionSound.Parent = Part\\n        Part.Parent = workspace\\n\\n        CollectionSound:Play()\\n    end;\\n\\n    --[[\\n        Called once the client informs the server that it has collected the droplet.\\n    ]]\\n    OnServerCollect = function(playerWhoCollected: Player, value: any, metadata: any)\\n        local ExpValue: number = value\\n\\n        local leaderstats = playerWhoCollected:FindFirstChild(\\"leaderstats\\")\\n        if not leaderstats then\\n            leaderstats = Instance.new(\\"Folder\\")\\n            leaderstats.Name = \\"leaderstats\\"\\n            leaderstats.Parent = playerWhoCollected\\n        end\\n\\n        local expStat = leaderstats:FindFirstChild(\\"Exp\\")\\n        if not expStat then\\n            expStat = Instance.new(\\"NumberValue\\")\\n            expStat.Name = \\"Exp\\"\\n            expStat.Parent = leaderstats\\n        end\\n\\n        expStat.Value += ExpValue\\n        -- Add the value to the player\'s \\"exp\\". This is just an example.\\n    end;\\n}\\n```","source":{"line":195,"path":"lib/dropletmanager/src/ExampleResourceTypeData.luau"}}')}}]);