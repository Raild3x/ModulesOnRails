"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3542],{28001:e=>{e.exports=JSON.parse('{"functions":[{"name":"isState","desc":"Checks if the arg is a Fusion StateObject.","params":[{"name":"arg","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":74,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"isValue","desc":"Checks if the arg is a Fusion Value.","params":[{"name":"arg","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":83,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"removeTask","desc":"Removes a task from a scope by its taskId.\\n\\n\\n```lua\\nlocal id = \\"Greeting\\"\\nlocal task = s:addTask(function() print(\\"Hello, World!\\") end, nil, id)\\n\\ns:removeTask(id) -- Hello, World!\\n```","params":[{"name":"scope","desc":"The scope to remove the task from","lua_type":"Scope<any>"},{"name":"taskId","desc":"The taskId of the task to remove","lua_type":"any"},{"name":"dontCleanup","desc":"Whether or not to run the cleanup function on the task","lua_type":"boolean?"}],"returns":[{"desc":"The task that was removed","lua_type":"Task?"}],"function_type":"static","source":{"line":200,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"addTask","desc":"Adds a task to a scope. If a taskId is provided, it will remove any existing task with that taskId.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal id = \\"Greeting\\"\\nlocal task = s:addTask(function() print(\\"Hello, World!\\") end, nil, id)\\n\\nFusion.doCleanup(s) -- Hello, World!\\n```","params":[{"name":"scope","desc":"The scope to add the task to","lua_type":"Scope<any>"},{"name":"tsk","desc":"The task to add","lua_type":"Task & T"},{"name":"methodName","desc":"The method to call when the task is removed","lua_type":"any?"},{"name":"taskId","desc":"The taskId of the task","lua_type":"any?"}],"returns":[{"desc":"The task that was added","lua_type":"Task"}],"function_type":"static","source":{"line":235,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"getTask","desc":"Gets a task from a scope by its taskId.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal id = \\"Greeting\\"\\nlocal task = s:addTask(function() print(\\"Hello, World!\\") end, nil, id)\\n\\nlocal foundTask = s:getTask(id)\\nfoundTask() -- Hello, World!\\n```","params":[{"name":"scope","desc":"The scope to search for the task","lua_type":"Scope<any>"},{"name":"taskId","desc":"The taskId of the task to find","lua_type":"any"}],"returns":[{"desc":"The task if found, nil otherwise","lua_type":"Task?"}],"function_type":"static","source":{"line":282,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"promiseState","desc":"Creates a promise that resolves when the given state changes. If a predicate is given then the promise will only resolve if the predicate returns true.\\nIf the third argument `canResolveImmediately` is true, the promise will will check the predicate immediately.\\n\\n```lua\\nlocal a = s:Value(10)\\n\\ns:promiseState(a):andThen(function(value)\\n\\tprint(\\"Value is now\\", value)\\nend)\\n\\na:set(20) -- \\"Value is now 20\\"\\na:set(30) -- Promise has already resolved so no print\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state","desc":"","lua_type":"State<T>"},{"name":"predicate","desc":"","lua_type":"((value: T) -> boolean)?"},{"name":"canResolveImmediately","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Promise\\r\\n"}],"function_type":"static","source":{"line":314,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"bindTo","desc":"Binds a scope to the lifecycle of an instance. When the instance is destroyed, the scope will be cleaned up.\\nAlso applies vice versa; when the scope is cleaned up, the instance will be destroyed.\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\ns:bindTo(s:New \\"Part\\" {\\n\\tAnchored = true;\\n})\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"obj","desc":"","lua_type":"Instance"}],"returns":[{"desc":"","lua_type":"Instance\\r\\n"}],"function_type":"static","source":{"line":355,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"ensureIsState","desc":"Ensures a passed data is a StateObject. If it is not, it will be converted to one.","params":[{"name":"scope","desc":"The scope in which to create the new state object","lua_type":"Scope<any>"},{"name":"data","desc":"The potential state object","lua_type":"UsedAs<T>?"},{"name":"defaultValue","desc":"The default value to use if the data is nil","lua_type":"T"},{"name":"datatype","desc":"The type or types of the data expected in the state","lua_type":"(string | { string })?"}],"returns":[{"desc":"The existing or newly created state object","lua_type":"StateObject<T>"}],"function_type":"static","source":{"line":384,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"ensureIsValue","desc":"Ensures a passed data is a Value. If it is not, it will be converted to one.","params":[{"name":"scope","desc":"The scope in which to create the new state object","lua_type":"Scope<any>"},{"name":"data","desc":"The potential state object","lua_type":"UsedAs<T>"},{"name":"defaultValue","desc":"The default value to use if the data is nil","lua_type":"T"},{"name":"datatype","desc":"The type or types of the data expected in the state","lua_type":"(string | { string })?"}],"returns":[{"desc":"The existing or newly created state object","lua_type":"Value<T>"}],"function_type":"static","source":{"line":431,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"formatAssetId","desc":"Takes an AssetId and formats it to a valid string.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal assetId = s:formatAssetId(\\"rbxefsefawsetid://1234567890\\")\\nprint( peek(assetId) ) -- \\"rbxassetid://1234567890\\"\\n```\\n```lua\\nlocal assetId = s:formatAssetId(1234567890)\\nprint( peek(assetId) ) -- \\"rbxassetid://1234567890\\"\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"id","desc":"The AssetId to ensure","lua_type":"UsedAs<string | number>"},{"name":"default","desc":"The default AssetId to use if the id is nil","lua_type":"(string | number)?"}],"returns":[{"desc":"The State<string> that is synced with the AssetId","lua_type":"CanBeState<string>"}],"function_type":"static","source":{"line":489,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"ratio","desc":"Generates a computed that calculates the ratio of two numbers as a State<number>.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal numerator = s:Value(100)\\nlocal denominator = s:Value(200)\\n\\nlocal ratio = s:ratio(numerator, denominator)\\nprint( peek(ratio) ) -- 0.5\\n```","params":[{"name":"scope","desc":"The scope to create the State in","lua_type":"Scope<any>"},{"name":"numerator","desc":"The numerator of the ratio","lua_type":"UsedAs<number>"},{"name":"denominator","desc":"The denominator of the ratio","lua_type":"UsedAs<number>"},{"name":"mutator","desc":"An optional State to scale by or a function to mutate the ratio","lua_type":"(UsedAs<T> | (ratio: number, use: Use) -> T)?\\r\\n"}],"returns":[{"desc":"The ratio (Potentially mutated)","lua_type":"State<T>"}],"function_type":"static","source":{"line":524,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"ratioUDim2","desc":"Wraps FusionUtil.ratio with a handler for UDim2s\\n\\n\\n```lua\\nlocal numerator = s:Value(100)\\nlocal denominator = s:Value(200)\\nlocal size = s:Value(UDim2.new(0.2, 100, 0.2, 100))\\nlocal sizeAdjusted = s:ratioUDim2(numerator, denominator, size)\\nprint( peek(sizeAdjusted) ) -- UDim2.new(0.1, 50, 0.1, 50)\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"numerator","desc":"The numerator of the ratio","lua_type":"UsedAs<number>"},{"name":"denominator","desc":"The denominator of the ratio","lua_type":"UsedAs<number>"},{"name":"v","desc":"The UDim2 to scale","lua_type":"UsedAs<UDim2>\\r\\n"}],"returns":[{"desc":"The scaled UDim2","lua_type":"State<UDim2>"}],"function_type":"static","source":{"line":565,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"screenRatio","desc":"This wraps FusionUtil.ratio with a handler for scaling states/functions with the Screen Height.\\n\\n\\n```lua\\nlocal paddingOffset = s:Value(10)\\n\\nlocal paddingAdjusted = s:screenRatio(paddingOffset)\\n```\\n```lua\\nlocal size = Value(UDim2.new(0, 100, 0, 100))\\n\\nlocal sizeAdjusted = s:screenRatio(size, FusionUtil.ratioUDim2)\\n```\\n```lua\\nlocal x = s:Value(10)\\nlocal y = s:Value(20)\\nlocal z = s:screenRatio(function(ratio, use)\\n\\treturn (use(x) + use(y)) * ratio\\nend)\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"mutator","desc":"An optional State to scale by or a function to mutate the ratio","lua_type":"(UsedAs<T> | (ratio: number, use: Use) -> T)?"},{"name":"ratioFn","desc":"An optional function to use for the ratio, defaults to FusionUtil.ratio, but could be given something like FusionUtil.ratioUDim2","lua_type":"any"}],"returns":[],"function_type":"static","realm":["Client"],"unreleased":true,"source":{"line":605,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"lerpNumber","desc":"Lerps between two number states. If no use function is given then it returns a state\\n\\n\\n```lua\\nlocal a = s:Value(10)\\nlocal b = s:Value(20)\\nlocal alpha = s:Value(0.5)\\nlocal z = s:lerpNumber(a, b, alpha)\\nprint( peek(z) ) -- 15\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"n1","desc":"The first number state","lua_type":"UsedAs<number>"},{"name":"n2","desc":"The second number state","lua_type":"UsedAs<number>"},{"name":"alpha","desc":"The alpha state","lua_type":"UsedAs<number>"},{"name":"_use","desc":"An optional function to use to get the values of the states","lua_type":"((any) -> (any))?"}],"returns":[{"desc":"The resultant lerped number state/value","lua_type":"UsedAs<number>"}],"function_type":"static","source":{"line":631,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"UDim","desc":"A method to simplify Computeds that return simple UDims. If neither the scale nor offset are states\\nthen it will just return a raw UDim.\\n\\n```lua\\nlocal scale = s:Value(10)\\nlocal udim = s:UDim(scale, 0)\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"scale","desc":"","lua_type":"UsedAs<number>"},{"name":"offset","desc":"","lua_type":"UsedAs<number>"}],"returns":[{"desc":"","lua_type":"UsedAs<UDim>\\r\\n"}],"function_type":"static","source":{"line":651,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"eq","desc":"A simple equality function that returns true if the two states are equal.\\n\\n\\n```lua\\nlocal a = s:Value(10)\\nlocal b = s:Value(10)\\nlocal c = s:eq(a, b)\\nprint( peek(c) ) -- true\\na:set(20)\\nprint( peek(c) ) -- false\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"stateToCheck1","desc":"The first potential state to check","lua_type":"UsedAs<any>"},{"name":"stateToCheck2","desc":"The second potential state to check","lua_type":"UsedAs<any>"}],"returns":[{"desc":"A state resolving to the equality of the two given arguments","lua_type":"State<boolean>"}],"function_type":"static","source":{"line":680,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"If","desc":"Checks if a given state is truthy. If it is, the state will resolve to \\nthe second arg, otherwise it will resolve to the third arg.\\n\\n\\n```lua\\nlocal a = s:Value(false)\\nlocal b = s:Value(20)\\nlocal c = s:If(a, b, 0)\\nprint( peek(c) ) -- 0\\na:set(true)\\nprint( peek(c) ) -- 20\\nb:set(30)\\nprint( peek(c) ) -- 30\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state","desc":"The state to check","lua_type":"UsedAs<any>"},{"name":"trueValue","desc":"The value to resolve to if the state is truthy","lua_type":"UsedAs<U>"},{"name":"falseValue","desc":"The value to resolve to if the state is falsey","lua_type":"UsedAs<V>"}],"returns":[{"desc":"","lua_type":"State<U | V>\\r\\n"}],"function_type":"static","source":{"line":712,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"Not","desc":"Flips the Truthiness of the given state.\\n\\n\\n```lua\\nlocal a = s:Value(false)\\nlocal b = s:Not(a)\\nprint( peek(b) ) -- true\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state","desc":"The state to flip","lua_type":"UsedAs<any>"}],"returns":[{"desc":"The flipped state","lua_type":"State<boolean>"}],"function_type":"static","source":{"line":733,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"Or","desc":"Runs an `or` operation on two states and returns the result.","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state1","desc":"","lua_type":"UsedAs<U>"},{"name":"state2","desc":"","lua_type":"UsedAs<V>"}],"returns":[{"desc":"","lua_type":"State<U | V>\\r\\n"}],"function_type":"static","source":{"line":744,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"And","desc":"Runs an `and` operation on two states and returns the result.","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state1","desc":"","lua_type":"UsedAs<U>"},{"name":"state2","desc":"","lua_type":"UsedAs<V>"}],"returns":[{"desc":"","lua_type":"State<U | V>\\r\\n"}],"function_type":"static","source":{"line":755,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"observeState","desc":"Calls the provided callback immediately with the initial state and then again anytime the state updates.","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"fusionState","desc":"The state object to observe","lua_type":"UsedAs<T>"},{"name":"callback","desc":"The callback to call when the fusionState is updated","lua_type":"(stateValue: T) -> ()"}],"returns":[{"desc":"A function that will disconnect the observer","lua_type":"() -> ()"}],"function_type":"static","source":{"line":771,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"copyState","desc":"Copies the state of a state object to a new state object. If the state object is updated, the new state object will be updated as well.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal a = s:Value(10)\\nlocal b, disconnect = s:copyState(a)\\n\\nprint( peek(b) ) -- 10\\na:set(20)\\nprint( peek(b) ) -- 20\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state","desc":"The state object to copy","lua_type":"UsedAs<T>"}],"returns":[{"desc":"The new state object copied from the original state object","lua_type":"State<T>"},{"desc":"A function to disconnect the syncronization of the two states","lua_type":"() -> ()"}],"function_type":"static","source":{"line":804,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"syncValues","desc":"Syncronizes a StateObject to a Value. The Value will be set to the StateObject\'s value any time it changes.\\nFunctions similarly to FusionUtil.copyState but requires you to give it the Value StateObject to update.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal a = s:Value(123)\\nlocal b = s:Value(0)\\nlocal disconnect = s:syncValues(a, b)\\n\\nprint( peek(b) ) -- 123\\na:set(456)\\nprint( peek(b) ) -- 456\\n\\ndisconnect()\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"stateToWatch","desc":"The state to watch for changes","lua_type":"State<any>"},{"name":"valueToSet","desc":"The value to set when the state changes","lua_type":"Value<any>"}],"returns":[{"desc":"A function that will disconnect the observer","lua_type":"() -> ()"}],"function_type":"static","source":{"line":838,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"clock","desc":"Creates a State that is updated on RenderStepped.\\nThe value of the State will contain a number representing the amount of time\\nthat the clock has spent running.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal clock = s:clock()\\n\\ns:New \\"Part\\" {\\n\\tPosition = s:Computed(function(use)\\n\\t\\tlocal t = use(clock)\\n\\t\\treturn Vector3.new(0, 5 + math.sin(t) * 5, 0)\\n\\tend)\\n}\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"paused","desc":"A State that can be used to pause the clock","lua_type":"State<boolean>?"}],"returns":[{"desc":"","lua_type":"Value<number>\\r\\n"}],"function_type":"static","source":{"line":868,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"mapValuesToStates","desc":":::caution Unreleased\\nThis method is not finalized for release and may change in the future. Lock your version if you utilize it.\\n:::\\n\\nConverts a state containing a dictionary into a similar dictionary where the values are states.\\nThis enables easier listening to changes in the dictionary values when using Fusion `For` objects.\\nIt can be used to prevent re-creating entire UI elements when all you actually need is to update\\nsome aspect of it.\\n\\n```lua\\nlocal map = s:Value({A = 1, B = 2, C = 3})\\nlocal mappedStates = s:mapValuesToStates(map)\\n\\ns:ForPairs(mappedStates, function(_, fs, key: string, value: State<number>)\\n\\treturn key, fs:New \\"TextLabel\\" {\\n\\t\\tName = key,\\n\\t\\tText = fs:Computed(function(use)\\n\\t\\t\\treturn \\"Current Value:\\" .. use(value)\\n\\t\\tend)\\n\\t}\\nend)\\n\\nFusionUtil.tableSet(map, \\"A\\", 10)\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"inputTable","desc":"","lua_type":"UsedAs<{[K]: VI?}>"},{"name":"_mutator","desc":"","lua_type":"UsedAs<(\\r\\n\\t\\t(use: Use, scope: Scope<any>, key: K, value: VI) -> (VO)\\r\\n\\t)>?\\r\\n"}],"returns":[{"desc":"","lua_type":"State<{[K]: State<VO>?}>\\r\\n"}],"function_type":"static","unreleased":true,"source":{"line":910,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arrayInsert","desc":"Inserts a value into a container state object.\\nFollows the structure of `table.insert` so giving an extra arg for the index will insert the value at that index.\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nFusionUtil.arrayInsert(myArr, 2, \\"X\\")\\nprint( peek(myArr) ) -- {\\"A\\", \\"X\\", \\"B\\", \\"C\\"}\\n\\nFusionUtil.arrayInsert(myArr, \\"Z\\")\\nprint( peek(myArr) ) -- {\\"A\\", \\"X\\", \\"B\\", \\"C\\", \\"Z\\"}\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"...","desc":"","lua_type":"(number, T) | T"}],"returns":[],"function_type":"static","source":{"line":1000,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arrayRemove","desc":"Removes a value from a container state object.\\n\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nlocal removedValue = FusionUtil.arrayRemove(myArr, 2)\\nprint( peek(myArr) ) -- {\\"A\\", \\"C\\"}\\nprint( removedValue ) -- \\"B\\"\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"index","desc":"The index of the value to remove","lua_type":"number?"},{"name":"swapRemove","desc":"Whether to swap the value with the last value before removing it. This is faster than a regular remove but does not maintain the order of the array.","lua_type":"boolean?"}],"returns":[{"desc":"The removed value if the index is valid","lua_type":"T?"}],"function_type":"static","source":{"line":1029,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arraySwapRemove","desc":"Swaps two values in a container state object.\\n\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nlocal removedValue = FusionUtil.arraySwapRemove(myArr, 1)\\nprint( peek(myArr) ) -- {\\"C\\", \\"B\\"}\\nprint( removedValue ) -- \\"A\\"\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"index","desc":"the index of the value to swap out","lua_type":"number"}],"returns":[{"desc":"The value that was swapped out","lua_type":"T"}],"function_type":"static","source":{"line":1062,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arrayRemoveFirstValue","desc":"Removes the first instance of a value from a container state object.\\n\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nlocal indexOfRemovedValue = FusionUtil.arrayRemoveFirstValue(myArr, \\"A\\")\\nprint( peek(myArr) ) -- {\\"B\\", \\"C\\"}\\nprint( indexOfRemovedValue ) -- 1\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"value","desc":"The value to remove","lua_type":"T"},{"name":"swapRemove","desc":"Whether to swap the value with the last value before removing it. This is faster than a regular remove but does not maintain the order of the array.","lua_type":"boolean?"}],"returns":[{"desc":"The index of the removed value if found","lua_type":"number?"}],"function_type":"static","source":{"line":1094,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arraySwapRemoveFirstValue","desc":"Removes the first instance of a value from a container state object via swap replacement.\\nFaster than normal removal but does not maintain order.\\n\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nFusionUtil.arraySwapRemoveFirstValue(myArr, \\"A\\")\\nprint( peek(myArr) ) -- {\\"C\\", \\"B\\"}\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"value","desc":"The value to remove","lua_type":"T"}],"returns":[{"desc":"The index of the removed value if found","lua_type":"number?"}],"function_type":"static","source":{"line":1121,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"tableSet","desc":"Sets the key in a table (State) to a given value and returns the previous value.\\n`tableSet` is a more general version of `arraySet`.\\n\\n\\n```lua\\nlocal myTable = s:Value({A = 1, B = 2, C = 3})\\n\\nFusionUtil.tableSet(myTable, \\"B\\", 10)\\nprint( peek(myTable) ) -- {A = 1, B = 10, C = 3}\\n```","params":[{"name":"tableState","desc":"The container state object","lua_type":"Value<{[K]: V}> | {[K]: V}"},{"name":"key","desc":"The index of the value to change","lua_type":"K"},{"name":"newValue","desc":"The new value to change index to","lua_type":"V"},{"name":"updateInsteadOfReplace","desc":"Whether to update the value at the index if it is a ValueState instead of overwriting it","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"V?\\r\\n"}],"function_type":"static","source":{"line":1143,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arraySet","desc":"Sets the index in an array (State) to a given value and returns the previous value.\\n`arraySet` is a more specific version of `tableSet` meant to be used only with array types.\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nFusionUtil.arraySet(myArr, 2, \\"X\\")\\nprint( peek(myArr) ) -- {\\"A\\", \\"X\\", \\"C\\"}\\n```","params":[{"name":"arrayState","desc":"The container state object","lua_type":"Value<{V}> | {V}"},{"name":"index","desc":"The index of the value to change","lua_type":"number"},{"name":"newValue","desc":"The new value to change index to","lua_type":"V"},{"name":"updateInsteadOfReplace","desc":"Whether to update the value at the index if it is a ValueState instead of overwriting it","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"V?\\r\\n"}],"function_type":"static","source":{"line":1183,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arraySetFirstValue","desc":"Sets the first instance of a value in a container state object.\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nFusionUtil.arraySetFirstValue(myArr, \\"B\\", \\"X\\")\\nprint( peek(myArr) ) -- {\\"A\\", \\"X\\", \\"C\\"}\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"valueToFind","desc":"The value to find","lua_type":"T"},{"name":"valueToReplaceWith","desc":"The value to replace the found value with","lua_type":"T"},{"name":"updateInsteadOfReplace","desc":"Whether to update the value at the index if it is a ValueState instead of overwriting it","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"T?\\r\\n"}],"function_type":"static","source":{"line":1225,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"isState","desc":"Checks if the arg is a Fusion StateObject.","params":[{"name":"arg","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":74,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"isValue","desc":"Checks if the arg is a Fusion Value.","params":[{"name":"arg","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":83,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"removeTask","desc":"Removes a task from a scope by its taskId.\\n\\n\\n```lua\\nlocal id = \\"Greeting\\"\\nlocal task = s:addTask(function() print(\\"Hello, World!\\") end, nil, id)\\n\\ns:removeTask(id) -- Hello, World!\\n```","params":[{"name":"scope","desc":"The scope to remove the task from","lua_type":"Scope<any>"},{"name":"taskId","desc":"The taskId of the task to remove","lua_type":"any"},{"name":"dontCleanup","desc":"Whether or not to run the cleanup function on the task","lua_type":"boolean?"}],"returns":[{"desc":"The task that was removed","lua_type":"Task?"}],"function_type":"static","source":{"line":200,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"addTask","desc":"Adds a task to a scope. If a taskId is provided, it will remove any existing task with that taskId.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal id = \\"Greeting\\"\\nlocal task = s:addTask(function() print(\\"Hello, World!\\") end, nil, id)\\n\\nFusion.doCleanup(s) -- Hello, World!\\n```","params":[{"name":"scope","desc":"The scope to add the task to","lua_type":"Scope<any>"},{"name":"tsk","desc":"The task to add","lua_type":"Task & T"},{"name":"methodName","desc":"The method to call when the task is removed","lua_type":"any?"},{"name":"taskId","desc":"The taskId of the task","lua_type":"any?"}],"returns":[{"desc":"The task that was added","lua_type":"Task"}],"function_type":"static","source":{"line":235,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"getTask","desc":"Gets a task from a scope by its taskId.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal id = \\"Greeting\\"\\nlocal task = s:addTask(function() print(\\"Hello, World!\\") end, nil, id)\\n\\nlocal foundTask = s:getTask(id)\\nfoundTask() -- Hello, World!\\n```","params":[{"name":"scope","desc":"The scope to search for the task","lua_type":"Scope<any>"},{"name":"taskId","desc":"The taskId of the task to find","lua_type":"any"}],"returns":[{"desc":"The task if found, nil otherwise","lua_type":"Task?"}],"function_type":"static","source":{"line":282,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"promiseState","desc":"Creates a promise that resolves when the given state changes. If a predicate is given then the promise will only resolve if the predicate returns true.\\nIf the third argument `canResolveImmediately` is true, the promise will will check the predicate immediately.\\n\\n```lua\\nlocal a = s:Value(10)\\n\\ns:promiseState(a):andThen(function(value)\\n\\tprint(\\"Value is now\\", value)\\nend)\\n\\na:set(20) -- \\"Value is now 20\\"\\na:set(30) -- Promise has already resolved so no print\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state","desc":"","lua_type":"State<T>"},{"name":"predicate","desc":"","lua_type":"((value: T) -> boolean)?"},{"name":"canResolveImmediately","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Promise\\r\\n"}],"function_type":"static","source":{"line":314,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"bindTo","desc":"Binds a scope to the lifecycle of an instance. When the instance is destroyed, the scope will be cleaned up.\\nAlso applies vice versa; when the scope is cleaned up, the instance will be destroyed.\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\ns:bindTo(s:New \\"Part\\" {\\n\\tAnchored = true;\\n})\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"obj","desc":"","lua_type":"Instance"}],"returns":[{"desc":"","lua_type":"Instance\\r\\n"}],"function_type":"static","source":{"line":355,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"ensureIsState","desc":"Ensures a passed data is a StateObject. If it is not, it will be converted to one.","params":[{"name":"scope","desc":"The scope in which to create the new state object","lua_type":"Scope<any>"},{"name":"data","desc":"The potential state object","lua_type":"UsedAs<T>?"},{"name":"defaultValue","desc":"The default value to use if the data is nil","lua_type":"T"},{"name":"datatype","desc":"The type or types of the data expected in the state","lua_type":"(string | { string })?"}],"returns":[{"desc":"The existing or newly created state object","lua_type":"StateObject<T>"}],"function_type":"static","source":{"line":384,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"ensureIsValue","desc":"Ensures a passed data is a Value. If it is not, it will be converted to one.","params":[{"name":"scope","desc":"The scope in which to create the new state object","lua_type":"Scope<any>"},{"name":"data","desc":"The potential state object","lua_type":"UsedAs<T>"},{"name":"defaultValue","desc":"The default value to use if the data is nil","lua_type":"T"},{"name":"datatype","desc":"The type or types of the data expected in the state","lua_type":"(string | { string })?"}],"returns":[{"desc":"The existing or newly created state object","lua_type":"Value<T>"}],"function_type":"static","source":{"line":431,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"formatAssetId","desc":"Takes an AssetId and formats it to a valid string.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal assetId = s:formatAssetId(\\"rbxefsefawsetid://1234567890\\")\\nprint( peek(assetId) ) -- \\"rbxassetid://1234567890\\"\\n```\\n```lua\\nlocal assetId = s:formatAssetId(1234567890)\\nprint( peek(assetId) ) -- \\"rbxassetid://1234567890\\"\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"id","desc":"The AssetId to ensure","lua_type":"UsedAs<string | number>"},{"name":"default","desc":"The default AssetId to use if the id is nil","lua_type":"(string | number)?"}],"returns":[{"desc":"The State<string> that is synced with the AssetId","lua_type":"CanBeState<string>"}],"function_type":"static","source":{"line":489,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"ratio","desc":"Generates a computed that calculates the ratio of two numbers as a State<number>.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal numerator = s:Value(100)\\nlocal denominator = s:Value(200)\\n\\nlocal ratio = s:ratio(numerator, denominator)\\nprint( peek(ratio) ) -- 0.5\\n```","params":[{"name":"scope","desc":"The scope to create the State in","lua_type":"Scope<any>"},{"name":"numerator","desc":"The numerator of the ratio","lua_type":"UsedAs<number>"},{"name":"denominator","desc":"The denominator of the ratio","lua_type":"UsedAs<number>"},{"name":"mutator","desc":"An optional State to scale by or a function to mutate the ratio","lua_type":"(UsedAs<T> | (ratio: number, use: Use) -> T)?\\r\\n"}],"returns":[{"desc":"The ratio (Potentially mutated)","lua_type":"State<T>"}],"function_type":"static","source":{"line":524,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"ratioUDim2","desc":"Wraps FusionUtil.ratio with a handler for UDim2s\\n\\n\\n```lua\\nlocal numerator = s:Value(100)\\nlocal denominator = s:Value(200)\\nlocal size = s:Value(UDim2.new(0.2, 100, 0.2, 100))\\nlocal sizeAdjusted = s:ratioUDim2(numerator, denominator, size)\\nprint( peek(sizeAdjusted) ) -- UDim2.new(0.1, 50, 0.1, 50)\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"numerator","desc":"The numerator of the ratio","lua_type":"UsedAs<number>"},{"name":"denominator","desc":"The denominator of the ratio","lua_type":"UsedAs<number>"},{"name":"v","desc":"The UDim2 to scale","lua_type":"UsedAs<UDim2>\\r\\n"}],"returns":[{"desc":"The scaled UDim2","lua_type":"State<UDim2>"}],"function_type":"static","source":{"line":565,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"screenRatio","desc":"This wraps FusionUtil.ratio with a handler for scaling states/functions with the Screen Height.\\n\\n\\n```lua\\nlocal paddingOffset = s:Value(10)\\n\\nlocal paddingAdjusted = s:screenRatio(paddingOffset)\\n```\\n```lua\\nlocal size = Value(UDim2.new(0, 100, 0, 100))\\n\\nlocal sizeAdjusted = s:screenRatio(size, FusionUtil.ratioUDim2)\\n```\\n```lua\\nlocal x = s:Value(10)\\nlocal y = s:Value(20)\\nlocal z = s:screenRatio(function(ratio, use)\\n\\treturn (use(x) + use(y)) * ratio\\nend)\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"mutator","desc":"An optional State to scale by or a function to mutate the ratio","lua_type":"(UsedAs<T> | (ratio: number, use: Use) -> T)?"},{"name":"ratioFn","desc":"An optional function to use for the ratio, defaults to FusionUtil.ratio, but could be given something like FusionUtil.ratioUDim2","lua_type":"any"}],"returns":[],"function_type":"static","realm":["Client"],"unreleased":true,"source":{"line":605,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"lerpNumber","desc":"Lerps between two number states. If no use function is given then it returns a state\\n\\n\\n```lua\\nlocal a = s:Value(10)\\nlocal b = s:Value(20)\\nlocal alpha = s:Value(0.5)\\nlocal z = s:lerpNumber(a, b, alpha)\\nprint( peek(z) ) -- 15\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"n1","desc":"The first number state","lua_type":"UsedAs<number>"},{"name":"n2","desc":"The second number state","lua_type":"UsedAs<number>"},{"name":"alpha","desc":"The alpha state","lua_type":"UsedAs<number>"},{"name":"_use","desc":"An optional function to use to get the values of the states","lua_type":"((any) -> (any))?"}],"returns":[{"desc":"The resultant lerped number state/value","lua_type":"UsedAs<number>"}],"function_type":"static","source":{"line":631,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"UDim","desc":"A method to simplify Computeds that return simple UDims. If neither the scale nor offset are states\\nthen it will just return a raw UDim.\\n\\n```lua\\nlocal scale = s:Value(10)\\nlocal udim = s:UDim(scale, 0)\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"scale","desc":"","lua_type":"UsedAs<number>"},{"name":"offset","desc":"","lua_type":"UsedAs<number>"}],"returns":[{"desc":"","lua_type":"UsedAs<UDim>\\r\\n"}],"function_type":"static","source":{"line":651,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"eq","desc":"A simple equality function that returns true if the two states are equal.\\n\\n\\n```lua\\nlocal a = s:Value(10)\\nlocal b = s:Value(10)\\nlocal c = s:eq(a, b)\\nprint( peek(c) ) -- true\\na:set(20)\\nprint( peek(c) ) -- false\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"stateToCheck1","desc":"The first potential state to check","lua_type":"UsedAs<any>"},{"name":"stateToCheck2","desc":"The second potential state to check","lua_type":"UsedAs<any>"}],"returns":[{"desc":"A state resolving to the equality of the two given arguments","lua_type":"State<boolean>"}],"function_type":"static","source":{"line":680,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"If","desc":"Checks if a given state is truthy. If it is, the state will resolve to \\nthe second arg, otherwise it will resolve to the third arg.\\n\\n\\n```lua\\nlocal a = s:Value(false)\\nlocal b = s:Value(20)\\nlocal c = s:If(a, b, 0)\\nprint( peek(c) ) -- 0\\na:set(true)\\nprint( peek(c) ) -- 20\\nb:set(30)\\nprint( peek(c) ) -- 30\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state","desc":"The state to check","lua_type":"UsedAs<any>"},{"name":"trueValue","desc":"The value to resolve to if the state is truthy","lua_type":"UsedAs<U>"},{"name":"falseValue","desc":"The value to resolve to if the state is falsey","lua_type":"UsedAs<V>"}],"returns":[{"desc":"","lua_type":"State<U | V>\\r\\n"}],"function_type":"static","source":{"line":712,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"Not","desc":"Flips the Truthiness of the given state.\\n\\n\\n```lua\\nlocal a = s:Value(false)\\nlocal b = s:Not(a)\\nprint( peek(b) ) -- true\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state","desc":"The state to flip","lua_type":"UsedAs<any>"}],"returns":[{"desc":"The flipped state","lua_type":"State<boolean>"}],"function_type":"static","source":{"line":733,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"Or","desc":"Runs an `or` operation on two states and returns the result.","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state1","desc":"","lua_type":"UsedAs<U>"},{"name":"state2","desc":"","lua_type":"UsedAs<V>"}],"returns":[{"desc":"","lua_type":"State<U | V>\\r\\n"}],"function_type":"static","source":{"line":744,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"And","desc":"Runs an `and` operation on two states and returns the result.","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state1","desc":"","lua_type":"UsedAs<U>"},{"name":"state2","desc":"","lua_type":"UsedAs<V>"}],"returns":[{"desc":"","lua_type":"State<U | V>\\r\\n"}],"function_type":"static","source":{"line":755,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"observeState","desc":"Calls the provided callback immediately with the initial state and then again anytime the state updates.","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"fusionState","desc":"The state object to observe","lua_type":"UsedAs<T>"},{"name":"callback","desc":"The callback to call when the fusionState is updated","lua_type":"(stateValue: T) -> ()"}],"returns":[{"desc":"A function that will disconnect the observer","lua_type":"() -> ()"}],"function_type":"static","source":{"line":771,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"copyState","desc":"Copies the state of a state object to a new state object. If the state object is updated, the new state object will be updated as well.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal a = s:Value(10)\\nlocal b, disconnect = s:copyState(a)\\n\\nprint( peek(b) ) -- 10\\na:set(20)\\nprint( peek(b) ) -- 20\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"state","desc":"The state object to copy","lua_type":"UsedAs<T>"}],"returns":[{"desc":"The new state object copied from the original state object","lua_type":"State<T>"},{"desc":"A function to disconnect the syncronization of the two states","lua_type":"() -> ()"}],"function_type":"static","source":{"line":804,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"syncValues","desc":"Syncronizes a StateObject to a Value. The Value will be set to the StateObject\'s value any time it changes.\\nFunctions similarly to FusionUtil.copyState but requires you to give it the Value StateObject to update.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal a = s:Value(123)\\nlocal b = s:Value(0)\\nlocal disconnect = s:syncValues(a, b)\\n\\nprint( peek(b) ) -- 123\\na:set(456)\\nprint( peek(b) ) -- 456\\n\\ndisconnect()\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"stateToWatch","desc":"The state to watch for changes","lua_type":"State<any>"},{"name":"valueToSet","desc":"The value to set when the state changes","lua_type":"Value<any>"}],"returns":[{"desc":"A function that will disconnect the observer","lua_type":"() -> ()"}],"function_type":"static","source":{"line":838,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"clock","desc":"Creates a State that is updated on RenderStepped.\\nThe value of the State will contain a number representing the amount of time\\nthat the clock has spent running.\\n\\n\\n```lua\\nlocal s = RailUtil.Fusion.scoped()\\n\\nlocal clock = s:clock()\\n\\ns:New \\"Part\\" {\\n\\tPosition = s:Computed(function(use)\\n\\t\\tlocal t = use(clock)\\n\\t\\treturn Vector3.new(0, 5 + math.sin(t) * 5, 0)\\n\\tend)\\n}\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"paused","desc":"A State that can be used to pause the clock","lua_type":"State<boolean>?"}],"returns":[{"desc":"","lua_type":"Value<number>\\r\\n"}],"function_type":"static","source":{"line":868,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"mapValuesToStates","desc":":::caution Unreleased\\nThis method is not finalized for release and may change in the future. Lock your version if you utilize it.\\n:::\\n\\nConverts a state containing a dictionary into a similar dictionary where the values are states.\\nThis enables easier listening to changes in the dictionary values when using Fusion `For` objects.\\nIt can be used to prevent re-creating entire UI elements when all you actually need is to update\\nsome aspect of it.\\n\\n```lua\\nlocal map = s:Value({A = 1, B = 2, C = 3})\\nlocal mappedStates = s:mapValuesToStates(map)\\n\\ns:ForPairs(mappedStates, function(_, fs, key: string, value: State<number>)\\n\\treturn key, fs:New \\"TextLabel\\" {\\n\\t\\tName = key,\\n\\t\\tText = fs:Computed(function(use)\\n\\t\\t\\treturn \\"Current Value:\\" .. use(value)\\n\\t\\tend)\\n\\t}\\nend)\\n\\nFusionUtil.tableSet(map, \\"A\\", 10)\\n```","params":[{"name":"scope","desc":"","lua_type":"Scope<any>"},{"name":"inputTable","desc":"","lua_type":"UsedAs<{[K]: VI?}>"},{"name":"_mutator","desc":"","lua_type":"UsedAs<(\\r\\n\\t\\t(use: Use, scope: Scope<any>, key: K, value: VI) -> (VO)\\r\\n\\t)>?\\r\\n"}],"returns":[{"desc":"","lua_type":"State<{[K]: State<VO>?}>\\r\\n"}],"function_type":"static","unreleased":true,"source":{"line":910,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arrayInsert","desc":"Inserts a value into a container state object.\\nFollows the structure of `table.insert` so giving an extra arg for the index will insert the value at that index.\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nFusionUtil.arrayInsert(myArr, 2, \\"X\\")\\nprint( peek(myArr) ) -- {\\"A\\", \\"X\\", \\"B\\", \\"C\\"}\\n\\nFusionUtil.arrayInsert(myArr, \\"Z\\")\\nprint( peek(myArr) ) -- {\\"A\\", \\"X\\", \\"B\\", \\"C\\", \\"Z\\"}\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"...","desc":"","lua_type":"(number, T) | T"}],"returns":[],"function_type":"static","source":{"line":1000,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arrayRemove","desc":"Removes a value from a container state object.\\n\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nlocal removedValue = FusionUtil.arrayRemove(myArr, 2)\\nprint( peek(myArr) ) -- {\\"A\\", \\"C\\"}\\nprint( removedValue ) -- \\"B\\"\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"index","desc":"The index of the value to remove","lua_type":"number?"},{"name":"swapRemove","desc":"Whether to swap the value with the last value before removing it. This is faster than a regular remove but does not maintain the order of the array.","lua_type":"boolean?"}],"returns":[{"desc":"The removed value if the index is valid","lua_type":"T?"}],"function_type":"static","source":{"line":1029,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arraySwapRemove","desc":"Swaps two values in a container state object.\\n\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nlocal removedValue = FusionUtil.arraySwapRemove(myArr, 1)\\nprint( peek(myArr) ) -- {\\"C\\", \\"B\\"}\\nprint( removedValue ) -- \\"A\\"\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"index","desc":"the index of the value to swap out","lua_type":"number"}],"returns":[{"desc":"The value that was swapped out","lua_type":"T"}],"function_type":"static","source":{"line":1062,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arrayRemoveFirstValue","desc":"Removes the first instance of a value from a container state object.\\n\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nlocal indexOfRemovedValue = FusionUtil.arrayRemoveFirstValue(myArr, \\"A\\")\\nprint( peek(myArr) ) -- {\\"B\\", \\"C\\"}\\nprint( indexOfRemovedValue ) -- 1\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"value","desc":"The value to remove","lua_type":"T"},{"name":"swapRemove","desc":"Whether to swap the value with the last value before removing it. This is faster than a regular remove but does not maintain the order of the array.","lua_type":"boolean?"}],"returns":[{"desc":"The index of the removed value if found","lua_type":"number?"}],"function_type":"static","source":{"line":1094,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arraySwapRemoveFirstValue","desc":"Removes the first instance of a value from a container state object via swap replacement.\\nFaster than normal removal but does not maintain order.\\n\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nFusionUtil.arraySwapRemoveFirstValue(myArr, \\"A\\")\\nprint( peek(myArr) ) -- {\\"C\\", \\"B\\"}\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"value","desc":"The value to remove","lua_type":"T"}],"returns":[{"desc":"The index of the removed value if found","lua_type":"number?"}],"function_type":"static","source":{"line":1121,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"tableSet","desc":"Sets the key in a table (State) to a given value and returns the previous value.\\n`tableSet` is a more general version of `arraySet`.\\n\\n\\n```lua\\nlocal myTable = s:Value({A = 1, B = 2, C = 3})\\n\\nFusionUtil.tableSet(myTable, \\"B\\", 10)\\nprint( peek(myTable) ) -- {A = 1, B = 10, C = 3}\\n```","params":[{"name":"tableState","desc":"The container state object","lua_type":"Value<{[K]: V}> | {[K]: V}"},{"name":"key","desc":"The index of the value to change","lua_type":"K"},{"name":"newValue","desc":"The new value to change index to","lua_type":"V"},{"name":"updateInsteadOfReplace","desc":"Whether to update the value at the index if it is a ValueState instead of overwriting it","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"V?\\r\\n"}],"function_type":"static","source":{"line":1143,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arraySet","desc":"Sets the index in an array (State) to a given value and returns the previous value.\\n`arraySet` is a more specific version of `tableSet` meant to be used only with array types.\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nFusionUtil.arraySet(myArr, 2, \\"X\\")\\nprint( peek(myArr) ) -- {\\"A\\", \\"X\\", \\"C\\"}\\n```","params":[{"name":"arrayState","desc":"The container state object","lua_type":"Value<{V}> | {V}"},{"name":"index","desc":"The index of the value to change","lua_type":"number"},{"name":"newValue","desc":"The new value to change index to","lua_type":"V"},{"name":"updateInsteadOfReplace","desc":"Whether to update the value at the index if it is a ValueState instead of overwriting it","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"V?\\r\\n"}],"function_type":"static","source":{"line":1183,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"arraySetFirstValue","desc":"Sets the first instance of a value in a container state object.\\n\\n\\n```lua\\nlocal myArr = s:Value({\\"A\\", \\"B\\", \\"C\\"})\\n\\nFusionUtil.arraySetFirstValue(myArr, \\"B\\", \\"X\\")\\nprint( peek(myArr) ) -- {\\"A\\", \\"X\\", \\"C\\"}\\n```","params":[{"name":"valueState","desc":"The container state object","lua_type":"Value<{T}>"},{"name":"valueToFind","desc":"The value to find","lua_type":"T"},{"name":"valueToReplaceWith","desc":"The value to replace the found value with","lua_type":"T"},{"name":"updateInsteadOfReplace","desc":"Whether to update the value at the index if it is a ValueState instead of overwriting it","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"T?\\r\\n"}],"function_type":"static","source":{"line":1225,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}}],"properties":[{"name":"scope","desc":"The global scope for FusionUtil.","lua_type":"Scope<FusionUtil>","source":{"line":91,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"scopeless","desc":"A table of convenience functions for creating Fusion objects.\\nThese functions do not require the use of a scope, they by default use the FusionUtil scope.\\nThese are meant to be used in places where you want to create persistent Fusion objects without needing to pass a scope.\\n\\n```lua\\nlocal Value = FusionUtil.scopeless.Value\\n\\nlocal a = Value(10)\\n```","lua_type":"table","source":{"line":108,"path":"lib/basecomponent/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"scope","desc":"The global scope for FusionUtil.","lua_type":"Scope<FusionUtil>","source":{"line":91,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}},{"name":"scopeless","desc":"A table of convenience functions for creating Fusion objects.\\nThese functions do not require the use of a scope, they by default use the FusionUtil scope.\\nThese are meant to be used in places where you want to create persistent Fusion objects without needing to pass a scope.\\n\\n```lua\\nlocal Value = FusionUtil.scopeless.Value\\n\\nlocal a = Value(10)\\n```","lua_type":"table","source":{"line":108,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}}],"types":[],"name":"[0.3.0] FusionUtil","desc":"A collection of utility functions for Fusion 0.3.0.\\n\\n:::warning Multithreading\\nDO NOT ACCESS THIS IN MULTIPLE VMs (Parallel Luau). Studio freaks out when\\nfusion is loaded in multiple VMs for some unknown reason.\\n:::\\n\\n:::tip\\nIf you see a variable `s` being used in the examples, you can assume it is a Fusion Scope equivalent to the following:\\n```lua\\nlocal s = RailUtil.Fusion:scoped()\\n```\\n:::","source":{"line":21,"path":"lib/tablereplicator/_Index/raild3x_railutil@1.15.0/railutil/FusionUtil/FusionUtil_v0_3_0.luau"}}')}}]);