"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4794],{10419:e=>{e.exports=JSON.parse('{"functions":[{"name":"min","desc":"Creates a min-heap where the smallest element is always on top.","params":[],"returns":[{"desc":"A min-heap instance.","lua_type":"Heap<T>"}],"function_type":"static","tags":["static"],"source":{"line":125,"path":"lib/heap/src/init.luau"}},{"name":"max","desc":"Creates a max-heap where the largest element is always on top.","params":[],"returns":[{"desc":"A max-heap instance.","lua_type":"Heap<T>"}],"function_type":"static","tags":["static"],"source":{"line":134,"path":"lib/heap/src/init.luau"}},{"name":"Peek","desc":"Returns the top value from the heap without removing it.","params":[],"returns":[{"desc":"","lua_type":"T?"},{"desc":"","lua_type":"number?"}],"function_type":"method","source":{"line":141,"path":"lib/heap/src/init.luau"}},{"name":"Push","desc":"Inserts a value into the heap.\\n\\n```lua\\nlocal minHeap = Heap.min()\\n\\nminHeap:Push(\\"A\\", 5)\\nminHeap:Push(\\"B\\", 2)\\nminHeap:Push(\\"C\\", 8)\\n\\nlocal minValue, minCost = minHeap:Peek()\\nprint(minValue, minCost) -- B 2\\n```\\n\\n:::caution Cost\\nIf no **cost** is given, the value itself is used as the cost.\\nEnsure that the given value is comparable with relational operators.\\n```lua\\nlocal minHeap = Heap.min()\\nminHeap:Push(5)\\nminHeap:Push(2)\\nminHeap:Push(8)\\n\\nlocal minValue, minCost = minHeap:Peek()\\nprint(minValue, minCost) -- 2 2\\n```\\n:::","params":[{"name":"value","desc":"","lua_type":"T"},{"name":"cost","desc":"","lua_type":"number?"}],"returns":[],"function_type":"method","source":{"line":175,"path":"lib/heap/src/init.luau"}},{"name":"Pop","desc":"Removes and returns the top value from the heap.","params":[],"returns":[{"desc":"","lua_type":"T?"},{"desc":"","lua_type":"number?"}],"function_type":"method","source":{"line":201,"path":"lib/heap/src/init.luau"}},{"name":"Size","desc":"Returns the number of elements in the heap.","params":[],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","source":{"line":232,"path":"lib/heap/src/init.luau"}},{"name":"Has","desc":"Returns true if the heap contains a specified value.","params":[{"name":"valueToCheckFor","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":239,"path":"lib/heap/src/init.luau"}},{"name":"GetCostFromValue","desc":"Returns the cost given to a value. If no value is found, nil is returned.\\n:::caution Repeated Values\\nIf you have multiple instances of the same value, this method will return the cost of the first instance found.\\nThere is no guarantee of which instance will be found first.\\n:::","params":[{"name":"valueToCheckCostOf","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"boolean?\\r\\n"}],"function_type":"method","source":{"line":255,"path":"lib/heap/src/init.luau"}},{"name":"CountOccurrences","desc":"Returns the number of occurrences of a value in the heap.","params":[{"name":"valueToCheckFor","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","source":{"line":267,"path":"lib/heap/src/init.luau"}},{"name":"RemoveFirstOccurrence","desc":"Removes the first occurrence of a given value from the heap.\\nHeaps are not optimized for removals, so this method should\\nbe used sparingly.","params":[{"name":"valueToRemove","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":282,"path":"lib/heap/src/init.luau"}},{"name":"RemoveAllOccurrences","desc":"Removes all occurrences of a value from the heap and returns the\\nnumber of occurrences removed. Heaps are not optimized for removals,\\nso this method should be used sparingly.","params":[{"name":"valueToRemove","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","source":{"line":311,"path":"lib/heap/src/init.luau"}},{"name":"ToTree","desc":"A utility method that converts the heap into a tree structure.\\nThis is useful for debugging and visualizing the heap.\\n\\n`type Branch<T> = {Value: T, Left: Branch<T>?, Right: Branch<T>?}`","params":[],"returns":[{"desc":"A tree representation of the heap.","lua_type":"Branch<T>?"}],"function_type":"method","source":{"line":343,"path":"lib/heap/src/init.luau"}},{"name":"_heapifyUp","desc":"Restores the heap order by moving a node up.\\n\\nThis is excessively large bc splitting the min/max heap comparators reduces\\nthe number of comparisons each loop. Its not a huge performance boost, but\\nit is a performance boost.","params":[{"name":"index","desc":"","lua_type":"number"}],"returns":[],"function_type":"method","private":true,"source":{"line":367,"path":"lib/heap/src/init.luau"}},{"name":"_heapifyDown","desc":"Restores the heap order by moving a node down.\\n\\nThis is excessively large bc splitting the min/max heap comparators reduces\\nthe number of comparisons each loop. Its not a huge performance boost, but\\nit is a performance boost.","params":[{"name":"index","desc":"","lua_type":"number"}],"returns":[],"function_type":"method","private":true,"source":{"line":404,"path":"lib/heap/src/init.luau"}},{"name":"__len","desc":"Metamethod for the len operator `#`.\\nReturns the number of elements in the heap.","params":[],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","private":true,"source":{"line":454,"path":"lib/heap/src/init.luau"}},{"name":"__tostring","desc":"Metamethod for tostring.\\nAttempts to return a string representation of the heap in a tree like display.","params":[],"returns":[{"desc":"","lua_type":"string\\r\\n"}],"function_type":"method","private":true,"source":{"line":463,"path":"lib/heap/src/init.luau"}}],"properties":[{"name":"ClassName","desc":"","lua_type":"\\"Heap\\"","tags":["static"],"source":{"line":108,"path":"lib/heap/src/init.luau"}}],"types":[],"name":"Heap","desc":"A generic [Heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) implementation for both min and max heaps. It is designed\\nfor allowing the association of a cost to a given value so that users are not restricted to just numbers.\\n\\nHeaps are an implementation of [Priority Queues](https://en.wikipedia.org/wiki/Priority_queue) that excel at tracking the smallest\\nor largest element in an array. They are commonly used in algorithms like Dijkstra\'s shortest path algorithm and Huffman coding.\\n\\n**Min Heap:**\\n```lua\\nlocal minHeap = Heap.min()\\nminHeap:Push(\\"A\\", 5)\\nminHeap:Push(\\"B\\", 2)\\nminHeap:Push(\\"C\\", 8)\\nminHeap:Push(\\"D\\", 4)\\n\\n-- look at the current lowest value\\nlocal minValue, minCost = minHeap:Peek()\\nprint(minValue, minCost) -- B 2\\n\\nassert(maxHeap:Peek() == maxHeap:Pop(), \\"Peek should equal Pop\\")\\n```\\n**Max Heap:**\\n```lua\\nlocal maxHeap = Heap.max()\\nminHeap:Push(\\"A\\", 5)\\nminHeap:Push(\\"B\\", 2)\\nminHeap:Push(\\"C\\", 8)\\nminHeap:Push(\\"D\\", 4)\\n\\nlocal poppedValue, costOfPoppedValue = maxHeap:Pop()\\nprint(poppedValue, costOfPoppedValue) -- C 8\\n\\n-- look at the new highest value\\nprint(maxHeap:Peek()) -- A 5\\n```\\n\\n:::info MetaMethods\\nSupports the following metamethods:\\n- `__tostring`: Returns a string representation of the heap in a tree like display.\\n- `__len`: Returns the number of elements in the heap. Equivalent to calling `:Size()`.\\n:::\\n:::info Exported Types\\nThis file exports a Heap type in the form of **`Heap<T>`** where **`T`** is the type of value stored in the heap.\\nUsually Luau can infer the type of **`T`** from your usage, but it may be useful to manually provide the type if\\nyou are using more complex datatypes.\\n```lua\\nlocal Heap = require(ReplicatedStorage.Heap)\\ntype Heap<T> = Heap.Heap<T>\\n\\nlocal myHeap: Heap<string> = Heap.min()\\nmyHeap:Push(\\"A\\", 5)\\n```\\n:::","source":{"line":57,"path":"lib/heap/src/init.luau"}}')}}]);