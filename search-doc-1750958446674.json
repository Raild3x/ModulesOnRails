[{"title":"PlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerDataManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#types","content":" "},{"title":"ServerPlayerDataManager​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#ServerPlayerDataManager","content":"&lt;/&gt; type ServerPlayerDataManager = ServerPlayerDataManager   "},{"title":"ClientPlayerDataManager​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#ClientPlayerDataManager","content":"&lt;/&gt; type ClientPlayerDataManager = ClientPlayerDataManager  "},{"title":"Properties​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#Server","content":"This item only works when running on the server. Server &lt;/&gt; PlayerDataManager.Server: ServerPlayerDataManager The ServerPlayerDataManager class.  "},{"title":"Client​","type":1,"pageTitle":"PlayerDataManager","url":"/ModulesOnRails/api/PlayerDataManager#Client","content":"This item only works when running on the client. Client &lt;/&gt; PlayerDataManager.Client: ClientPlayerDataManager The ClientPlayerDataManager class. "},{"title":"ClientTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientTableReplicator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#functions","content":" "},{"title":"fromTemplate​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#fromTemplate","content":"Static &lt;/&gt; ClientTableReplicator.fromTemplate() → () Creates a ReplicatedTableSingleton object from the given template configuration. See TableReplicatorSingleton.new for more information.  "},{"title":"onNew​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#onNew","content":"&lt;/&gt; ClientTableReplicator.onNew( classTokenName: string, fn: (replicator: ClientTableReplicator) → () ) → () → () Listens for a new ClientTableReplicator of the given ClassName. Listening after server data loaded If you call this method after the ClientTableReplicator has already requested and loaded the server data, then this listener may miss the creation of some replicators. It is recommended to call this method before calling .requestServerData() or use .forEach() instead.  "},{"title":"requestServerData​","type":1,"pageTitle":"ClientTableReplicator","url":"/ModulesOnRails/api/ClientTableReplicator#requestServerData","content":"&lt;/&gt; ClientTableReplicator.requestServerData() → Promise Requests all the existing replicators from the server. This should only be called once, calling it multiple times will return the same promise. All replicator listeners should be registered before calling this method. "},{"title":"NetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/NetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#properties","content":" "},{"title":"Client​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Client","content":"This item only works when running on the client. Client &lt;/&gt; NetWire.Client: ClientNetWire   "},{"title":"Server​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#Server","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.Server: ServerNetWire  "},{"title":"Functions​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#functions","content":" "},{"title":"createEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createEvent","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createEvent( inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyEvent = NetWire.createEvent() MyWire.MyEvent:Connect(function(plr: Player, msg: string) print(plr, &quot;said:&quot;, msg) end)   "},{"title":"createUnreliableEvent​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createUnreliableEvent","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createUnreliableEvent( inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteEvent Returns an EventMarker that is used to mark where a remoteSignal should be created. Calls ServerNetWire:RegisterEvent() when set to the index of a ServerNetWire. See ServerNetWire:RegisterEvent for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyEvent = NetWire.createUnreliableEvent() MyWire.MyEvent:FireAll(&quot;Hello, world!&quot;)   "},{"title":"createProperty​","type":1,"pageTitle":"NetWire","url":"/ModulesOnRails/api/NetWire#createProperty","content":"This item only works when running on the server. Server &lt;/&gt; NetWire.createProperty( initialValue: any?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → ServerRemoteProperty Returns an PropertyMarker that is used to mark where a remoteProperty should be created. Calls ServerNetWire:RegisterProperty() when set to the index of a ServerNetWire. See ServerNetWire:RegisterProperty for more information. local MyWire = NetWire.Server(&quot;MyWire&quot;) MyWire.MyProperty = NetWire.createProperty(0) print(MyWire.MyProperty:Get()) -- 0  "},{"title":"CmdrHandler","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrHandler","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#Server","content":"&lt;/&gt; CmdrHandler.Server: CmdrServer   "},{"title":"Client​","type":1,"pageTitle":"CmdrHandler","url":"/ModulesOnRails/api/CmdrHandler#Client","content":"&lt;/&gt; CmdrHandler.Client: CmdrClient  "},{"title":"ClientPlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientPlayerDataManager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#properties","content":" "},{"title":"DEFAULT_MANAGER_NAME​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#DEFAULT_MANAGER_NAME","content":"&lt;/&gt; ClientPlayerDataManager.DEFAULT_MANAGER_NAME: string The default internal manager name.  "},{"title":"PlayerDataReady​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#PlayerDataReady","content":"&lt;/&gt; ClientPlayerDataManager.PlayerDataReady: Signal&lt;Player &gt; A signal that fires when a Player's data is ready to be used. "},{"title":"Functions​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#new","content":"Constructor Static &lt;/&gt; ClientPlayerDataManager.new(config: { ProfileSchema: table, }) → ClientPlayerDataManager   "},{"title":"GetImmediate​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#GetImmediate","content":"&lt;/&gt; ClientPlayerDataManager:GetImmediate(managerName: string?) → TableReplicatorSingleton Gets the TableReplicatorSingleton for this manager so you can get immediate info from it if needed.  "},{"title":"GetManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#GetManager","content":"&lt;/&gt; ClientPlayerDataManager:GetManager(managerName: string?) → TableManager? Gets the TableManager associated with the given name. This method may return nil if the data has not replicated yet.  "},{"title":"PromiseManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#PromiseManager","content":"&lt;/&gt; ClientPlayerDataManager:PromiseManager(managerName: string?) → Promise Promises the TableManager associated with the given name. If it doesnt exist when called then it will wait for it to be replicated and then will resolve.  "},{"title":"RegisterManager​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#RegisterManager","content":"&lt;/&gt; ClientPlayerDataManager:RegisterManager(config: string | {Name: string;DefaultDataSchema: table;ConditionFn: ((replicator: TableReplicator) → boolean)?}) → TableReplicatorSingleton Registers a tableManager/TableReplicatorSingleton to be watched for on the client. Informal registration. Assumes data key in the profile template is the same as the given name. ClientPlayerDataManager:RegisterManager(&quot;Currency&quot;) Formal registration. Used for more complex/custom registering of managers. Equivalent to the above ClientPlayerDataManager:RegisterManager({ Name = &quot;Currency&quot;, DefaultDataSchema = profileTemplate[&quot;Currency&quot;], ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end, })   "},{"title":"Start​","type":1,"pageTitle":"ClientPlayerDataManager","url":"/ModulesOnRails/api/ClientPlayerDataManager#Start","content":"unreleased &lt;/&gt; ClientPlayerDataManager:Start() → () Marks the CPDM as started. This is not currently neccessary "},{"title":"ClientNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ClientNetWire","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ClientNetWire.ClassName: &quot;ClientNetWire&quot;  "},{"title":"Functions​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#functions","content":" "},{"title":"indexReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#indexReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.indexReady( wireOrName: ClientNetWire | string, idx: string-- The index to wait for existence of ) → Promise Returns a promise that resolves when the ClientNetWire is ready for use and the index exists. The resolved value is the value of the index.  "},{"title":"onReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#onReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.onReady(clientNetWire: ClientNetWire | string) → Promise Returns a promise that resolves when the ClientNetWire is ready for use.  "},{"title":"isReady​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#isReady","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.isReady(clientNetWire: ClientNetWire | string) → boolean Can be used to check if a clientNetWire is ready for use.  "},{"title":"destroy​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#destroy","content":"This item only works when running on the client. Client &lt;/&gt; ClientNetWire.destroy(clientNetWire: ClientNetWire) → () Destroys a ClientNetWire, removing it from the cache.  "},{"title":"new​","type":1,"pageTitle":"ClientNetWire","url":"/ModulesOnRails/api/ClientNetWire#new","content":"constructor static &lt;/&gt; ClientNetWire.new(nameSpace: string) → ClientNetWire Creates a new ClientNetWire. If a ClientNetWire with the same nameSpace already exists, it will be returned instead. "},{"title":"DropletServerManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletServerManager","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#new","content":"constructor &lt;/&gt; DropletServerManager.new() → DropletServerManager Creates a new DropletServerManager if one has not already been made, returns the existing one if one already exists.  "},{"title":"RegisterResourceType​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#RegisterResourceType","content":"&lt;/&gt; DropletServerManager:RegisterResourceType( resourceType: string, data: ResourceTypeData ) → () Registers a new resource type. Attempting to register a resource type with the same name as an existing one will error. local data = Import(&quot;ExampleResourceTypeData&quot;) -- This is an Example file included in the package you can check out. DropletServerManager:RegisterResourceType(&quot;Example&quot;, data)   "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#GetResourceTypeData","content":"&lt;/&gt; DropletServerManager:GetResourceTypeData(resourceType: string) → ResourceTypeData? Returns the resource type data for the given resource type.  "},{"title":"Spawn​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Spawn","content":"&lt;/&gt; DropletServerManager:Spawn( data: ResourceSpawnData-- The data used to spawn the droplet. ) → number-- The seed of the droplet request. Creates a new droplet request to create some defined number of droplets of a given ResourceType. The droplet request will be created on the server and replicated to the clients. A PlayerTargets array can be passed to specify which players the droplet request should be replicated to, if one isnt given it replicates to all connected players at the moment of the request. Caveats Some properties of the interface have special behaviors depending on their type. See 'ResourceSpawnData' for more info on important caveats and behavior. local Bounds = 35 local seed = DropletServerManager:Spawn({ ResourceType = &quot;Example&quot;; Value = NumberRange.new(0.6, 1.4); Count = NumberRange.new(2, 10); LifeTime = NumberRange.new(10, 20); SpawnLocation = Vector3.new( math.random(-Bounds,Bounds), 7, math.random(-Bounds,Bounds) ); CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector; })   "},{"title":"Claim​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Claim","content":"&lt;/&gt; DropletServerManager:Claim( collector: Player ,-- The player claiming the droplet. seed: number,-- The droplet request identifier. dropletNumber: number?-- The particular droplet number to claim. If nil, all remaining droplets will be claimed. ) → boolean-- Whether or not the claim was successful. Force claim a droplet(s) for a player.  "},{"title":"Collect​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#Collect","content":"&lt;/&gt; DropletServerManager:Collect( collector: Player ,-- The player collecting the resource. seed: number,-- The droplet request identifier. dropletNumber: number?-- The particular droplet number to collect. If nil, all droplets will be collected. ) → boolean-- Whether or not the collection was successful. Force collects a droplet(s) resource and returns whether or not the collection was successful.  "},{"title":"GetCollectionRadius​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#GetCollectionRadius","content":"&lt;/&gt; DropletServerManager:GetCollectionRadius(player: Player ) → number Gets the collection radius for the given player.  "},{"title":"SetCollectionRadius​","type":1,"pageTitle":"DropletServerManager","url":"/ModulesOnRails/api/DropletServerManager#SetCollectionRadius","content":"&lt;/&gt; DropletServerManager:SetCollectionRadius( player: Player , radius: number ) → () Sets the collection radius for the given player. "},{"title":"DropletClientManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletClientManager","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#new","content":"constructor &lt;/&gt; DropletClientManager.new() → DropletClientManager Creates a new DropletClientManager if one has not already been made, returns the existing one if one already exists.  "},{"title":"RegisterResourceType​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#RegisterResourceType","content":"&lt;/&gt; DropletClientManager:RegisterResourceType( resourceType: string, data: ResourceTypeData ) → () Registers a new resource type.  "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#GetResourceTypeData","content":"&lt;/&gt; DropletClientManager:GetResourceTypeData(resourceType: string) → ResourceTypeData? Returns the resource type data for the given resource type  "},{"title":"GetCollectionRadius​","type":1,"pageTitle":"DropletClientManager","url":"/ModulesOnRails/api/DropletClientManager#GetCollectionRadius","content":"&lt;/&gt; DropletClientManager:GetCollectionRadius() → number Gets the distance at which a droplet must be within to be collected by the LocalPlayer "},{"title":"DropletManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#types","content":" "},{"title":"Droplet​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Droplet","content":"&lt;/&gt; type Droplet = Droplet   "},{"title":"ResourceTypeData​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#ResourceTypeData","content":"&lt;/&gt; type ResourceTypeData = ResourceTypeData   "},{"title":"ResourceSpawnData​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#ResourceSpawnData","content":"&lt;/&gt; type ResourceSpawnData = ResourceSpawnData  "},{"title":"Properties​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Server","content":"This item only works when running on the server. Server &lt;/&gt; DropletManager.Server: DropletServerManager Accessing this will automatically create a new DropletServerManager if one does not exist.  "},{"title":"Client​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Client","content":"This item only works when running on the client. Client &lt;/&gt; DropletManager.Client: DropletClientManager Accessing this will automatically create a new DropletClientManager if one does not exist.  "},{"title":"Util​","type":1,"pageTitle":"DropletManager","url":"/ModulesOnRails/api/DropletManager#Util","content":"&lt;/&gt; DropletManager.Util: DropletUtil  "},{"title":"AdjustableTimer","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/AdjustableTimer","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#functions","content":" "},{"title":"new​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#new","content":"&lt;/&gt; AdjustableTimer.new(config: { TimeScale: number?, StartTime: number?, }?) → AdjustableTimer Creates a new AdjustableTimer instance. Takes an optional configuration table. TimeScale: The initial time scale for the timer. Defaults to 1. StartTime: The initial start time of the timer. Defaults to the current server time (via workspace:GetServerTimeNow()). local timer = AdjustableTimer.new() timer:Resume() -- Start the timer Starting the Timer Timers are initialized in a paused state by default. You need to call :Resume() to start the timer.  "},{"title":"Unserialize​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#Unserialize","content":"&lt;/&gt; AdjustableTimer.Unserialize(data: SerializedAdjustableTimer) → AdjustableTimer Unserializes a table into an AdjustableTimer instance. local timer = AdjustableTimer.Unserialize(serializedData)   "},{"title":"Serialize​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#Serialize","content":"&lt;/&gt; AdjustableTimer:Serialize() → SerializedAdjustableTimer Serializes the timer into a saveable/network-safe table. local serializedData = timer:Serialize()   "},{"title":"GetElapsedTime​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#GetElapsedTime","content":"&lt;/&gt; AdjustableTimer:GetElapsedTime() → number-- The elapsed time in seconds. Gets the elapsed time that the timer has been running unpaused. print(timer:GetElapsedTime())   "},{"title":"Pause​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#Pause","content":"&lt;/&gt; AdjustableTimer:Pause() → AdjustableTimer Pauses the timer. Returns the timer for chaining. timer:Pause()   "},{"title":"Resume​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#Resume","content":"&lt;/&gt; AdjustableTimer:Resume() → AdjustableTimer Resumes the timer. Returns the timer for chaining. timer:Resume()   "},{"title":"IsPaused​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#IsPaused","content":"&lt;/&gt; AdjustableTimer:IsPaused() → boolean Returns whether or not the timer is paused. print(timer:IsPaused())   "},{"title":"SetTimeScale​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#SetTimeScale","content":"&lt;/&gt; AdjustableTimer:SetTimeScale( newRate: number,-- The new rate at with time will progress. _newRateChangeTime: number? ) → () Changes how fast the timer progresses every unpaused second.2 means the timer will progress twice as fast, 0.5 means it will progress half as fast. timer:SetTimeScale(2)   "},{"title":"GetTimeScale​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#GetTimeScale","content":"&lt;/&gt; AdjustableTimer:GetTimeScale() → number-- The current progress rate. Gets the current time scale of the timer. Represents how fast the timer progresses every unpaused second.2 means the timer will progress twice as fast, 0.5 means it will progress half as fast.  "},{"title":"AddElapsedTime​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#AddElapsedTime","content":"&lt;/&gt; AdjustableTimer:AddElapsedTime( seconds: number,-- The number of seconds to add. useTimeScale: boolean?-- Whether to apply the current time scale to the given seconds (default is false). ) → () Adds progress to the timer in raw seconds. local time = AdjustableTimer.new():Resume() print(timer:GetElapsedTime()) -- 0 timer:AddElapsedTime(10) print(timer:GetElapsedTime()) -- 10 timer:SetTimeScale(2) timer:AddElapsedTime(5, true) print(timer:GetElapsedTime()) -- 20   "},{"title":"SetElapsedTime​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#SetElapsedTime","content":"&lt;/&gt; AdjustableTimer:SetElapsedTime( seconds: number-- The elapsed time to set. ) → () Sets the elapsed time of the timer in raw seconds. timer:SetElapsedTime(30)   "},{"title":"SetStartTime​","type":1,"pageTitle":"AdjustableTimer","url":"/ModulesOnRails/api/AdjustableTimer#SetStartTime","content":"&lt;/&gt; AdjustableTimer:SetStartTime(timestamp: number) → () Sets the time at which the timer started. This will affect the elapsed time calculation. The timestamp should be relative to workspace:GetServerTimeNow(). Does not account for time scale or paused state. timer:SetStartTime(workspace:GetServerTimeNow() - 60) -- Set start time to 60 seconds ago  "},{"title":"ObjectCache","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ObjectCache","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#functions","content":" "},{"title":"setupModelForCacheMovement​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#setupModelForCacheMovement","content":"&lt;/&gt; ObjectCache.setupModelForCacheMovement(model: Model ) → () Sets up a model for cache movement by welding all of its descendant BaseParts to its PrimaryPart.  "},{"title":"isModelSetupForCacheMovement​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#isModelSetupForCacheMovement","content":"&lt;/&gt; ObjectCache.isModelSetupForCacheMovement(model: Model ) → boolean Checks if a model is setup for cache movement.  "},{"title":"new​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#new","content":"&lt;/&gt; ObjectCache.new(config: CacheConfig) → () "},{"title":"Types","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache##","content":""},{"title":"​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#CacheConfig","content":"interface CacheConfig { Template: T | () → T-- The template object to use for the cache. Must be a PVInstance or a function that returns a PVInstance. InitialSize: number?-- The initial size of the cache. Defaults to 10. ExpansionSize: number?-- The amount to expand the cache by. Defaults to 50. ObjectsParent: Instance? -- The parent to put the objects in. CacheParent: Instance? -- The parent to put the cache in. Name: string?-- The name of the cache. }  Creates a new ObjectCache. local myCache: ObjectCache&lt;Part&gt; = ObjectCache.new({ Template = function() local part = Instance.new(&quot;Part&quot;) part.Anchored = true return part end, }) Anchored Parts Make sure that your template object is anchored. Otherwise when it returns to the cache it will fall out of existence. info Luau LSP type inference for the template is not yet robust enough to properly infer the type of the template object. As a result, you should properly assign the right type to your cache object.  "},{"title":"Get​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Get","content":"&lt;/&gt; ObjectCache:Get(moveTo: CFrame? ) → T Gets an object from the cache, moving it to the specified CFrame if provided. Moving the returned object If you provide a CFrame, the movement is deferred so it can be bulk moved. Keep this in mind if you need to do other operations on the object immediately after moving it.  "},{"title":"Return​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Return","content":"&lt;/&gt; ObjectCache:Return(obj: T) → () Returns an object to the cache.  "},{"title":"ExpandCache​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#ExpandCache","content":"&lt;/&gt; ObjectCache:ExpandCache( Amount: number-- The amount to expand the cache by. ) → () Expands the cache by the specified amount.  "},{"title":"SetExpandAmount​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#SetExpandAmount","content":"&lt;/&gt; ObjectCache:SetExpandAmount( Amount: number-- The amount to expand the cache by. ) → () Sets the default amount to expand the cache by.  "},{"title":"IsInUse​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#IsInUse","content":"&lt;/&gt; ObjectCache:IsInUse(obj: PVInstance ) → boolean Returns whether the specified object is currently in use.  "},{"title":"BelongsTo​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#BelongsTo","content":"&lt;/&gt; ObjectCache:BelongsTo(obj: PVInstance ) → boolean Checks if an object belongs to this cache.  "},{"title":"Update​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Update","content":"&lt;/&gt; ObjectCache:Update() → () Forces an immediate position update for all objects in the cache.  "},{"title":"Destroy​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#Destroy","content":"&lt;/&gt; ObjectCache:Destroy() → () Destroys the cache and all objects within it.  "},{"title":"ConnectOnReturn​","type":1,"pageTitle":"ObjectCache","url":"/ModulesOnRails/api/ObjectCache#ConnectOnReturn","content":"&lt;/&gt; ObjectCache:ConnectOnReturn( fn: (obj: T) → ()-- The function to run. ) → () → boolean-- A cleaner function to disconnect the connection. Sets a function to run when an object is returned to the cache. Passes the object that was returned as an argument. "},{"title":"CmdrTypes","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrTypes","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#types","content":" "},{"title":"ArgumentContext<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#ArgumentContext<T>","content":"&lt;/&gt; interface ArgumentContext&lt;T&gt; { Command: CommandContext&lt;T&gt;-- The command context this argument belongs to. Name: string-- The name of the argument Type: TypeDefinition&lt;T&gt;-- The type definition of the argument Required: boolean-- Whether or not this argument is required Executor: Player -- The player that ran the command this argument belongs to. RawValue: string-- The raw value of the argument RawSegments: {string}-- The raw segments of the argument Prefix: string-- The prefix of the argument }   "},{"title":"CommandContext<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandContext<T>","content":"&lt;/&gt; interface CommandContext&lt;T&gt; { Executor: Player -- The player who executed the command Name: string-- the name of the command Description: string-- the description of the command Alias: string-- The specific alias of this command that was used to trigger this command (may be the same as Name) Aliases: {string}-- The list of aliases that could have been used to trigger this command Group: any-- The group this command is a part of. Defined in command definitions, typically a string. RawText: string-- the raw text of the command RawArguments: {string}-- the raw arguments of the command Arguments: {ArgumentContext&lt;T&gt;}-- the parsed arguments of the command Cmdr: table Dispatcher: table-- the dispatcher that ran the command State: table-- A blank table that can be used to store user-defined information about this command's current execution. This could potentially be used with hooks to add information to this table which your command or other hooks could consume. }   "},{"title":"TypeDefinition<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#TypeDefinition<T>","content":"&lt;/&gt; interface TypeDefinition&lt;T&gt; { DisplayName: string-- The display name of the type Prefixes: string-- The prefixes that this type can use Transform: ( rawText: string, executor: Player ) → any-- A function that transforms the raw text into the desired type Validate: (value: T) → ( boolean, string? )-- A function that validates the value. Returns a boolean and an optional error message. ValidateOnce: (value: T) → ( boolean, string? )-- A function that validates the value once. Returns a boolean and an optional error message. Autocomplete: (value: T) → ( {string}, {IsPartial: boolean?} )-- A function that returns a list of possible completions for the value. Returns a list of strings and an optional boolean indicating if the completions are partial. Parse: (value: T) → any-- A function that parses the value Default: (plr: Player ) → string-- A function that returns the default value for the type Listable: boolean-- Whether or not this type is listable }   "},{"title":"CommandArgument​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandArgument","content":"&lt;/&gt; interface CommandArgument { Type: string | TypeDefinition&lt;any&gt;-- The type of the argument Name: string-- The name of the argument Description: string-- The description of the argument Optional: boolean-- Whether or not this argument is optional Default: any-- The default value of the argument }   "},{"title":"CommandDefinition<T>​","type":1,"pageTitle":"CmdrTypes","url":"/ModulesOnRails/api/CmdrTypes#CommandDefinition<T>","content":"&lt;/&gt; interface CommandDefinition&lt;T&gt; { Name: string-- The name of the command Description: string-- The description of the command Aliases: {string}?-- The aliases of the command Group: any?-- The group this command is a part of Args: {CommandArgument | (context: CommandContext&lt;T&gt;) → CommandArgument}-- The arguments of the command Data: (( context: CommandContext&lt;T&gt;, ...any ) → any)?-- The data of the command AutoExec: {string}?-- The autoexec of the command ClientRun: (( context: CommandContext&lt;T&gt;, ...any ) → string?)?-- The client run of the command }  "},{"title":"CmdrClient","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrClient","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#functions","content":" "},{"title":"PromiseCmdr​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#PromiseCmdr","content":"&lt;/&gt; CmdrClient:PromiseCmdr() → Promise Returns a promise that resolves with the Cmdr instance.https://eryn.io/Cmdr/api/CmdrClient.html return Promise  "},{"title":"HasPermission​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#HasPermission","content":"&lt;/&gt; CmdrClient:HasPermission( commandName: string-- The name of the command to check ) → boolean Checks if a player has permission to run a command  "},{"title":"ExecuteCommand​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#ExecuteCommand","content":"&lt;/&gt; CmdrClient:ExecuteCommand(...: string) → Promise&lt;string&gt; Executes a command CmdrService:ExecuteCommand(&quot;blink&quot;)   "},{"title":"GetPermissions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetPermissions","content":"&lt;/&gt; CmdrClient:GetPermissions() → {any} Gets the permissions for the local player Does not return permissions granted from groups  "},{"title":"GetGroupRankPermissions​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetGroupRankPermissions","content":"&lt;/&gt; CmdrClient:GetGroupRankPermissions( groupId: number,-- The Roblox group id to get permissions for rank: number-- The rank to get permissions for ) → {string}-- The permissions granted to the rank Gets the permissions granted to a particular rank in a group local permissions = CmdrService:GetGroupRankPermissions(15905255, 230)   "},{"title":"GetPermissionInheritance​","type":1,"pageTitle":"CmdrClient","url":"/ModulesOnRails/api/CmdrClient#GetPermissionInheritance","content":"&lt;/&gt; CmdrClient:GetPermissionInheritance(permissionGroup: string) → {string} Fetches the inherited permission group for a permission group "},{"title":"Droplet","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Droplet","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#types","content":" "},{"title":"Droplet​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Droplet","content":"&lt;/&gt; type Droplet = Droplet  "},{"title":"Functions​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#functions","content":" "},{"title":"GetValue​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetValue","content":"&lt;/&gt; Droplet:GetValue() → any   "},{"title":"GetMetadata​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetMetadata","content":"&lt;/&gt; Droplet:GetMetadata() → any?   "},{"title":"GetResourceTypeData​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetResourceTypeData","content":"&lt;/&gt; Droplet:GetResourceTypeData() → ResourceTypeData   "},{"title":"GetPosition​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetPosition","content":"&lt;/&gt; Droplet:GetPosition() → Vector3    "},{"title":"GetModel​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetModel","content":"&lt;/&gt; Droplet:GetModel() → Actor    "},{"title":"GetSetupData​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#GetSetupData","content":"&lt;/&gt; Droplet:GetSetupData() → any Returns the data that was returned by the ResourceTypeData.Setup function  "},{"title":"Identify​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Identify","content":"&lt;/&gt; Droplet:Identify() → ( number,-- The seed of the droplet number-- The id of the droplet ) Returns the seed and id of the droplet. Used for internal identification.  "},{"title":"IsTimingOut​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#IsTimingOut","content":"&lt;/&gt; Droplet:IsTimingOut() → boolean Returns whether or not the droplet is in the process of timing out.  "},{"title":"AttachModel​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#AttachModel","content":"&lt;/&gt; Droplet:AttachModel(object: Model | BasePart ) → () Attaches a Model or Part to the droplet. Use this to add your visuals to the droplet.  "},{"title":"Collect​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Collect","content":"&lt;/&gt; Droplet:Collect(playerWhoCollected: Player ) → ()   "},{"title":"Claim​","type":1,"pageTitle":"Droplet","url":"/ModulesOnRails/api/Droplet#Claim","content":"&lt;/&gt; Droplet:Claim(playerWhoClaimed: Player ) → ()  "},{"title":"ExampleResourceTypeData","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ExampleResourceTypeData","content":"On this page ExampleResourceTypeData An Example ResourceTypeData file. This is used to define the general behavior of a droplet type. local GenericPart = Instance.new(&quot;Part&quot;) GenericPart.Name = &quot;GenericPart&quot; GenericPart.Transparency = 1 GenericPart.Size = Vector3.one GenericPart.Anchored = true GenericPart.CanCollide = false GenericPart.CanTouch = false GenericPart.CanQuery = false GenericPart.Massless = true -------------------------------------------------------------------------------- --// Data //-- -------------------------------------------------------------------------------- return { Defaults = { Value = NumberRange.new(0.6, 1.4); -- The value you want the droplet to have. This can be anything. -- Metadata = {}; -- You typically shouldnt default metadata. Count = NumberRange.new(2, 5); -- Number of droplets to spawn LifeTime = NumberRange.new(50, 60); -- Time before the droplet dissapears EjectionDuration = 1; -- Time it takes to spew out all the droplets EjectionHorizontalVelocity = NumberRange.new(0, 25); EjectionVerticalVelocity = NumberRange.new(25, 50); CollectorMode = DropletUtil.Enums.CollectorMode.MultiCollector; Mass = 1; -- Mass of the droplet (Used in magnitization calculations) MaxForce = math.huge; -- Maximum steering force applied to the droplet when magnitized to a player MaxVelocity = 150; -- Maxiumum velocity of the droplet when magnitized to a player CollectionRadius = 1.5; -- Radius from center of player the droplet must be to be considered 'collected' }; --[[ Called when a new droplet is created. Use this to setup your visuals and any variables you need to keep track of. All parts within this should be Anchored = false, CanCollide = false, and Massless = true. The return value of this function can be accessed via Droplet:GetSetupData() ]] SetupDroplet = function(droplet: Droplet) local Value = droplet:GetValue() :: number local VisualModel = Instance.new(&quot;Model&quot;) VisualModel.Name = &quot;VisualModel&quot; local OuterPart = GenericPart:Clone() OuterPart.Name = &quot;Outer&quot; OuterPart.Material = Enum.Material.Glass OuterPart.Transparency = 0.5 OuterPart.Color = Color3.fromRGB(16, 206, 16) OuterPart.Size = Vector3.one * Value OuterPart.Anchored = false OuterPart.Parent = VisualModel VisualModel.PrimaryPart = OuterPart local NumGen = Random.new() local InnerPart = OuterPart:Clone() InnerPart.Material = Enum.Material.Neon InnerPart.Name = &quot;Inner&quot; InnerPart.Color = Color3.fromRGB(219, 189, 18) InnerPart.Transparency = 0 InnerPart.CastShadow = false InnerPart.Size *= 0.6 + NumGen:NextNumber(-0.1, 0.1) InnerPart.CFrame = OuterPart.CFrame + Vector3.new( NumGen:NextNumber(-0.1, 0.1), NumGen:NextNumber(-0.1, 0.1), NumGen:NextNumber(-0.1, 0.1) ) InnerPart.Parent = VisualModel local Weld = Instance.new(&quot;WeldConstraint&quot;) Weld.Part0 = OuterPart Weld.Part1 = InnerPart Weld.Parent = VisualModel droplet:AddTask(task.spawn(function() for i = 0.025, 1, 0.025 do VisualModel:ScaleTo(i) task.wait() end VisualModel:ScaleTo(1) end), nil, &quot;GrowThread&quot;) droplet:AttachModel(VisualModel) return { VisualModel = VisualModel; SpinDirection = if math.random() &gt; 0.5 then 1 else -1; } end; -- Ran when the droplet is within render range of the LocalPlayer's Camera OnRenderUpdate = function(droplet: Droplet, rendertimeElapsed: number) local SetupData = droplet:GetSetupData() local OffsetCFrame = CFrame.new() do -- Bobbing local AMPLITUDE = 1 -- Studs of vertical movement (+- half of this) local FREQUENCY = 0.25 -- Cycles per second local Y = (AMPLITUDE * 0.5) * -math.cos((rendertimeElapsed*math.pi) * (FREQUENCY)) OffsetCFrame *= CFrame.new(0, AMPLITUDE + Y, 0) end do -- Rotating local TimeToMakeOneRotation = 4 local RotationsPerSecond = 1/TimeToMakeOneRotation OffsetCFrame *= CFrame.Angles(0, (rendertimeElapsed*math.pi) * RotationsPerSecond * SetupData.SpinDirection , 0) end return OffsetCFrame end; OnDropletTimeout = function(droplet: Droplet) local VisualModel = droplet:GetSetupData().VisualModel droplet:RemoveTask(&quot;GrowThread&quot;) for i = 1, 0.025, -0.025 do VisualModel:ScaleTo(i) task.wait() end end; OnClientClaim = function(playerWhoClaimed: Player, droplet: Droplet) -- droplet:Collect(playerWhoClaimed) end; --[[ Called when the droplet hits the player and is considered collected. This is ran on the client only. It should be used for collection effects and other client side things. ]] OnClientCollect = function(playerWhoCollected: Player, droplet: Droplet) local Value = droplet:GetValue() :: number local Part = GenericPart:Clone() Part.CFrame = droplet:GetPivot() task.delay(2, function() Part:Destroy() end) local CollectionSound = Instance.new(&quot;Sound&quot;) CollectionSound.SoundId = &quot;rbxassetid://402143943&quot; CollectionSound.Volume = 0.25 local PitchShift = Instance.new(&quot;PitchShiftSoundEffect&quot;) PitchShift.Octave = 2 - Value/1.5 PitchShift.Parent = CollectionSound CollectionSound.Parent = Part Part.Parent = workspace CollectionSound:Play() end; --[[ Called once the client informs the server that it has collected the droplet. ]] OnServerCollect = function(playerWhoCollected: Player, value: any, metadata: any) local ExpValue: number = value local leaderstats = playerWhoCollected:FindFirstChild(&quot;leaderstats&quot;) if not leaderstats then leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; leaderstats.Parent = playerWhoCollected end local expStat = leaderstats:FindFirstChild(&quot;Exp&quot;) if not expStat then expStat = Instance.new(&quot;NumberValue&quot;) expStat.Name = &quot;Exp&quot; expStat.Parent = leaderstats end expStat.Value += ExpValue -- Add the value to the player's &quot;exp&quot;. This is just an example. end; } ","keywords":""},{"title":"PromValue","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PromValue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#ClassName","content":"&lt;/&gt; PromValue.ClassName: &quot;PromValue&quot; The name of the class.  "},{"title":"Changed​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Changed","content":"&lt;/&gt; PromValue.Changed: Signal&lt;new: any,old: any&gt; A signal that fires when the value of the PromValue changes. "},{"title":"Functions​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#new","content":"Static &lt;/&gt; PromValue.new( initialValue: any?-- an optional initial value to set the PromValue to. ) → PromValue Creates a new PromValue  "},{"title":"Set​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Set","content":"&lt;/&gt; PromValue:Set(newValue: any) → () Sets the value of the PromValue and fires the Changed signal.  "},{"title":"Get​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Get","content":"&lt;/&gt; PromValue:Get() → any Immediately returns the stored value.  "},{"title":"IsReady​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#IsReady","content":"&lt;/&gt; PromValue:IsReady() → boolean Returns whether or not the value has been set yet  "},{"title":"OnReady​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#OnReady","content":"&lt;/&gt; PromValue:OnReady( fn: ((value: any) → ...any)?-- an optional function to call when the value is set. ) → Promise&lt;any&gt; Returns a promise that resolves with the value when it has been set atleast once. If given a function then it will run it the first time it is set, this is equivalent to just chaining :andThen(). Alias for :Promise()  "},{"title":"Promise​","type":1,"pageTitle":"PromValue","url":"/ModulesOnRails/api/PromValue#Promise","content":"&lt;/&gt; PromValue:Promise( fn: ((value: any) → ...any)?-- an optional function to call when the value is set. ) → Promise&lt;any&gt; Alias for :OnReady() "},{"title":"BaseTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#types","content":" "},{"title":"Id​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Id","content":"&lt;/&gt; type Id = number The id of a replicator.  "},{"title":"SearchCondition​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#SearchCondition","content":"&lt;/&gt; type SearchCondition = string | ClassToken | Tags | ( replicator: BaseTableReplicator, manager: TableManager? ) → (boolean) A condition that can be used to filter replicators. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If the condition is a function then it should return a boolean to indicate success. If the condition is a ClassToken then it will check if the replicator's class token matches the given token. If the condition is a string then it will check if the replicator's class token name matches the given string. If the condition is a Tags dictionary then it will check if the replicator's tags are a superset of the given tags.  "},{"title":"Tags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#Tags","content":"&lt;/&gt; type Tags = {[string]: any} The valid tag format that can be given to a TableReplicator. This table will become locked once given to a TableReplicator. Do not attempt to modify it after the fact. local tags = table.freeze { OwnerId = Player.UserId; ToolType = &quot;Sword&quot;; }  "},{"title":"Properties​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#properties","content":" "},{"title":"ReplicatorCreated​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#ReplicatorCreated","content":"&lt;/&gt; BaseTableReplicator.ReplicatorCreated: Signal&lt;BaseTableReplicator&gt; A signal that fires whenever a new replicator is created. "},{"title":"Functions​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#functions","content":" "},{"title":"iterating over BaseTableReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#__iter","content":"Metamethod &lt;/&gt; for in BaseTableReplicator do Iterates over all replicators that are currently in memory. for _, replicator in TableReplicator do print(replicator:GetServerId()) end   "},{"title":"getFromServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getFromServerId","content":"Static &lt;/&gt; BaseTableReplicator.getFromServerId(id: Id) → BaseTableReplicator? Returns the replicator with the given id if one exists.  "},{"title":"forEach​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#forEach","content":"Static &lt;/&gt; BaseTableReplicator.forEach( condition: SearchCondition, fn: ( replicator: BaseTableReplicator, manager: TableManager? ) → (), allowDestroyedReplicators: boolean? ) → () forEach is a special function that allows you to run a function on all replicators that currently exist or will exist that match the given condition. caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned.  "},{"title":"promiseFirstReplicator​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#promiseFirstReplicator","content":"Static &lt;/&gt; BaseTableReplicator.promiseFirstReplicator( condition: SearchCondition, allowDestroyedReplicators: boolean? ) → Promise&lt;BaseTableReplicator,TableManager?&gt; promiseFirstReplicator is a special function that allows you to run a function on the first replicator to satisfy the given condition. If no replicator currently exists that satisfies the condition then it will wait for one to be created. BaseTableReplicator.promiseFirstReplicator(&quot;Test&quot;) caution There are rare edge cases where if a Replicator is destroyed soon after it is created and you have deffered events, it will be destroyed before the ReplicatorCreated signal fires. In this case you can set allowDestroyedReplicators to true to allow destroyed replicators to be returned.  "},{"title":"getAll​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#getAll","content":"Static &lt;/&gt; BaseTableReplicator.getAll(classTokenName: string?) → {BaseTableReplicator} Fetches all replicators that are currently in memory. This is very slow and should be used sparingly.  "},{"title":"onNew​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#onNew","content":"Static &lt;/&gt; BaseTableReplicator.onNew( classToken: CanBeArray&lt;string | ClassToken&gt;, fn: (replicator: BaseTableReplicator) → () ) → () → () Listens for new replicators that are created with the given class token.  "},{"title":"GetTableManager​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTableManager","content":"&lt;/&gt; BaseTableReplicator:GetTableManager() → TableManager Gets the TableManager that is being replicated.  "},{"title":"GetServerId​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetServerId","content":"&lt;/&gt; BaseTableReplicator:GetServerId() → Id Returns the server id for this replicator. On the Server this is equivalent to :GetId()  "},{"title":"GetTokenName​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTokenName","content":"&lt;/&gt; BaseTableReplicator:GetTokenName() → string Fetches the name of the class token that this replicator is using.  "},{"title":"IsTopLevel​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsTopLevel","content":"&lt;/&gt; BaseTableReplicator:IsTopLevel() → boolean Returns whether or not this replicator is a top level replicator. A top level replicator is a replicator that has no parent. Only top level replicators can have their ReplicationTargets set.  "},{"title":"GetParent​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetParent","content":"&lt;/&gt; BaseTableReplicator:GetParent() → BaseTableReplicator? Returns the parent of this replicator if it has one. If this replicator is a top level replicator then this will return nil.  "},{"title":"GetChildren​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetChildren","content":"&lt;/&gt; BaseTableReplicator:GetChildren() → {BaseTableReplicator} Returns the immediate children of this replicator.  "},{"title":"GetDescendants​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetDescendants","content":"&lt;/&gt; BaseTableReplicator:GetDescendants() → {BaseTableReplicator} Returns the descendants of this replicator.  "},{"title":"FindFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#FindFirstChild","content":"&lt;/&gt; BaseTableReplicator:FindFirstChild( condition: SearchCondition, recursive: boolean? ) → BaseTableReplicator? Finds the first child that satisfies the given condition. The condition can be a function, a ClassToken, a string representing a ClassToken's name, or a Tags dictionary. If recursive is true then it will search through all descendants. local child = tr:FindFirstChild(function(child) local manager = child:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 })   "},{"title":"PromiseFirstChild​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#PromiseFirstChild","content":"&lt;/&gt; BaseTableReplicator:PromiseFirstChild(condition: SearchCondition) → Promise&lt;BaseTableReplicator&gt; Returns a promise that resolves when the first child that satisfies the given function is found. tr:PromiseFirstChild(function(replicator) local manager = replicator:GetTableManager() return manager:Get(&quot;Test&quot;) == 1 }):andThen(function(replicator) print(&quot;Found child with data key 'Test' equal to 1!&quot;) end) tr:PromiseFirstChild(&quot;Test&quot;):andThen(function(replicator) print(&quot;Found child with classtoken 'Test'!&quot;) end) tr:PromiseFirstChild({UserId == 12345}):andThen(function(replicator) print(&quot;Found child with UserId Tag matching 12345!&quot;) end)   "},{"title":"GetTag​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTag","content":"&lt;/&gt; BaseTableReplicator:GetTag(tagKey: string) → any Returns the value of the given tag for this replicator.  "},{"title":"GetTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#GetTags","content":"&lt;/&gt; BaseTableReplicator:GetTags() → Tags Returns the tags dictionary for this replicator.  "},{"title":"IsSupersetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSupersetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSupersetOfTags(tags: Tags) → boolean Checks whether or not the given tags are a subset of this replicator's tags. ELI5: Are all the given tags also on this replicator? Aliased as :ContainsAllTags(tags) ```lua local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSupersetOfTags({ Test1 = 1, }) -- true tr:IsSupersetOfTags({ Test2 = 2, }) -- true  "},{"title":"IsSubsetOfTags​","type":1,"pageTitle":"BaseTableReplicator","url":"/ModulesOnRails/api/BaseTableReplicator#IsSubsetOfTags","content":"&lt;/&gt; BaseTableReplicator:IsSubsetOfTags(tags: Tags) → boolean Checks whether or not this replicator's tags are a subset of the given tags. ELI5: Are all the tags on this replicator also on the given tags? Aliased as :IsWithinTags(tags) local tr = TableReplicator.new({ Tags = { Test1 = 1, Test2 = 2, } }) tr:IsSubsetOfTags({ Test1 = 1, Test2 = 2, Test3 = 3, }) -- true tr:IsSubsetOfTags({ Test1 = 1, }) -- false  "},{"title":"BaseComponent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseComponent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#functions","content":" "},{"title":"GetAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetAttribute","content":"&lt;/&gt; BaseComponent:GetAttribute( attributeName: string-- The name of the attribute to fetch ) → any?-- The current value of the attribute Fetches the current Value of an attribute on the Component Instance  "},{"title":"SetAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#SetAttribute","content":"&lt;/&gt; BaseComponent:SetAttribute( attributeName: string,-- The name of the attribute to set value: any-- The value to set the attribute to ) → () Sets an attribute of this Component's instance to a value  "},{"title":"IncrementAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#IncrementAttribute","content":"&lt;/&gt; BaseComponent:IncrementAttribute( attributeName: string,-- The name of the attribute to increment increment: number?-- The amount to increment the attribute by. Defaults to 1 ) → number-- The new value of the attribute Increments the current value of the attribute by the increment. If no increment is provided, it defaults to 1  "},{"title":"UpdateAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#UpdateAttribute","content":"&lt;/&gt; BaseComponent:UpdateAttribute( attributeName: string,-- The name of the attribute to mutate mutator: ((value: any) → (any))-- The function to mutate the attribute with ) → any-- The new value of the attribute Updates the current value of the attribute into a new value from the return of the mutator function  "},{"title":"ObserveAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#ObserveAttribute","content":"&lt;/&gt; BaseComponent:ObserveAttribute( attributeName: string,-- The name of the attribute to observe callback: ((newValue: any) → ())-- The function to call when the attribute changes ) → function-- A function to disconnect the observer Watches for when the attribute changes and calls the callback. Also calls the callback initially with the current value  "},{"title":"OutAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#OutAttribute","content":"&lt;/&gt; BaseComponent:OutAttribute( attributeName: string-- The name of the attribute to fetch ) → Value&lt;any&gt;-- The synchronized fusion value of the attribute Fetches an attribute and turns into into a synchronized usable value  "},{"title":"DefaultAttribute​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#DefaultAttribute","content":"&lt;/&gt; BaseComponent:DefaultAttribute( attributeName: string,-- The name of the attribute to set value: any,-- The value to set the attribute to validDataTypes: {string}?-- A list of valid data types for the attribute ) → any-- The value of the attribute Sets an attribute to a default value if it is not already set, allows for type checking of the initial value  "},{"title":"AttributeChanged​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AttributeChanged","content":"&lt;/&gt; BaseComponent:AttributeChanged( attributeName: string,-- The name of the attribute to observe fn: ((...any) → ())?-- The function to call when the attribute changes ) → RBXScriptConnection | RBXScriptSignal -- A function to disconnect the observer or the signal Fetches the AttributeChanged signal for the attribute if no function is given. If a function is provided, it will connect the function to the attribute changed signal and return the connection  "},{"title":"GetScope​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetScope","content":"&lt;/&gt; BaseComponent:GetScope() → Scope&lt;any&gt; Returns a scope associated with the lifecycle of the component. Inherits methods from RailUtil.Fusion and Fusion.  "},{"title":"AddPromise​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AddPromise","content":"&lt;/&gt; BaseComponent:AddPromise(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Adds a promise to the component's janitor. Returns the same promise that was given.  "},{"title":"AddTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#AddTask","content":"&lt;/&gt; BaseComponent:AddTask( task: T, cleanupMethod: (string | true)?, index: any? ) → T-- The same task that was given Adds a task to the component's janitor.  "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RemoveTaskNoClean","content":"&lt;/&gt; BaseComponent:RemoveTaskNoClean( index: any-- The index of the task to remove. ) → () Removes a task from the component's janitor without cleaning it.  "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RemoveTask","content":"&lt;/&gt; BaseComponent:RemoveTask( index: any,-- The id of the task to remove. dontClean: boolean?-- Optional flag to not clean the task. ) → () Removes a task from the component's janitor.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetTask","content":"&lt;/&gt; BaseComponent:GetTask( index: any-- The id of the task to get. ) → any-- The task that was retrieved. Gets a task from the janitor.  "},{"title":"ObserveProperty​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#ObserveProperty","content":"&lt;/&gt; BaseComponent:ObserveProperty( propertyName: string,-- The name of the property to observe callback: ((newValue: any) → ())-- The function to call when the property changes ) → function-- A function to disconnect the observer Watches for when the property changes and calls the callback. Also calls the callback initially with the current value  "},{"title":"OutProperty​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#OutProperty","content":"&lt;/&gt; BaseComponent:OutProperty( propertyName: string-- The name of the property to fetch ) → Value&lt;any&gt;-- The synchronized fusion value of the property Fetches an property and turns into into a synchronized usable value  "},{"title":"PropertyChanged​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#PropertyChanged","content":"&lt;/&gt; BaseComponent:PropertyChanged( propertyName: string,-- The name of the property to observe fn: ((...any) → ())?,-- The function to call when the property changes connectOnce: boolean?-- If true, the function will only be called the first time the property changes ) → RBXScriptConnection | RBXScriptSignal -- A connection or signal Fetches the PropertyChanged signal for the property if no function is given. If a function is provided, it will connect the function to the property changed signal and return the connection  "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#RegisterSignal","content":"&lt;/&gt; BaseComponent:RegisterSignal( signalName: string-- The name of the signal to register. ) → Signal-- The signal that was registered. Registers a signal to the component.  "},{"title":"GetSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#GetSignal","content":"&lt;/&gt; BaseComponent:GetSignal( signalName: string-- The name of the signal to get. ) → Signal-- The signal that was retrieved. Gets a signal from the component.  "},{"title":"FireSignal​","type":1,"pageTitle":"BaseComponent","url":"/ModulesOnRails/api/BaseComponent#FireSignal","content":"&lt;/&gt; BaseComponent:FireSignal( signalName: string,-- The name of the signal to fire. ...: any-- The arguments to pass to the signal. ) → () Fires a signal from the component. "},{"title":"DropletUtil","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/DropletUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#types","content":" "},{"title":"WeightedArray<T>​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#WeightedArray<T>","content":"&lt;/&gt; type WeightedArray&lt;T&gt; = {{ Weight: number, Value: T }} A table of values with weights. The weights are used to calculate the probability of a value being chosen. The weights do not need to add up to 1. See ProbabilityDistributor for more information.  "},{"title":"NumOrRange​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#NumOrRange","content":"&lt;/&gt; type NumOrRange = number | NumberRange    "},{"title":"NumOrRangeOrWeightedArray​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#NumOrRangeOrWeightedArray","content":"&lt;/&gt; type NumOrRangeOrWeightedArray = NumOrRange | WeightedArray&lt;NumOrRange&gt;   "},{"title":"ResourceTypeData​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#ResourceTypeData","content":"&lt;/&gt; interface ResourceTypeData { Defaults: table SetupDroplet: (droplet: Droplet) → any? OnRenderUpdate: (( droplet: Droplet, renderTime: number ) → (CFrame? ))? OnDropletTimeout: ((droplet: Droplet) → ())? OnClientClaim: (( playerWhoCollected: Player , droplet: Droplet ) → ())? OnClientCollect: (( playerWhoCollected: Player , droplet: Droplet ) → ())? OnServerCollect: (( playerWhoCollected: Player , value: any, metadata: any ) → ())? }  [Defaults] is a table of default values for the droplet. This can be left empty. The values in this table are used to fill in any missing values in the ResourceSpawnData when a droplet is spawned as well as overriding certain behaviors internall for things like magnetization. [SetupDroplet] is called when a new droplet is created. Use this to setup your visuals and any variables you need to keep track of. All parts within this should be Anchored = false, CanCollide = false, and Massless = true. The return value of this function can be accessed via Droplet:GetSetupData() [OnRenderUpdate] is called every frame that the droplet is within render range of the LocalPlayer's Camera. Use this to update the visuals of your droplet. The return value, if one is given, must be a CFrame and is used for offsetting the droplet. [OnDropletTimeout] is called when the droplet times out. Use this to perform/cleanup any visual effects you may have. [OnClientClaim] is called when the server acknowledges that the droplet has been claimed. [OnClientCollect] is called when the droplet hits the player and is considered collected. It should be used for collection effects and other client side things. [OnServerCollect] is called once the server is informed by a client that the droplet has been collected. This is where you should perform any server side logic like actually giving things like Money or Exp.   "},{"title":"ResourceSpawnData​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#ResourceSpawnData","content":"&lt;/&gt; interface ResourceSpawnData { ResourceType: string-- The registered name of the resource type Value: any | NumOrRangeOrWeightedArray-- The value of the droplet Metadata: any?-- The metadata of the droplet SpawnLocation: Vector3 | CFrame | PVInstance -- The location to spawn the droplet CollectorMode: CollectorMode?-- The behavior of how the droplet is claimed PlayerTargets: Player | {Player }?-- The players that can collect the droplet LifeTime: NumOrRange?-- The time before the droplet dissapears Count: NumOrRangeOrWeightedArray?-- The number of droplets to spawn EjectionDuration: NumOrRangeOrWeightedArray?-- The time it takes to spew out all the droplets EjectionHorizontalVelocity: NumOrRangeOrWeightedArray?-- The horizontal velocity of the droplets when they are ejected EjectionVerticalVelocity: NumOrRangeOrWeightedArray?-- The vertical velocity of the droplets when they are ejected }  Special Behaviors Any index that takes a NumOrRangeOrWeightedArray will be parsed and calculated ahead of time internally so that the client and server are synced. For example, if you pass in a NumberRange for Value, the server will calculate a random decimal number between the min and max, this number would then be accessed by Droplet:GetValue() on the client.  "},{"title":"CollectorMode​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#CollectorMode","content":"&lt;/&gt; type CollectorMode = &quot;MultiCollector&quot; | &quot;SingleCollector&quot; The behavior of how the droplet is claimed. MultiCollector - Many players can collect this droplet, each has their own individual instance SingleCollector - Only one player can collect this droplet  "},{"title":"Properties​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"DropletUtil","url":"/ModulesOnRails/api/DropletUtil#Enums","content":"&lt;/&gt; DropletUtil.Enums: {CollectorMode: { MultiCollector: CollectorMode, SingleCollector: CollectorMode }}  "},{"title":"AdjustableTimerManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/AdjustableTimerManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#types","content":" "},{"title":"TimerId​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#TimerId","content":"&lt;/&gt; type TimerId = string A unique identifier for the replication of an AdjustableTimer.  "},{"title":"Tags​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#Tags","content":"&lt;/&gt; type Tags = {[any]: any} Represents a dictionary of tags associated with a timer. Tags can be used to categorize or filter timers based on specific attributes. local tags = { Category = &quot;Game&quot;, Level = 5 }   "},{"title":"TagMatchType​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#TagMatchType","content":"&lt;/&gt; type TagMatchType = &quot;exact&quot; | &quot;any&quot; | &quot;superset&quot; | &quot;subset&quot; Defines the type of matching to perform when comparing tags. &quot;exact&quot;: All key-value pairs in the tags must match exactly. &quot;any&quot;: At least one key-value pair in the tags must match. &quot;superset&quot;: The timer's tags must contain all key-value pairs of the given tags. &quot;subset&quot;: The timer's tags must be contained within the key-value pairs of the given tags. "},{"title":"Properties​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#properties","content":" "},{"title":"TimerRegistered​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#TimerRegistered","content":"&lt;/&gt; AdjustableTimerManager.TimerRegistered: Signal&lt;AdjustableTimer,TimerId&gt; Signal that fires when a timer is registered with the manager. local connection = AdjustableTimerManager.TimerRegistered:Connect(function(timer, id) print(&quot;Timer registered:&quot;, timer, id) end)   "},{"title":"TimerDisconnected​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#TimerDisconnected","content":"&lt;/&gt; AdjustableTimerManager.TimerDisconnected: Signal&lt;AdjustableTimer,TimerId&gt; Signal that fires when a timer is disconnected from the manager. local connection = AdjustableTimerManager.TimerDisconnected:Connect(function(timer, id) print(&quot;Timer disconnected:&quot;, timer, id) end)  "},{"title":"Functions​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#functions","content":" "},{"title":"ReplicateTimer​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#ReplicateTimer","content":"This item only works when running on the server. Server &lt;/&gt; AdjustableTimerManager:ReplicateTimer( timer: AdjustableTimer,-- The timer to replicate. tags: Tags?-- Optional tags to associate with the timer. ) → TimerId-- The ID of the replicated timer. Replicates a timer to all clients. local id = AdjustableTimerManager:ReplicateTimer(timer, { Tag = &quot;Example&quot; }) Memory Leaks Ensure to call AdjustableTimerManager:DisconnectTimer(timer) when the timer is no longer needed to prevent memory leaks.  "},{"title":"DisconnectTimer​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#DisconnectTimer","content":"This item only works when running on the server. Server &lt;/&gt; AdjustableTimerManager:DisconnectTimer( timer: AdjustableTimer-- The timer to disconnect. ) → () Disconnects a timer from the manager and stops replicating it to clients. AdjustableTimerManager:DisconnectTimer(timer)   "},{"title":"GetTimerFromId​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetTimerFromId","content":"&lt;/&gt; AdjustableTimerManager:GetTimerFromId(id: TimerId) → AdjustableTimer? Returns the timer associated with the given ID, or nil if it doesn't exist. local timer = AdjustableTimerManager:GetTimerFromId(timerId)   "},{"title":"GetTimerId​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetTimerId","content":"&lt;/&gt; AdjustableTimerManager:GetTimerId(timer: AdjustableTimer) → TimerId? Returns the ID of the timer if it is registered, otherwise returns nil. local id = AdjustableTimerManager:GetTimerId(timer)   "},{"title":"GetTimerTags​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetTimerTags","content":"&lt;/&gt; AdjustableTimerManager:GetTimerTags( timer: AdjustableTimer | TimerId-- The timer or timer ID to get tags for. ) → Tags?-- The tags associated with the timer. Returns the tags associated with the given timer or timer ID. Tags are defined on the server when initially replicating the timer. local tags = AdjustableTimerManager:GetTimerTags(timer)   "},{"title":"GetTimersWithTags​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetTimersWithTags","content":"&lt;/&gt; AdjustableTimerManager:GetTimersWithTags( tagsToMatch: Tags,-- The tags to match against. matchType: TagMatchType?-- The type of tag matching to perform. Defaults to &quot;exact&quot;. ) → {AdjustableTimer}-- An array of timers that satisfy the tag match. Returns an array of timers that match the given tags. local timers = AdjustableTimerManager:GetTimersWithTags({ Tag = &quot;Example&quot; })   "},{"title":"PromiseFirstTimerWithTags​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#PromiseFirstTimerWithTags","content":"&lt;/&gt; AdjustableTimerManager:PromiseFirstTimerWithTags( tagsToMatch: Tags,-- The tags to match against. matchType: TagMatchType?-- The type of tag matching to perform. Defaults to &quot;exact&quot;. ) → Promise&lt;AdjustableTimer&gt;-- A promise that resolves with the first matching timer. Returns a promise that resolves with the first timer that matches the given tags. If no timer is found, it will wait for a timer to be registered that matches the tags. AdjustableTimerManager:PromiseFirstTimerWithTags({ Tag = &quot;Example&quot; }):andThen(function(timer) print(timer) end)   "},{"title":"PromiseTimerWithId​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#PromiseTimerWithId","content":"&lt;/&gt; AdjustableTimerManager:PromiseTimerWithId( id: TimerId-- The ID of the timer to find. ) → Promise&lt;AdjustableTimer&gt;-- A promise that resolves with the timer. Returns a promise that resolves with the timer associated with the given ID. Example Code AdjustableTimerManager:PromiseTimerWithId(someTimerId):andThen(function(timer) print(timer) end)   "},{"title":"GetAllReplicatedTimers​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#GetAllReplicatedTimers","content":"&lt;/&gt; AdjustableTimerManager:GetAllReplicatedTimers() → {AdjustableTimer} Returns an array of all replicated timers. local timers = AdjustableTimerManager:GetAllReplicatedTimers()   "},{"title":"SyncTimer​","type":1,"pageTitle":"AdjustableTimerManager","url":"/ModulesOnRails/api/AdjustableTimerManager#SyncTimer","content":"&lt;/&gt; AdjustableTimerManager:SyncTimer( timer: TimerId | AdjustableTimer,-- The timer or ID of the timer to sync. player: Player? -- Optional player to sync the timer with. If not provided, syncs with all clients. (SERVER ONLY) ) → Promise&lt;TimerId,SerializedAdjustableTimer&gt;-- A promise that resolves with the timer ID and its serialized state. If called on the client, it will request the server to sync the timer so that their states match. If called on the server, it will sync the timer with all clients or a specific player. This method should only need to be used if you perform some manual changes to the timer on the client side, such as pausing it. You will need to call this to resync the timer state with the server. AdjustableTimerManager:SyncTimer(timerId):andThen(function(timerId, snapshot) print(&quot;Timer synced:&quot;, timerId, snapshot) end)  "},{"title":"RemoteComponent","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/RemoteComponent","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#types","content":" "},{"title":"RemoteComponent​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#RemoteComponent","content":"&lt;/&gt; interface RemoteComponent { Client: table?-- Only available on the server. Set this to a table to expose it to the client. Server: table?-- Only available on the client. The indices of this are inferred from the server. }  "},{"title":"Functions​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#functions","content":" "},{"title":"createEvent () -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createEvent () -> MARKER","content":"&lt;/&gt; RemoteComponent.createEvent () -&gt; MARKER() → () Redirects to NetWire.createEvent  "},{"title":"createUnreliableEvent () -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createUnreliableEvent () -> MARKER","content":"&lt;/&gt; RemoteComponent.createUnreliableEvent () -&gt; MARKER() → () Redirects to NetWire.createUnreliableEvent  "},{"title":"createProperty (initialValue: any) -> MARKER​","type":1,"pageTitle":"RemoteComponent","url":"/ModulesOnRails/api/RemoteComponent#createProperty (initialValue: any) -> MARKER","content":"&lt;/&gt; RemoteComponent.createProperty (initialValue: any) -&gt; MARKER() → () Redirects to NetWire.createProperty "},{"title":"ProbabilityDistributor","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ProbabilityDistributor","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#types","content":" "},{"title":"Weight​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Weight","content":"&lt;/&gt; type Weight = number | NumberRange | () → (number | NumberRange ) A valid input for the weight of an item in the WeightsTable. Allows for functions to be passed in to generate a weight on the fly. If a NumberRange is given in, it will generate a random INTEGER between the min and max values of the Range.  "},{"title":"WeightedItem<T>​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#WeightedItem<T>","content":"&lt;/&gt; interface WeightedItem&lt;T&gt; { Weight: Weight Value: T } The format weights and an associated value must be in.  "},{"title":"WeightedArray<T>​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#WeightedArray<T>","content":"&lt;/&gt; type WeightedArray&lt;T&gt; = {WeightedItem&lt;T&gt;} A valid input for the WeightsTable. "},{"title":"Functions​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#new","content":"&lt;/&gt; ProbabilityDistributor.new( weights: {WeightedItem&lt;T&gt;},-- A table of weights to distribute. randomOrSeed: (Random | number)?-- An optional random number generator to use for the rolls. If a number is passed, it will be used as the seed for a new random number generator. If nothing is passed, it will create a new Random and use the current time as the seed. ) → ProbabilityDistributor&lt;T&gt;-- A new probability distributor of type T. Where T is the type of the value of the weighted item. Constructs a new ProbabilityDistributor  "},{"title":"Roll​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Roll","content":"&lt;/&gt; ProbabilityDistributor:Roll( luck: number?-- [Optional] A number between 0 and 1 that determines how lucky the roll is. The number acts as a chance that it rerolls the item for a better version. 'Better'ness is determined by the initial order of the weights table. ) → T-- The value of the item that was rolled. Rolls the probability distributor for a weighted item.  "},{"title":"Clone​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Clone","content":"&lt;/&gt; ProbabilityDistributor:Clone() → ProbabilityDistributor&lt;T&gt;-- A new probability distributor of type T. Where T is the type of the value of the weighted item. Clones the probability distributor.  "},{"title":"Sample​","type":1,"pageTitle":"ProbabilityDistributor","url":"/ModulesOnRails/api/ProbabilityDistributor#Sample","content":"&lt;/&gt; ProbabilityDistributor:Sample( numOfSamples: number?,-- The number of samples to take. Defaults to 10,000. luck: number?-- The luck to use for the rolls. Defaults to 0. ) → {[T]: number}-- A table of the items that were rolled and how many times they were rolled. Samples the probability distributor to show the distribution of the rolls. "},{"title":"PlayerProfileManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/PlayerProfileManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#types","content":" "},{"title":"DataMigrator​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#DataMigrator","content":"&lt;/&gt; interface DataMigrator { FromVersion: string ToVersion: string Migrate: ( profileData: table, profileOwner: Player ) → (table) } Used to Transform data from one version to another -- Turn all the deprecated currency 'Candy' into the new currency 'Gems' at a 1:10 rate local migrator = { FromVersion = &quot;0.0.1&quot;, ToVersion = &quot;0.0.2&quot; Migrate = function(data: table, plr: Player) if not data.Gems then data.Gems = 0 end local candy = data.Candy or 0 data.Gems += candy * 10 data.Candy = nil return data end }   "},{"title":"PPM_Config​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PPM_Config","content":"&lt;/&gt; interface PPM_Config { DataStoreKey: string DefaultDataSchema: table UseMock: boolean? Migrator: {DataMigrator} GetPlayerKeyCallback: ((player: Player ) → (string))? ReconcileCallback: (( player: Player , profile: Profile ) → ())? OnProfileLoadFailureCallback: (( player: Player , err: string ) → ())? }  DataStoreKey is the internal Key used for the PlayerData's DataStore. DefaultDataSchema is a template table that is used for reconciling the player's profile with. It is what new players are given if they dont have existing data. UseMock determines whether or not a Mock ProfileStore will be used. Migrator is a table of DataMigrators that are used to transform data from one version to another. GetPlayerKeyCallback is a callback that is used to fetch the Key that each player's data is mapped to. ReconcileCallback is a callback that is called when the system attempts to reconcile the players profile. It will default to calling Profile:Reconcile if not provided. OnProfileLoadFailureCallback is a callback that is called if the player's data fails to load. It will default to kicking the player if not provided.  "},{"title":"Functions​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#new","content":"&lt;/&gt; PlayerProfileManager.new(config: PPM_Config) → PlayerProfileManager Creates a new PlayerProfileManager. This is a singleton class, so calling this function multiple times will return the same instance. Takes a config table, see PPM_Config for more info on the individual fields it supports. PlayerProfileManager.new({ DataStoreKey = &quot;PlayerData&quot;; DefaultDataSchema = { __VERSION = &quot;0.0.0&quot;; Currency = 0; }; })   "},{"title":"IsLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#IsLoaded","content":"&lt;/&gt; PlayerProfileManager:IsLoaded(player: Player ) → boolean Returns whether or not the player's profile is currently loaded. local isLoaded = PlayerProfileManager:IsLoaded(player)   "},{"title":"OnLoaded​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#OnLoaded","content":"&lt;/&gt; PlayerProfileManager:OnLoaded(player: Player ) → Promise&lt;()&gt; Returns a promise that will resolve when the player's profile is loaded. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:OnLoaded(player):andThen(function() print(&quot;Profile loaded for &quot; .. player.Name) end)   "},{"title":"GetProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#GetProfile","content":"&lt;/&gt; PlayerProfileManager:GetProfile(player: Player ) → Profile? Returns the player's profile, if it exists. May return nil if this players profile is not loaded. local profile: Profile? = PlayerProfileManager:GetProfile(player)   "},{"title":"PromiseProfile​","type":1,"pageTitle":"PlayerProfileManager","url":"/ModulesOnRails/api/PlayerProfileManager#PromiseProfile","content":"&lt;/&gt; PlayerProfileManager:PromiseProfile(player: Player ) → Promise&lt;Profile&gt; Returns a promise that resolves with the player's profile when it is ready. Rejects if the player leaves or the profile fails to load. PlayerProfileManager:PromiseProfile(player):andThen(function(profile: Profile) print(&quot;Profile loaded for &quot; .. player.Name) end)  "},{"title":"Heap","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Heap","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#functions","content":" "},{"title":"min​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#min","content":"static &lt;/&gt; Heap.min() → Heap&lt;T&gt;-- A min-heap instance. Creates a min-heap where the smallest element is always on top.  "},{"title":"max​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#max","content":"static &lt;/&gt; Heap.max() → Heap&lt;T&gt;-- A max-heap instance. Creates a max-heap where the largest element is always on top.  "},{"title":"Peek​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Peek","content":"&lt;/&gt; Heap:Peek() → ( T?,-- The top value from the heap. number?-- The cost of the top value. ) Returns the top value from the heap without removing it. The top value is the value with the lowest cost in a min-heap and the value with the highest cost in a max-heap. If the heap is empty, nil is returned for both values. Time Complexity: Runs in O(1) time.  "},{"title":"Push​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Push","content":"&lt;/&gt; Heap:Push( value: T, cost: number? ) → () Inserts a value into the heap. Time Complexity: Runs in worst case O(log n) time. local minHeap = Heap.min() minHeap:Push(&quot;A&quot;, 5) minHeap:Push(&quot;B&quot;, 2) minHeap:Push(&quot;C&quot;, 8) local minValue, minCost = minHeap:Peek() print(minValue, minCost) -- B 2 Cost If no cost is given, the value itself is used as the cost. Ensure that the given value is comparable with relational operators. local minHeap = Heap.min() minHeap:Push(2) -- uses 2 for both value and cost print(minHeap:Peek()) -- 2 2   "},{"title":"Pop​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Pop","content":"&lt;/&gt; Heap:Pop() → ( T?, number? ) Removes and returns the top value from the heap. Time Complexity: Runs in worst case O(log n) time.  "},{"title":"Size​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Size","content":"&lt;/&gt; Heap:Size() → number Returns the number of elements in the heap. Equivalent to using the # operator on the heap. Time Complexity: Runs in O(1) time.  "},{"title":"Has​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#Has","content":"&lt;/&gt; Heap:Has( valueToCheckFor: T, cost: number? ) → boolean Takes a value or function and checks if the heap contains it. If a cost is provided then it will also ensure the cost matches. Returns true if the heap contains a specified value. Time Complexity: Runs in worst case O(n) time.  "},{"title":"UpdateCost​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#UpdateCost","content":"unreleased &lt;/&gt; Heap:UpdateCost( valueToUpdate: T | (value: T) → (boolean),-- The value to update the cost of. newCost: number | ( value: T, oldCost: number ) → number,-- The new cost to assign to the value. Can also be a function that takes the old cost and returns a new cost. updateAll: boolean?-- If true, all occurrences of the value will be updated. Defaults to false. ) → boolean-- True if the cost was updated, false otherwise. Updates the cost of a value in the heap. If no value is found, false is returned. Repeated Values If you have multiple instances of the same value, this method will only update the cost of the first valid instance found, unless the third parameter updateAll is set to true. There is no guarantee of which instance will be found first. Using updateAll can be expensive as it may need to perform a large resorting of the heap to ensure proper ordering. local minHeap = Heap.min() minHeap:Push(&quot;A&quot;, 5) minHeap:Push(&quot;B&quot;, 2) minHeap:Push(&quot;C&quot;, 8) minHeap:Push(&quot;D&quot;, 10) print(minHeap:Peek()) -- B 2 minHeap:UpdateCost(&quot;A&quot;, 1) print(minHeap:Peek()) -- A 1 -- update the cost of the first value that matches either &quot;A&quot; or &quot;B&quot; to 15 minHeap:UpdateCost(function(value) return value == &quot;A&quot; or value == &quot;B&quot; end, 15, false) -- update the cost of all values that match &quot;A&quot; or &quot;B&quot; to 30 minHeap:UpdateCost(function(value) return value == &quot;A&quot; or value == &quot;B&quot; end, 30, true)   "},{"title":"RemoveFirstOccurrence​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#RemoveFirstOccurrence","content":"&lt;/&gt; Heap:RemoveFirstOccurrence(valueToRemove: T) → boolean Removes the first occurrence of a given value from the heap. Heaps are not optimized for search removals, so this method should be used sparingly.  "},{"title":"RemoveAllOccurrences​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#RemoveAllOccurrences","content":"&lt;/&gt; Heap:RemoveAllOccurrences(valueToRemove: T) → number Removes all occurrences of a value from the heap and returns the number of occurrences removed. Heaps are not optimized for search removals, so this method should be used sparingly.  "},{"title":"ToTree​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#ToTree","content":"&lt;/&gt; Heap:ToTree() → Branch&lt;T&gt;?-- A tree representation of the heap. A utility method that converts the heap into a tree structure. This is useful for debugging and visualizing the heap. type Branch&lt;T&gt; = {Value: T, Left: Branch&lt;T&gt;?, Right: Branch&lt;T&gt;?}  "},{"title":"iterating over Heap​","type":1,"pageTitle":"Heap","url":"/ModulesOnRails/api/Heap#__iter","content":"metamethod &lt;/&gt; for value: T, cost: number in Heap do MetaMethod for iterating over the heap. In a for loop, the first variable is the Value and the second variable is the Cost. local minHeap = Heap.min() minHeap:Push(&quot;A&quot;, 5) minHeap:Push(&quot;B&quot;, 2) minHeap:Push(&quot;C&quot;, 8) minHeap:Push(&quot;A&quot;, 4) minHeap:Push(&quot;D&quot;, 10) for value: string, cost: number in minHeap do print(value, cost) end -- Output: the order may vary B 2 A 4 C 8 A 5 D 10 Manipulating the Heap during iteration It is not recommended to modify the Heap during iteration as it may cause undefined behavior. Internal orders may change and the iterator may not be able to find the next value. Iteration Order There is no guaranteed order of iteration. You should assume you will receive the values in a random order. "},{"title":"TableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableReplicator","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#properties","content":" "},{"title":"Client​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#Client","content":"This item only works when running on the client. Client &lt;/&gt; TableReplicator.Client: ClientTableReplicator   "},{"title":"Server​","type":1,"pageTitle":"TableReplicator","url":"/ModulesOnRails/api/TableReplicator#Server","content":"This item only works when running on the server. Server &lt;/&gt; TableReplicator.Server: ServerTableReplicator  "},{"title":"BaseObject","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/BaseObject","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#types","content":" "},{"title":"BaseObject​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BaseObject","content":"&lt;/&gt; type BaseObject = BaseObject  "},{"title":"Properties​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; BaseObject.ClassName: string  "},{"title":"Functions​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#functions","content":" "},{"title":"getObjectFromId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#getObjectFromId","content":"static &lt;/&gt; BaseObject.getObjectFromId(id: number) → BaseObject? Fetches the object with the given ID if it exists. local obj = BaseObject.new() local id = obj:GetId() print(BaseObject.getObjectFromId(id) == obj) -- true   "},{"title":"isDestroyed​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#isDestroyed","content":"static &lt;/&gt; BaseObject.isDestroyed(self: BaseObject) → boolean Checks whether or not the object is destroyed. local obj = BaseObject.new() print(BaseObject.isDestroyed(obj)) -- false obj:Destroy() print(BaseObject.isDestroyed(obj)) -- true   "},{"title":"new​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#new","content":"static &lt;/&gt; BaseObject.new( tbl: {[any]: any}?-- Table to construct the BaseObject with ) → BaseObject Constructs a new BaseObject local obj = BaseObject.new({ X = 1, Y = 2, }) obj.Z = 3 print(obj.X, obj.Y, obj.Z) -- 1, 2, 3 local SuperClass = BaseObject local MyClass = setmetatable({}, SuperClass) MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() local self = setmetatable(SuperClass.new(), MyClass) -- Custom logic here return self end function MyClass:Destroy() -- Overwrite the BaseObject Destroy method SuperClass.Destroy(self) -- If you overwrite the BaseObject Destroy method you need to have this line to call the original. end function MyClass:Print() print(&quot;Hello, World!&quot;) end return MyClass   "},{"title":"Destroy​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#Destroy","content":"&lt;/&gt; BaseObject:Destroy() → () Marks the Object as Destroyed, fires the Destroyed Signal, cleans up the BaseObject, and sets the metatable to nil/a special locked MT. Overriding If you override this method, you need to make sure you callSuperClass.Destroy(self) to call the superclass methods. function MyCustomClass:Destroy() SuperClass.Destroy(self) -- calls the superclass method to clean up events, tasks, etc.. end   "},{"title":"GetId​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetId","content":"&lt;/&gt; BaseObject:GetId() → number Returns the ID of the BaseObject Can be used to fetch the object with BaseObject.getObjectFromId(id)  "},{"title":"IsA​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#IsA","content":"&lt;/&gt; BaseObject:IsA(classOrClassName: {[any]: any} | string) → boolean Returns true if the given object is of a given class. Takes a class name or class object.  "},{"title":"GetTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetTask","content":"&lt;/&gt; BaseObject:GetTask(taskId: any) → Task? Fetches the task with the given ID if it exists. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:AddTask(part, nil, &quot;Test&quot;) print(obj:GetTask(&quot;Test&quot;) == part) -- true   "},{"title":"AddTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddTask","content":"&lt;/&gt; BaseObject:AddTask( task: Task, taskCleanupMethod: (string | true | nil)?,-- (if none is given it will try to infer; Passing true tells it to call it as a function) taskId: any? ) → Task-- The task that was given Adds a task to the janitor. If a taskId is provided, it will be used as the key for the task in the janitor and can then be fetched later with :GetTask(). If an ID is provided and there already exists a task with that ID, it will clean up the existing task and then replace the index with the new one. It will return the task that was added/given. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end) obj:Destroy() -- Prints &quot;Hello, World!&quot;   "},{"title":"AddPromise​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#AddPromise","content":"&lt;/&gt; BaseObject:AddPromise(prom: Promise) → Promise Adds a promise to the janitor. Similar to :AddTask(). Returns the same Promise that was given to it. local prom = Promise.delay(math.random(10)) local obj = BaseObject.new() obj:AddPromise(prom) task.wait(math.random(10)) obj:Destroy() -- Cancels the promise if it hasn't resolved yet   "},{"title":"RemoveTask​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTask","content":"&lt;/&gt; BaseObject:RemoveTask( taskId: any, dontClean: boolean? ) → () Removes a task from the janitor. Cleans the task as if :DoCleaning was called. If dontClean is true, it will not clean up the task, it will just remove it from the janitor. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTask(&quot;Test&quot;) -- Prints &quot;Hello, World!&quot;   "},{"title":"RemoveTaskNoClean​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RemoveTaskNoClean","content":"&lt;/&gt; BaseObject:RemoveTaskNoClean(taskId: any) → () Removes a task from the janitor without cleaning it. local obj = BaseObject.new() local task = obj:AddTask(function() print(&quot;Hello, World!&quot;) end, nil, &quot;Test&quot;) obj:RemoveTaskNoClean(&quot;Test&quot;) -- Does NOT print &quot;Hello, World!&quot;   "},{"title":"FireSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#FireSignal","content":"&lt;/&gt; BaseObject:FireSignal( signalName: string,-- The name of the signal to fire ...: any-- Arguments to pass to the signal ) → () Fires the signal with the given name, if it exists. Equivalent to calling :GetSignal(signalName):Fire(...) except this does not require the signal to exist first. local obj = BaseObject.new() local SignalName = &quot;Test&quot; obj:RegisterSignal(SignalName) obj:GetSignal(SignalName):Connect(print) obj:FireSignal(SignalName, &quot;Hello, World!&quot;) -- Fires the signal with the argument &quot;Hello, World!&quot;   "},{"title":"RegisterSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#RegisterSignal","content":"&lt;/&gt; BaseObject:RegisterSignal( signalName: string-- Name of signal to register ) → () Marks a signal with the given name as registered. Does not actually build a new signal, it sets the index to a SignalMarker to identify it as registered so that it can be fetched later.  "},{"title":"HasSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#HasSignal","content":"&lt;/&gt; BaseObject:HasSignal(signalName: string) → boolean Checks whether or not a signal with the given name is registered. local obj = BaseObject.new() local SignalName = &quot;Test&quot; print(obj:HasSignal(SignalName)) -- false obj:RegisterSignal(SignalName) print(obj:HasSignal(SignalName)) -- true   "},{"title":"GetSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetSignal","content":"&lt;/&gt; BaseObject:GetSignal(signalName: string) → Signal Fetches a signal with the given name. Creates the Signal JIT.  "},{"title":"ConnectSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#ConnectSignal","content":"&lt;/&gt; BaseObject:ConnectSignal( signalName: string, func: (...any) → () ) → () Connects a function to a signal with the given name. Creates the signal JIT. Shorthand for :GetSignal(signalName):Connect(func).  "},{"title":"GetDestroyedSignal​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#GetDestroyedSignal","content":"&lt;/&gt; BaseObject:GetDestroyedSignal() → Signal Returns a signal that fires when the object is destroyed. Creates the signal JIT. Kept for backwards compatibility. local obj = BaseObject.new() obj:GetDestroyedSignal():Connect(function() print(&quot;Object Destroyed!&quot;) end) obj:Destroy() -- Prints &quot;Object Destroyed!&quot;   "},{"title":"BindToInstance​","type":1,"pageTitle":"BaseObject","url":"/ModulesOnRails/api/BaseObject#BindToInstance","content":"&lt;/&gt; BaseObject:BindToInstance( obj: Instance , destroyOnNilParent: boolean?-- Whether or not to destroy the object when the parent is nil'd ) → function-- Disconnects the binding Binds the object to the given instance. When the object is destroyed, it will destroy the instance. When the instance is destroyed, it will destroy the object. local obj = BaseObject.new() local part = Instance.new(&quot;Part&quot;) obj:BindToInstance(part) do -- setup prints on destroy obj:AddTask(function() print(&quot;Object Destroyed!&quot;) end) part.Destroying:Connect(function() print(&quot;Part Destroyed!&quot;) end) end local X = if math.random(1,2) == 1 then obj or part X:Destroy() -- Prints &quot;Object Destroyed!&quot; and &quot;Part Destroyed!&quot; (Destroying one will destroy the other)  "},{"title":"CmdrServer","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/CmdrServer","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#functions","content":" "},{"title":"PromiseCmdr​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#PromiseCmdr","content":"&lt;/&gt; CmdrServer:PromiseCmdr() → Promise&lt;Cmdr&gt; Promise that resolves to the Cmdr module data  "},{"title":"RegisterCommandFromModule​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#RegisterCommandFromModule","content":"&lt;/&gt; CmdrServer:RegisterCommandFromModule( module: ModuleScript -- The module to register the command from ) → Promise&lt;nil&gt; Registers a command from a module with Cmdr. Command modules must return a table of type CommandModuleData. -- Commands/Kill.lua return { Name = &quot;kill&quot;; Aliases = {&quot;slay&quot;}; Description = &quot;Kills a player or set of players.&quot;; Group = &quot;DefaultAdmin&quot;; -- The permission group required to run this command Args = { { Type = &quot;players&quot;; Name = &quot;victims&quot;; Description = &quot;The players to kill.&quot;; }, }; -- Executors ClientRun = nil, -- No client side needed ServerRun = function (_, players) for _, player in pairs(players) do if player.Character then player.Character:BreakJoints() end end return (&quot;Killed %d players.&quot;):format(#players) end } CmdrServer:RegisterCommandFromModule(script.Parent.Commands.Kill)   "},{"title":"ExecuteCommand​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#ExecuteCommand","content":"&lt;/&gt; CmdrServer:ExecuteCommand( commandText: string, executor: Player? , options: { Data: any?, IsHuman: boolean }? ) → Promise&lt;string&gt; Executes a command with Cmdr from the server CmdrServer:ExecuteCommand(&quot;kill Raildex&quot;):andThen(function(result) print(result) end)   "},{"title":"ExecuteCommandAsClient​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#ExecuteCommandAsClient","content":"&lt;/&gt; CmdrServer:ExecuteCommandAsClient( executor: Player , ...: string ) → () Executes a command with Cmdr as if it were run by a client CmdrServer:ExecuteCommandAsClient(Players.Raildex, &quot;kill&quot;, &quot;*&quot;) CmdrServer:ExecuteCommandAsClient(Players.Raildex, &quot;kill *&quot;)   "},{"title":"HasPermission​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#HasPermission","content":"&lt;/&gt; CmdrServer:HasPermission( plr: Player ,-- The player to check commandName: string-- The name of the command to check ) → boolean Checks if a player has permission to run a command  "},{"title":"GetPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetPermissions","content":"&lt;/&gt; CmdrServer:GetPermissions(plr: Player ) → {any} Gets the permissions for a player  "},{"title":"SetPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#SetPermissions","content":"&lt;/&gt; CmdrServer:SetPermissions( plr: Player , permissions: string | {string} ) → () Sets the direct permissions for a player. Does not override inherited permissions or group permissions. CmdrServer:SetPermissions(Players.Raildex, &quot;Admin&quot;) info The 'Creator' permission grants all permissions regardless of group inheritance.  "},{"title":"GivePermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GivePermissions","content":"&lt;/&gt; CmdrServer:GivePermissions( plr: Player ,-- The player to grant permissions to permissions: string | {string}-- The permissions to grant ) → () Grants a player a permission group(s). Adds the given permissions to the player's current permissions. CmdrServer:GivePermissions(Players.Raildex, &quot;Admin&quot;)   "},{"title":"GetGroupRankPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetGroupRankPermissions","content":"&lt;/&gt; CmdrServer:GetGroupRankPermissions( groupId: number,-- The Roblox group id to get permissions for rank: number-- The rank to get permissions for ) → {string}-- The permissions granted to the rank Gets the permissions granted to a particular rank in a group. local permissions = CmdrServer:GetGroupRankPermissions(15905255, 230)   "},{"title":"GiveGroupPermissions​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GiveGroupPermissions","content":"&lt;/&gt; CmdrServer:GiveGroupPermissions( groupId: number,-- The Roblox group id to grant permissions to ranks: number | NumberRange ,-- The ranks to apply the permissions to. Can be a single rank or a range of ranks. permissions: string | {string}-- The permissions to grant to the group ) → function-- A function that can be called to remove the permissions Grants a Roblox group permissions to run a command. Takes the ranks to apply the permissions to, and the permissions to grant. local revoke = CmdrServer:GiveGroupPermissions(15905255, 230, &quot;Admin&quot;)   "},{"title":"SetPermissionInheritance​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#SetPermissionInheritance","content":"&lt;/&gt; CmdrServer:SetPermissionInheritance( permissionGroup: string,-- The permission group to set the inheritance for inheritedGroups: string | {string}-- The groups to inherit permissions from ) → nil Sets the permission inheritance for a permission group. This will override any previous inheritance. CmdrServer:SetPermissionInheritance(&quot;Admin&quot;, &quot;DefaultAdmin&quot;) CmdrServer:SetPermissionInheritance(&quot;Admin&quot;, {&quot;DefaultAdmin&quot;, &quot;Moderator&quot;})   "},{"title":"GetPermissionInheritance​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#GetPermissionInheritance","content":"&lt;/&gt; CmdrServer:GetPermissionInheritance(permissionGroup: string) → {string} Fetches the inherited permission group for a permission group  "},{"title":"RegisterType​","type":1,"pageTitle":"CmdrServer","url":"/ModulesOnRails/api/CmdrServer#RegisterType","content":"&lt;/&gt; CmdrServer:RegisterType( name: string,-- The name of the type typeData: TypeDefinition&lt;T&gt;-- The type data to register ) → Promise Registers a type with Cmdr "},{"title":"Queue","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Queue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#ClassName","content":"&lt;/&gt; Queue.ClassName: &quot;Queue&quot;  "},{"title":"Functions​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#new","content":"static &lt;/&gt; Queue.new() → Queue&lt;T&gt; Creates a new Queue  "},{"title":"iterating over Queue​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#__iter","content":"metamethod &lt;/&gt; for index: number, value: T in Queue do Iterates over the values in the Queue. local queue = Queue.new() queue:Push(50) queue:Push(100) for i, v in queue do print(i, v) end 1 50 2 100   "},{"title":"Peek​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Peek","content":"&lt;/&gt; Queue:Peek(index: number?) → T? Look at the first value in the queue. If there is an index provided, it will look at the value at that index instead. local queue = Queue.new() queue:Push(50) queue:Push(100) queue:Push(150) print(queue:Peek()) -- 50 print(queue:Peek(2)) -- 100 queue:Pop() print(queue:Peek()) -- 100   "},{"title":"Pop​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Pop","content":"&lt;/&gt; Queue:Pop() → T? Remove the value at the front of the queue if there is one.  "},{"title":"Push​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Push","content":"&lt;/&gt; Queue:Push(value: T) → () Add a value to the back of the queue.  "},{"title":"Prepend​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Prepend","content":"&lt;/&gt; Queue:Prepend(value: T) → () Add a value to the front of the queue.  "},{"title":"Size​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Size","content":"&lt;/&gt; Queue:Size() → number Get the number of items in the Queue.  "},{"title":"IsEmpty​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#IsEmpty","content":"&lt;/&gt; Queue:IsEmpty() → boolean Check if the queue is empty.  "},{"title":"ToArray​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#ToArray","content":"&lt;/&gt; Queue:ToArray() → {T} Converts the Queue into an iterable array.  "},{"title":"Has​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#Has","content":"&lt;/&gt; Queue:Has(value: T) → boolean Checks to see if a given value exists within the Queue.  "},{"title":"CountOccurrences​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#CountOccurrences","content":"&lt;/&gt; Queue:CountOccurrences(value: T) → number Returns the number of occurrences of a given value in the queue.  "},{"title":"RemoveFirstOccurrence​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#RemoveFirstOccurrence","content":"&lt;/&gt; Queue:RemoveFirstOccurrence(value: T) → boolean Removes the first occurrence of a given value in the queue. Returns whether or not it did remove something.  "},{"title":"RemoveAllOccurrences​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#RemoveAllOccurrences","content":"&lt;/&gt; Queue:RemoveAllOccurrences(value: T) → number Removes all occurrences of a given value in the queue. Returns the number of items removed.  "},{"title":"RemoveValueAt​","type":1,"pageTitle":"Queue","url":"/ModulesOnRails/api/Queue#RemoveValueAt","content":"&lt;/&gt; Queue:RemoveValueAt( index: number-- The index of the item to remove. ) → T | nil-- The item that was removed, or nil if the index was out of bounds or the queue is empty. Removes the item at the given index. Returns whether or not it did remove something. If it did, it will also return the item that was removed. This method should typically only be used in conjunction with the iterator metamethod. "},{"title":"ServerPlayerDataManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerPlayerDataManager","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#properties","content":" "},{"title":"DEFAULT_MANAGER_NAME​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#DEFAULT_MANAGER_NAME","content":"&lt;/&gt; ServerPlayerDataManager.DEFAULT_MANAGER_NAME: string The default internal manager name.  "},{"title":"PlayerDataReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#PlayerDataReady","content":"&lt;/&gt; ServerPlayerDataManager.PlayerDataReady: Signal&lt;Player &gt; A signal that fires when a Player's data is ready to be used. "},{"title":"Functions​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#new","content":"Constructor Singleton Static &lt;/&gt; ServerPlayerDataManager.new(ppm: PlayerProfileManager?) → ServerPlayerDataManager Constructs a new ServerPlayerDataManager instance. local PPM = PlayerProfileManager.new() local PlayerDataManager = PlayerDataManager.Server.new(PPM) PlayerProfileManager The ServerPlayerDataManager requires a PlayerProfileManager instance in order to properly function. You must provide a PlayerProfileManager instance before you call the :Start method. Optimally you should provide it during the constructor phase.  "},{"title":"OnReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#OnReady","content":"&lt;/&gt; ServerPlayerDataManager:OnReady(player: Player ) → Promise Promise that resolves when the player's data is ready to be used.  "},{"title":"IsReady​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#IsReady","content":"&lt;/&gt; ServerPlayerDataManager:IsReady(player: Player ) → boolean Checks whether or not a given player's data is ready  "},{"title":"IsManagerRegistered​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#IsManagerRegistered","content":"&lt;/&gt; ServerPlayerDataManager:IsManagerRegistered(managerName: string?) → boolean Checks whether or not a given manager is registered. If one is not specified then it will assume the default one.  "},{"title":"GetManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#GetManager","content":"&lt;/&gt; ServerPlayerDataManager:GetManager( player: Player , managerName: string? ) → TableManager? Fetches one of the given Player's DataManagers. If one is not specified then it will assume the default one.  "},{"title":"PromiseManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#PromiseManager","content":"&lt;/&gt; ServerPlayerDataManager:PromiseManager( player: Player , managerName: string? ) → Promise Promises a TableManager for a given player. If a managerName is not specified then it will assume the default one. ServerPlayerDataManager:PromiseManager(Players.Raildex, &quot;Settings&quot;):andThen(function(manager) manager:Set(&quot;Volume&quot;, 0.5) end)   "},{"title":"ForEachPlayer​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#ForEachPlayer","content":"&lt;/&gt; ServerPlayerDataManager:ForEachPlayer(fn: ( player: Player , data: any ) → ()) → Connection Runs a function for all existing loaded player data and all future player data. ServerPlayerDataManager:ForEachPlayer(function(player) local defaultManager = ServerPlayerDataManager:GetManager(player) defaultManager:Set(&quot;Volume&quot;, 0.5) end)   "},{"title":"GetReplicator​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#GetReplicator","content":"&lt;/&gt; ServerPlayerDataManager:GetReplicator( player: Player , replicatorName: string? ) → TableReplicator? Returns the TableReplicator for a given player. If a replicatorName is not specified then it will assume the default one. local replicator = ServerPlayerDataManager:GetReplicator(Players.Raildex, &quot;Settings&quot;)   "},{"title":"RegisterManager​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#RegisterManager","content":"&lt;/&gt; ServerPlayerDataManager:RegisterManager(config: { Name: string, GetData: ( player: Player , profile: Profile ) → table, ReplicationTargets: (&quot;All&quot; | &quot;Self&quot; | Player | {Player })?, Tags: table?, Parent: table?, Client: table?, } | string) → () Registers a config table for new managers to use for construction. ServerPlayerDataManager:RegisterManager({ Name = &quot;Settings&quot;, GetData = function(player, profile) return profile.Data.Settings end, ReplicationTargets = &quot;Self&quot;, Tags = {UserId = player.UserId}, }) Modifying the given table DO NOT MODIFY THE TABLE AFTER PASSING IT. Treat it as frozen. Doing so can cause potential desyncs between players.  "},{"title":"Start​","type":1,"pageTitle":"ServerPlayerDataManager","url":"/ModulesOnRails/api/ServerPlayerDataManager#Start","content":"&lt;/&gt; ServerPlayerDataManager:Start(ppm: PlayerProfileManager?) → () Starts the service and sets up all the Player's data managers. local PlayerDataManager = PlayerDataManager.Server.new() local PPM = PlayerProfileManager.new() PlayerDataManager:Start(PPM)  "},{"title":"TableState","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableState","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#new","content":"&lt;/&gt; TableState.new( manager: TableManager, Path: Path ) → TableState Creates a new TableState. This is used to observe and modify values in a TableManager easier. Equivalent to tblMngr:ToState(Path) local tbl = { Coins = 0; Inventory = { &quot;Sword&quot;; &quot;Shield&quot;; }; } local tblMngr = TableManager.new(tbl) local coinsState = TableState.new(tblMngr, &quot;Coins&quot;) print( coinsState == tblMngr:ToTableState(&quot;Coins&quot;) ) -- true coinsState:Set(100) -- equivalent to `tblMngr:SetValue(&quot;Coins&quot;, 100)` local inventoryState = TableState.new(tblMngr, &quot;Inventory&quot;) inventoryState:Insert(&quot;Potion&quot;) -- equivalent to `tblMngr:ArrayInsert(&quot;Inventory&quot;, &quot;Potion&quot;)` States with array values You should avoid setting states to be a particular index in array because if the array is shifted then the state can potentially be pointing to the wrong value.  "},{"title":"Set​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Set","content":"&lt;/&gt; TableState:Set(...: any) → () Sets the value this state is associated with. :Set(999) -- Sets the value itself to 999 :Set(1, 999) -- Sets the value at index 1 to 999 (State must be an array)   "},{"title":"Get​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Get","content":"&lt;/&gt; TableState:Get(index: number?) → any Gets the value this state is associated with. Takes an optional argument to specify the index of the array to get. :Get() -- Gets the value itself :Get(1) -- Gets the value at index 1 of the state (State must be an array) (Equivalent to :Get()[1])   "},{"title":"Increment​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Increment","content":"&lt;/&gt; TableState:Increment(...: any) → any Increments the value this state is associated with. :Increment(999) -- Increments the value itself by 999 :Increment(1, 999) -- Increments the value at index 1 by 999 (State must be an array)   "},{"title":"Insert​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Insert","content":"&lt;/&gt; TableState:Insert(...: any) → () Inserts a value into the array this state is associated with. :Insert(999) -- Appends 999 onto the array :Insert(5, 999) -- Inserts 999 at index 5 of the array   "},{"title":"Remove​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Remove","content":"&lt;/&gt; TableState:Remove(index: number) → any-- The removed value. Removes the value at the given index from the array this state is associated with.  "},{"title":"RemoveFirstValue​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#RemoveFirstValue","content":"&lt;/&gt; TableState:RemoveFirstValue(valueToFind: any) → number-- The index of the removed value. Removes the first value that matches the given value from the array this state is associated with.  "},{"title":"Observe​","type":1,"pageTitle":"TableState","url":"/ModulesOnRails/api/TableState#Observe","content":"&lt;/&gt; TableState:Observe(fn: (new: any) → ()) → () → () Observes changes to the value this state is associated with. Also fires immediately. See TableManager:Observe for more information. "},{"title":"ServerNetWire","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerNetWire","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#types","content":" "},{"title":"ServerRemoteEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerRemoteEvent","content":"&lt;/&gt; type ServerRemoteEvent = RemoteSignal https://sleitnick.github.io/RbxUtil/api/RemoteSignal  "},{"title":"ServerRemoteProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerRemoteProperty","content":"&lt;/&gt; type ServerRemoteProperty = RemoteProperty https://sleitnick.github.io/RbxUtil/api/RemoteProperty  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...any )  "},{"title":"Properties​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#properties","content":" "},{"title":"ClassName​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ServerNetWire.ClassName: &quot;ServerNetWire&quot;  "},{"title":"Functions​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#new","content":"constructor static &lt;/&gt; ServerNetWire.new(nameSpace: string | Service) → () Constructs a new ServerNetWire. If a ServerNetWire with the same nameSpace already exists, it will be returned instead.  "},{"title":"setupServiceNetworking​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#setupServiceNetworking","content":"constructor static &lt;/&gt; ServerNetWire.setupServiceNetworking(service: Service) → ServerNetWire Creates a ServerNetWire from a Roam Service. This method will read the service's Name and Client table to create the NetWire. The goal of this function is to recreate the simplicity of Knit's networking features without the systems being coupled together. In order to access the service on the client, use NetWire.Client(&quot;SERVICE_NAME&quot;). local ExampleService = Roam.createService { Name = &quot;ExampleService&quot; } ExampleService.Client = { TestEvent = NetWire.createEvent() } function ExampleService.Client:Greeting(plr: Player, msg: string) print(plr.Name, &quot;said&quot;, msg) end ---------------------------------------------------------------- function ExampleService:RoamInit() NetWire.Server.setupServiceNetworking(self) end function ExampleService:RoamStart() self.Client.TestEvent:FireAll(&quot;Hello from ExampleService!&quot;) -- send a message to all clients end Client Table Overwrite Calling this function will overwrite the service's Client table with the NetWire. You should not store anything aside from supported NetWire objects in the Client table. Where to call This function should be called within the init method of the service. This is to prevent netwires from being created outside of a running game.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#Destroy","content":"destructor &lt;/&gt; ServerNetWire:Destroy() → () Destroys the NetWire and removes it from the internal cache.  "},{"title":"RegisterEvent​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterEvent","content":"&lt;/&gt; ServerNetWire:RegisterEvent( eventName: string, isUnreliable: boolean?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote event with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteSignal Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteSignal -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestEvent = NetWire.createEvent() myWire.TestEvent:Connect(function(plr: Player, someArg) print(someArg) end) myWire.TestEvent:FireAll(&quot;Hello from the server!&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire.TestEvent:Connect(function(someArg) print(someArg) end) myWire.TestEvent:Fire(&quot;Hello from the client!&quot;)   "},{"title":"RegisterProperty​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterProperty","content":"&lt;/&gt; ServerNetWire:RegisterProperty( propertyName: string, initialValue: any?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote property with the given name. Server Documentation: https://sleitnick.github.io/RbxUtil/api/RemoteProperty Client Documentation: https://sleitnick.github.io/RbxUtil/api/ClientRemoteProperty -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) myWire.TestProperty = NetWire.createProperty(&quot;Hello&quot;) --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) if myWire.TestProperty:IsReady() then -- Check if its ready first print( myWire.TestProperty:Get() ) -- &quot;Hello&quot; end   "},{"title":"RegisterMethod​","type":1,"pageTitle":"ServerNetWire","url":"/ModulesOnRails/api/ServerNetWire#RegisterMethod","content":"&lt;/&gt; ServerNetWire:RegisterMethod( functionName: string, callback: ( self: any, plr: Player , ...any ) → (...any), tbl: {}?, inboundMiddleware: {ServerMiddleware}?, outboundMiddleware: {ServerMiddleware}? ) → () Creates a remote function with the given name. This is not suggested to be used by end users; instead you should just append a function to a netwire object and it will properly wrap it for you. -- Server Side local myWire = NetWire.Server(&quot;MyWire&quot;) function myWire:TestMethod(plr: Player, arg: number) return arg * 2 end --------------------------------------------------------- -- Client Side local myWire = NetWire.Client(&quot;MyWire&quot;) myWire:TestMethod(5):andThen(function(result) print(result) -- 10 end)  "},{"title":"Roam","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Roam","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#types","content":" "},{"title":"ServiceConfig​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#ServiceConfig","content":"&lt;/&gt; interface ServiceConfig { Name: string-- Name of the Service. Must be unique. Used when accessing via .getService RequiredServices: {Service}?-- The Services that this Service depends on. Roam will ensure that these Services are initialized before this Service. StartMethodName: string?-- Overrides default StartMethodName of &quot;RoamStart&quot; InitMethodName: string?-- Overrides default InitMethodName of &quot;RoamInit&quot; } local myOtherService = require(ReplicatedStorage.MyOtherService) ------------------------------------------------- local MyService = {} function MyService:CustomStartMethod() print(&quot;MyService started!&quot;) end ------------------------------------------------- Roam.registerService(MyService, { Name = &quot;MyService&quot;, RequiredServices = {myOtherService}, StartMethodName = &quot;CustomStartMethod&quot;, }) return MyService Deffering RequiredServices Do NOT add services to the RequiredServices after you have created or registered the service. This will cause undefined behavior. "},{"title":"Properties​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#properties","content":" "},{"title":"Debug​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#Debug","content":"&lt;/&gt; Roam.Debug: boolean Whether or not to print debug messages. Default is false.  "},{"title":"Bootstrappers​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#Bootstrappers","content":"&lt;/&gt; Roam.Bootstrappers: { Server: (script: Script ) → (), Client: (script: Script ) → () } A table of generic bootstrappers for Roam that you can use to quickly setup new projects. local Roam = require(Packages.Roam) Roam.Bootstrappers.Server(script) :andThenCall(print, &quot;Roam Server Bootstrapped!&quot;)  "},{"title":"Functions​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#functions","content":" "},{"title":"registerService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#registerService","content":"&lt;/&gt; Roam.registerService( service: Service, serviceConfig: (ServiceConfig | string)? ) → Service Registers a Service/Table with Roam to be Initialized and Started when Roam starts. Cannot be called after Roam has been started. local MyRegisteredService = {} function MyRegisteredService:RoamStart() print(&quot;MyRegisteredService started!&quot;) end function MyRegisteredService:RoamInit() print(&quot;MyRegisteredService initialized!&quot;) end ---------------------------------------------------------------- local Roam = require(Packages.Roam) Roam.registerService(MyRegisteredService, &quot;MyRegisteredService&quot;) return MyRegisteredService   "},{"title":"start​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#start","content":"&lt;/&gt; Roam.start(postInitPreStart: (() → (Promise?))?) → Promise Starts Roam. Should only be called once. Calling multiple times will result in a promise rejection. Optional argument postInitPreStart is a function that is called after all services have been initialized, but before they are started. Roam.start() :andThenCall(print, &quot;Roam started!&quot;) :catch(warn) caution Be sure that all services have been created before calling Start. Services cannot be added later. Bootstrapping You can use the Roam.Bootstrappers table/methods to quickly bootstrap Roam in your project. This is reccomended as it will provide a consistent starting point for your projects.  "},{"title":"onStart​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#onStart","content":"&lt;/&gt; Roam.onStart() → Promise Returns a promise that is resolved once Roam has started. This is useful for any code that needs to tie into Roam services but is not the script that called Start. Roam.onStart():andThen(function() local MyService = Roam.Services.MyService MyService:DoSomething() end):catch(warn)   "},{"title":"isReady​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#isReady","content":"&lt;/&gt; Roam.isReady() → boolean Returns whether or not Roam has been successfully started and is ready for external access.  "},{"title":"requireModules​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#requireModules","content":"&lt;/&gt; Roam.requireModules( parents: Instance | {Instance }, config: { DeepSearch: boolean?, RequirePredicate: ((obj: ModuleScript ) → boolean)?, IgnoreDescendantsPredicate: ((obj: Instance ) → boolean)?, }? ) → {Service} Requires all the modules that are children of the given parent. This is an easy way to quickly load all services that might be in a folder. Takes an optional predicate function to filter which modules are loaded. Services collected this way must not yield. DeepSearch -&gt; whether it checks descendants or just children RequirePredicate -&gt; a predicate function that determines whether a module should be required IgnoreDescendantsPredicate -&gt; A Predicate for whether the Descendants of the Module should be Searched (Only matters if DeepSearch is true) local pred = function(obj: ModuleScript): boolean return obj.Name:match(&quot;Service$&quot;) ~= nil end Roam.requireModules(ReplicatedStorage.Shared, { DeepSearch = true, RequirePredicate = pred, IgnoreDescendantsPredicate = function(obj: Instance): boolean return obj.Name == &quot;Ignore&quot; end, })   "},{"title":"getNameFromService​","type":1,"pageTitle":"Roam","url":"/ModulesOnRails/api/Roam#getNameFromService","content":"&lt;/&gt; Roam.getNameFromService(service: Service) → string Fetches the name of a registered Service. "},{"title":"TableReplicatorSingleton","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableReplicatorSingleton","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#new","content":"&lt;/&gt; TableReplicatorSingleton.new(config: Config) → () "},{"title":"Types","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton##","content":""},{"title":"​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Config","content":"interface Config { ClassTokenName: string-- The name of the class token to listen for. DefaultDataSchema: table?-- The default schema to use if the replicator is not ready yet. ConditionFn: ((replicator: ClientTableReplicator) → boolean)?-- A function that returns whether or not the replicator is valid and should be bound. }  Creates a new TableReplicatorSingleton. local ClientPlayerData = TableReplicatorSingleton.new { ClassTokenName = &quot;PlayerData&quot;; DefaultDataSchema = Import(&quot;PlayerDataSchema&quot;); ConditionFn = function(replicator) return replicator:GetTag(&quot;UserId&quot;) == LocalPlayer.UserId end; } return ClientPlayerData   "},{"title":"Get​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Get","content":"&lt;/&gt; TableReplicatorSingleton:Get( path: Path, index: number? ) → any? Fetches the value at the path. An index can be provided to fetch the value at that index. If the value is not ready yet, it will return the value rom the default schema if one was given. If the path is untraversable, it will return nil. local coins = ClientPlayerData:Get(&quot;Coins&quot;) local thirdItem = ClientPlayerData:Get(&quot;Inventory&quot;, 3) -- Equivalent to `ClientPlayerData:Get(&quot;Inventory&quot;)[3]`   "},{"title":"Observe​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#Observe","content":"&lt;/&gt; TableReplicatorSingleton:Observe( path: Path, callback: (newValue: any?) → () ) → () → () Called immediately and then whenever the value at the path changes. The callback will be called with the new value. ClientPlayerData:Observe(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToValueChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToValueChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToValueChange( path: Path, callback: (...any) → () ) → function-- A function that, when called, will disconnect the listener. Called when the value at the path is changed. The callback will be called with the new value. ClientPlayerData:ListenToValueChange(&quot;Coins&quot;, function(newValue) print(&quot;Coins changed to&quot;, newValue) end)   "},{"title":"ListenToAnyChange​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ListenToAnyChange","content":"&lt;/&gt; TableReplicatorSingleton:ListenToAnyChange( path: Path, callback: (...any) → () ) → () → () Called when the value at the path is changed through any means. This includes if the value is an array and a value in the array is changed, inserted, or removed.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#ToFusionState","content":"&lt;/&gt; TableReplicatorSingleton:ToFusionState(path: Path) → State&lt;any&gt; Returns a Fusion State object that will automatically update when the value at the path changes. This is useful for when you want to use Fusion dependents to respond to changes in the value. local coinsState = ClientPlayerData:ToFusionState(&quot;Coins&quot;) New &quot;TextLabel&quot; { Text = coinsState; }   "},{"title":"GetTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableManager","content":"&lt;/&gt; TableReplicatorSingleton:GetTableManager() → TableManager Gets the TableManager for the TableReplicatorSingleton. This will error if the TableManager is not ready yet. local TM = ClientPlayerData:GetTableManager()   "},{"title":"GetTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#GetTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:GetTableReplicator() → ClientTableReplicator Gets the TableReplicator for the TableReplicatorSingleton. This will error if the TableReplicator is not ready yet. local TR = ClientPlayerData:GetTableReplicator()   "},{"title":"PromiseTableManager​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableManager","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableManager() → Promise&lt;TableManager&gt; Returns a promise that resolves with the TableManager when it is ready. ClientPlayerData:PromiseTableManager():andThen(function(TM: TableManager) print(&quot;TableManager is ready!&quot;) end)   "},{"title":"PromiseTableReplicator​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#PromiseTableReplicator","content":"&lt;/&gt; TableReplicatorSingleton:PromiseTableReplicator() → Promise&lt;ClientTableReplicator&gt; Returns a promise that resolves with the TableReplicator when it is ready. ClientPlayerData:PromiseTableReplicator():andThen(function(TR: ClientTableReplicator) print(&quot;TableReplicator is ready!&quot;) end)   "},{"title":"IsReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#IsReady","content":"&lt;/&gt; TableReplicatorSingleton:IsReady() → boolean Returns whether or not a valid Replicator has been found and hooked into. if ClientPlayerData:IsReady() then print(&quot;We have a valid Replicator!&quot;) end   "},{"title":"OnReady​","type":1,"pageTitle":"TableReplicatorSingleton","url":"/ModulesOnRails/api/TableReplicatorSingleton#OnReady","content":"&lt;/&gt; TableReplicatorSingleton:OnReady() → Promise&lt;()&gt; Returns a promise that resolves when the TableReplicatorSingleton is ready. ClientPlayerData:OnReady():andThen(function() print(&quot;Found a valid Replicator!&quot;) end)  "},{"title":"ServerTableReplicator","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/ServerTableReplicator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#types","content":" "},{"title":"ReplicationTargets​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicationTargets","content":"&lt;/&gt; type ReplicationTargets = &quot;All&quot; | Player | {Player } The Player(s) that the STR should replicate to. If &quot;All&quot; is given then the STR will replicate to all current and future players.  "},{"title":"ReplicationToken​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#ReplicationToken","content":"&lt;/&gt; type ReplicationToken = {Name: string} A unique symbol that identifies the STR Class. This is used to identify the STR Class when it is replicated to the client. Use .Token to generate an object of this type. Do NOT manually create the table. "},{"title":"Properties​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#properties","content":" "},{"title":"AddedActivePlayer​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#AddedActivePlayer","content":"&lt;/&gt; ServerTableReplicator.AddedActivePlayer: Signal&lt;Player &gt; A signal that fires whenever a player starts being replicated to. This happens when their client requests the current data from the server.  "},{"title":"All​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#All","content":"&lt;/&gt; ServerTableReplicator.All: ServerTableReplicator A STR that replicates to all current and future players. Used as a global parent for child STRs that need a home and should be replicated to all current and future players. Do not modify anything about this STR, only use it as a Parent.  "},{"title":"None​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#None","content":"&lt;/&gt; ServerTableReplicator.None: ServerTableReplicator A STR that doesnt replicate to anyone. Used as a global parent for child STRs that shouldnt be replicated. Do not modify anything about this STR, only use it as a Parent. "},{"title":"Functions​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#functions","content":" "},{"title":"Token​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Token","content":"&lt;/&gt; ServerTableReplicator.Token(tokenName: string) → ReplicationToken Returns a Token Symbol that is used for identifying the ServerTableReplicator Class. We use unique symbols instead of strings to prevent accidental collisions on the server. warning This may only be called once per unique string. The returned symbol should be used repeatedly instead of calling this function again. Calling this function again with the same string will result in an error.  "},{"title":"new​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#new","content":"&lt;/&gt; ServerTableReplicator.new(config: { Token: ReplicationToken, TableManager: TableManager, ReplicationTargets: ReplicationTargets?, Parent: ServerTableReplicator?, Tags: {[string]: any}?, Client: {[string]: any}?, }) → () Creates a new ServerTableReplicator instance. The config must be given a TableManager instance and a Token Symbol. A list of replication targets can be provided to specify which players the STR should replicate to immediately. If no replication targets are specified, the STR will not replicate to any players. You can specify a Parent STR instead of giving ReplicationTargets and it will inherit the replication targets of the top level STR. Optionally, a list of tags can be provided to help identify the STR. The tags list will become immutable internally after the STR is created. EXAMPLE: -- Some Server Script local token = ServerTableReplicator.Token(&quot;PlayerData&quot;) Players.PlayerAdded:Connect(function(player) local manager = TableManager.new({ Money = math.random(1, 100); }) local replicator = ServerTableReplicator.new({ TableManager = manager, Token = token, ReplicationTargets = &quot;All&quot;, Tags = {UserId = player.UserId}, }) end) -- Some Client Script ClientTableReplicator.onNew(&quot;PlayerData&quot;, function(replicator) print(&quot;New PlayerData STR: &quot;, replicator:GetTag(&quot;UserId&quot;)) print(&quot;Money: &quot;, replicator:GetTableManager():Get(&quot;Money&quot;)) end) Top Level Replicators A replicator must be given either a Parent Replicator or a list of ReplicationTargets. If both are given then it will produce an error. If you give ReplicationTargets then that Replicator will be known as TopLevel. Only TopLevel Replicators can have their ReplicationTargets manually changed. If a Parent Replicator is given, the Child Replicator will inherit the replication targets of the Ancestor TopLevel Replicator.  "},{"title":"Destroy​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Destroy","content":"&lt;/&gt; ServerTableReplicator:Destroy() → () Destroys the Replicator on both the Server and any replicated Clients  "},{"title":"Subscribe​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Subscribe","content":"&lt;/&gt; ServerTableReplicator:Subscribe(targets: ReplicationTargets) → () Adds a player or list of players to the replication targets.  "},{"title":"Unsubscribe​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#Unsubscribe","content":"&lt;/&gt; ServerTableReplicator:Unsubscribe(targets: ReplicationTargets) → () Removes a player or list of players from the replication targets.  "},{"title":"SetSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetSubscribers","content":"&lt;/&gt; ServerTableReplicator:SetSubscribers(targets: ReplicationTargets) → () Overwrites the current replication targets with the new targets.  "},{"title":"IsSubscribed​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsSubscribed","content":"&lt;/&gt; ServerTableReplicator:IsSubscribed(player: Player ) → boolean Checks whether the player is a valid target for replication. Not whether the player is currently being replicated to.  "},{"title":"IsSubscribedToAll​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#IsSubscribedToAll","content":"&lt;/&gt; ServerTableReplicator:IsSubscribedToAll() → boolean Returns whether or not this STR is replicating to all current and future players.  "},{"title":"GetSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetSubscribers","content":"&lt;/&gt; ServerTableReplicator:GetSubscribers() → {Player } Gets the list of Players that this Replicator is attempting to replicate to.  "},{"title":"GetActiveSubscribers​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#GetActiveSubscribers","content":"&lt;/&gt; ServerTableReplicator:GetActiveSubscribers() → {Player } Gets the list of Players that this Replicator is currently replicating to. This is different from GetReplicationTargets as it does not include pending replication targets.  "},{"title":"SetParent​","type":1,"pageTitle":"ServerTableReplicator","url":"/ModulesOnRails/api/ServerTableReplicator#SetParent","content":"&lt;/&gt; ServerTableReplicator:SetParent(newParent: ServerTableReplicator) → () Sets the Parent of this STR to the given STR. "},{"title":"LooseTightDoubleGrid","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/LooseTightDoubleGrid","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#types","content":" "},{"title":"EntityId​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#EntityId","content":"&lt;/&gt; type EntityId = number An identifier for an entity in the grid. This is a unique number assigned to each entity upon insertion into the grid. Ids are not unique between different grids, so they should be used only within the context of a single grid instance.  "},{"title":"ShapeType​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#ShapeType","content":"&lt;/&gt; type ShapeType = string The type of shape for an entity in the grid. Use the ShapeType enum for comparisions as the raw values are subject to change.  "},{"title":"FilterParams​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#FilterParams","content":"&lt;/&gt; interface FilterParams { FilterList: {EntityId}? CustomFilter: ((EntityId) → boolean)? FilterType: Enum.RaycastFilterType? } Controls the filtering of entities during queries. You can use either a list of entity IDs or a custom filter function to specify which entities to include or exclude from the query results. The FilterType determines whether the filter is inclusive or exclusive. Uses RaycastFilterType for consistency with Roblox's raycasting system. "},{"title":"Properties​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#properties","content":" "},{"title":"ShapeType​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#ShapeType","content":"&lt;/&gt; LooseTightDoubleGrid.ShapeType: { Circle: ShapeType, Rect: ShapeType, Point: ShapeType } Circle: Represents a circular entity. Rect: Represents a rectangular entity. Point: Represents a point entity. "},{"title":"Functions​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#functions","content":" "},{"title":"new​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#new","content":"&lt;/&gt; LooseTightDoubleGrid.new(config: { Position: Vector2? , Size: Vector2? , CellSize: number? }) → LTDG Creates a new instance of LooseTightDoubleGrid with the given configuration. Position is the center origin of the grid. (Default: Vector2.new(0, 0)) Size is the number of cells in the x and y directions. (Default: Vector2.new(32, 32)) CellSize is the size of each cell in studs. Adjust this number based on the average sizes of your provided entities in order to optimize performance. (Default: 4) local grid = LooseTightDoubleGrid.new({ Position = Vector2.new(0, 0), Size = Vector2.new(32, 32), CellSize = 4 })   "},{"title":"iterating over LooseTightDoubleGrid​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#__iter","content":"&lt;/&gt; for id: EntityId in LooseTightDoubleGrid do Iterates over the entities in the grid. local grid = LooseTightDoubleGrid.new() grid:InsertRect(Vector2.new(10, 10), Vector2.new(5, 5)) for id in grid do print(grid:GetPosition(id)) -- Prints the position of each entity in the grid end   "},{"title":"GetEntities​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntities","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntities() → {EntityId} Gets an array of all currently registered entity IDs in the grid. If you need to iterate over the grid then you should use the __iter metamethod instead.  "},{"title":"InsertRect​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#InsertRect","content":"&lt;/&gt; LooseTightDoubleGrid:InsertRect( position: Vector2 , size: Vector2 ) → EntityId Inserts a rectangular entity into the grid. -- Example Code for generating some parts and registering them in the grid local function V3ToV2(v3: Vector3): Vector2 return Vector2.new(v3.X, v3.Z) end local IdToPart = {} for i = 1, 10 do local part = Instance.new(&quot;Part&quot;) part.Size = Vector3.new(math.random(1, 5), 1, math.random(1, 5)) part.Position = Vector3.new(math.random(-20, 20), 1, math.random(-20, 20)) part.Anchored = true part.Parent = workspace local entityId = grid:InsertRect(V3ToV2(part.Position), V3ToV2(part.Size)) -- Some potential ways you could identify the connection between the part and the entityId: IdToPart[entityId] = part -- A: store the part in a table for later reference part:SetAttribute(&quot;EntityId&quot;, entityId) -- B: store the entity ID in the part's attribute for lookup print(&quot;Inserted Rect Entity ID:&quot;, entityId) end   "},{"title":"InsertCircle​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#InsertCircle","content":"&lt;/&gt; LooseTightDoubleGrid:InsertCircle( position: Vector2 , radius: number ) → EntityId Inserts a circular entity into the grid. local entityId = grid:InsertCircle(Vector2.new(5, 5), 2) print(&quot;Inserted Circle Entity ID:&quot;, entityId)   "},{"title":"InsertPoint​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#InsertPoint","content":"&lt;/&gt; LooseTightDoubleGrid:InsertPoint(position: Vector2 ) → EntityId Inserts a point entity into the grid. local entityId = grid:InsertPoint(Vector2.new(10, 10)) print(&quot;Inserted Point Entity ID:&quot;, entityId)   "},{"title":"UpdateRect​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#UpdateRect","content":"&lt;/&gt; LooseTightDoubleGrid:UpdateRect( entityId: EntityId, newPosition: Vector2 , newSize: Vector2 ) → () Updates the position and size of a rectangular entity. grid:UpdateRect(entityId, Vector2.new(12, 12), Vector2.new(5, 7)) print(&quot;Updated Rect Entity ID:&quot;, entityId)   "},{"title":"UpdateCircle​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#UpdateCircle","content":"&lt;/&gt; LooseTightDoubleGrid:UpdateCircle( entityId: EntityId, newPosition: Vector2 , newRadius: number ) → () Updates the position and radius of a circular entity. grid:UpdateCircle(entityId, Vector2.new(8, 8), 3) print(&quot;Updated Circle Entity ID:&quot;, entityId)   "},{"title":"UpdatePoint​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#UpdatePoint","content":"&lt;/&gt; LooseTightDoubleGrid:UpdatePoint( entityId: EntityId, newPosition: Vector2 ) → () Updates the position of a point entity. grid:UpdatePoint(entityId, Vector2.new(15, 15)) print(&quot;Updated Point Entity ID:&quot;, entityId)   "},{"title":"Remove​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#Remove","content":"&lt;/&gt; LooseTightDoubleGrid:Remove(entityId: EntityId) → boolean Removes an entity from the grid. Return true if the entity was found and removed. Return false if the entity was not found. local entityId = grid:InsertRect(Vector2.new(10, 10), Vector2.new(5, 5)) local didRemove = grid:Remove(entityId)   "},{"title":"Has​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#Has","content":"&lt;/&gt; LooseTightDoubleGrid:Has(entityId: EntityId) → boolean Checks if an entity exists in the grid. local exists = grid:Has(entityId) print(&quot;Entity exists:&quot;, exists)   "},{"title":"GetEntitySize​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntitySize","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntitySize(id: EntityId) → Vector2  Returns the size of an entity. Errors if no entity with the id is in the grid. local size = grid:GetEntitySize(entityId) print(&quot;Entity Size:&quot;, size)   "},{"title":"GetEntityPosition​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntityPosition","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntityPosition(id: EntityId) → Vector2  Returns the position of an entity. Errors if no entity with the id is in the grid.. local position = grid:GetEntityPosition(entityId) print   "},{"title":"GetEntityPositionAndSize​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntityPositionAndSize","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntityPositionAndSize(id: EntityId) → ( Vector2 , Vector2 ) Gets the position and size of an entity. Faster than calling GetEntityPosition and GetEntitySize separately. Errors if no entity with the id is in the grid. local position, size = grid:GetEntityPositionAndSize(entityId) print(&quot;Entity Position:&quot;, position, &quot;Size:&quot;, size)   "},{"title":"GetEntityShape​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#GetEntityShape","content":"&lt;/&gt; LooseTightDoubleGrid:GetEntityShape(id: EntityId) → ShapeType Returns the shape type of an entity. Errors if no entity with the id is in the grid. local shapeType = grid:GetEntityShape(entityId) print(&quot;Entity Shape Type:&quot;, shapeType)   "},{"title":"QueryRect​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#QueryRect","content":"&lt;/&gt; LooseTightDoubleGrid:QueryRect( pos: Vector2 , size: Vector2 , filterParams: FilterParams? ) → {EntityId} Queries entities within a rectangular region. local entityIds = grid:QueryRect(Vector2.new(10, 10), Vector2.new(6, 6)) print(&quot;Entities in Rect:&quot;, entityIds)   "},{"title":"QueryCircle​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#QueryCircle","content":"&lt;/&gt; LooseTightDoubleGrid:QueryCircle( pos: Vector2 , radius: number, filterParams: FilterParams? ) → {EntityId} Queries entities within a circular region. local entities = grid:QueryCircle(Vector2.new(15, 15), 5) print(&quot;Entities in Circle:&quot;, entities)   "},{"title":"QueryPoint​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#QueryPoint","content":"&lt;/&gt; LooseTightDoubleGrid:QueryPoint( pos: Vector2 , filterParams: FilterParams? ) → {EntityId} Queries entities at a specific point. local entitiesIds = grid:QueryPoint(Vector2.new(20, 20)) print(&quot;Entities at Point:&quot;, entitiesIds)   "},{"title":"QueryClosestToPoint​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#QueryClosestToPoint","content":"&lt;/&gt; LooseTightDoubleGrid:QueryClosestToPoint( point: Vector2 , filterParams: FilterParams? ) → EntityId? Queries the closest entity to a given point. Closeness is determined by the distance to the edge of the entity's shape. This method searches for the entity that is closest to the specified point in the grid. It considers all shapes (circles, rectangles, and points) and uses a two-tier comparison: Primary Metric: Distance to the edge of the shape. Secondary Metric: Distance to the center of the shape (used to break ties when the point is inside multiple shapes). Under this two-tier metric, the method will return an entity if the point is inside the entity, even if another entities's center is technically closer to the point. Point entities are treated as circles with a radius of 0. The method uses an expanding search algorithm, starting from the tight cell containing the point and gradually expanding outward until the closest entity is found. -- Insert some entities local rectId = grid:InsertRect(Vector2.new(10, 10), Vector2.new(5, 5)) local circleId = grid:InsertCircle(Vector2.new(15, 15), 3) local pointId = grid:InsertPoint(Vector2.new(20, 20)) -- Query the closest entity to a point local closestEntityId = grid:QueryClosestToPoint(Vector2.new(12, 12)) print(&quot;Closest Entity ID:&quot;, closestEntityId)   "},{"title":"Raycast​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#Raycast","content":"&lt;/&gt; LooseTightDoubleGrid:Raycast( origin: Vector2 , direction: Vector2 , filterParams: FilterParams? ) → { Normal: Vector2 , Position: Vector2 , Distance: number, EntityId: EntityId, }? Performs a raycast through the grid, checking for intersections with entities. The ray starts at origin and travels in the direction. The magnitude of the direction vector determines the length of the ray. Returns the closest intersection, including the hit position, normal, distance, and the intersected entity ID. If nothing was hit then it returns nil. local id1 = grid:InsertRect(Vector2.new(5, 0), Vector2.new(2, 2)) local id2 = grid:InsertCircle(Vector2.new(8, 0), 1) local hit = grid:Raycast(Vector2.new(0, 0), Vector2.new(10, 0), { FilterList = {id1}, -- ignore the rect FilterType = Enum.RaycastFilterType.Exclude, }) if hit then print(&quot;Hit entity:&quot;, hit.EntityId) end   "},{"title":"Draw​","type":1,"pageTitle":"LooseTightDoubleGrid","url":"/ModulesOnRails/api/LooseTightDoubleGrid#Draw","content":"debug &lt;/&gt; LooseTightDoubleGrid:Draw() → Instance  Renders the grid and its entities for debugging purposes. Subsequent calls will destroy the previous render model. local renderModel = grid:Draw() print(&quot;Render Model:&quot;, renderModel)  "},{"title":"Component","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? Extensions: {Extension}? Methods: {[string]: function}? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end In this forked version of component, extensions can also add methods to the component class and extend other extensions via giving an extension a Methods table. For example: local ExtendedComponentMethods = {} function ExtendedComponentMethods.DoSomething(component) print(&quot;Hello World!&quot;) end local MyComponentExtension = {} MyComponentExtension.Methods = ExtendedComponentMethods This will add a method called DoSomething to the component class. Be careful when using with ShouldExtend It is important to note that these methods are added to the Component Class and not the Component Instance. This means that these methods will be availible regardless of whether the extension passes its shouldExtend function or not. If your code is dependent on extension methods existing only when they pass their shouldExtend function, you may want to avoid using this feature. If you want to utilize other extensions within your extension or guarantee that the given extension is loaded onto the component before your extension, you can use the Extensions table. For example: local SomeOtherExtension = require(somewhere.SomeOtherExtension) local MyComponentExtension = {} MyComponentExtension.Extensions = {SomeOtherExtension} This will guarantee that SomeOtherExtension is added to the component and loaded before MyComponentExtension. info The ShouldExtend function of SomeOtherExtension will still be called independently of the ShouldExtend function of MyExtension. Under the hood this just adds the extension to the components original extension array.  "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#properties","content":" "},{"title":"Started​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#new","content":"Component &lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:Construct() self.MyData = &quot;Hello&quot; end function MyComponent:Start() local another = self:GetComponent(AnotherComponent) another:DoSomething() end function MyComponent:Stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:HeartbeatUpdate(dt) end function MyComponent:SteppedUpdate(dt) end function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"HeartbeatUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#HeartbeatUpdate","content":"Component Class &lt;/&gt; Component.HeartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:HeartbeatUpdate(dt) end   "},{"title":"SteppedUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#SteppedUpdate","content":"Component Class &lt;/&gt; Component.SteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:SteppedUpdate(dt) end   "},{"title":"RenderSteppedUpdate​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#RenderSteppedUpdate","content":"This item only works when running on the client. Client Component Class &lt;/&gt; Component.RenderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:RenderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetAll","content":"Component Class &lt;/&gt; Component:GetAll() → {Component} Gets a table array of all existing component objects. For example, if there was a component class linked to the &quot;MyComponent&quot; tag, and three Roblox instances in your game had that same tag, then calling GetAll would return the three component instances. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- ... local components = MyComponent:GetAll() for _,component in ipairs(components) do component:DoSomethingHere() end   "},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#FromInstance","content":"Component Class &lt;/&gt; Component:FromInstance(instance: Instance ) → Component? Gets an instance of a component class from the given Roblox instance. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = MyComponent:FromInstance(workspace.SomeInstance)   "},{"title":"WaitForInstance​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#WaitForInstance","content":"Component Class &lt;/&gt; Component:WaitForInstance( instance: Instance , timeout: number? ) → Promise&lt;ComponentInstance&gt; Resolves a promise once the component instance is present on a given Roblox instance. An optional timeout can be provided to reject the promise if it takes more than timeout seconds to resolve. If no timeout is supplied, timeout defaults to 60 seconds. local MyComponent = require(somewhere.MyComponent) MyComponent:WaitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance) -- Do something with the component class end)   "},{"title":"UpdateAncestors​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#UpdateAncestors","content":"Component Class &lt;/&gt; Component:UpdateAncestors(newAncestors: {Instance }) → () Allows for you to update the valid ancestors of a component class. This is useful if you want to give a valid ancestor that may not exist when the component is first created. local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, }) task.defer(function() local newAncestors = {workspace:WaitForChild(&quot;SomeFolder&quot;)} MyComponent:UpdateAncestors(newAncestors) end)   "},{"title":"Construct​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Construct","content":"Component Class &lt;/&gt; Component:Construct() → () Construct is called before the component is started, and should be used to construct the component instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"Start​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Start","content":"Component Class &lt;/&gt; Component:Start() → () Start is called when the component is started. At this point in time, it is safe to grab other components also bound to the same instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() -- e.g., grab another component: local another = self:GetComponent(AnotherComponent) end   "},{"title":"Stop​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#Stop","content":"Component Class &lt;/&gt; Component:Stop() → () Stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.Instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Stop() self.SomeStuff:Destroy() end   "},{"title":"GetComponent​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#GetComponent","content":"Component Instance &lt;/&gt; Component:GetComponent(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() local another = self:GetComponent(AnotherComponent) end   "},{"title":"ForEachSibling​","type":1,"pageTitle":"Component","url":"/ModulesOnRails/api/Component#ForEachSibling","content":"Component Instance &lt;/&gt; Component:ForEachSibling( componentClass: ComponentClass, fn: ( component: Component, jani: Janitor ) → () ) → Connection Ties a function to the lifecycle of the calling component and the equivalent component of the givencomponentClass. The function is run whenever a component of the given class is started. The given function passes the sibling component of the given class and a janitor to handle any connections you may make within it. The Janitor is cleaned up whenever either compenent is stopped. local AnotherComponent = require(somewhere.AnotherComponent) local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Start() self:ForEachSibling(AnotherComponent, function(sibling, jani) print(sibling.SomeProperty) jani:Add(function() print(&quot;Sibling component stopped&quot;) end) end) end  "},{"title":"TableManager","type":0,"sectionRef":"#","url":"/ModulesOnRails/api/TableManager","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#types","content":" "},{"title":"CanBeArray<T>​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#CanBeArray<T>","content":"&lt;/&gt; type CanBeArray&lt;T&gt; = T | {T} A type that could be an individual of the type or an array of the type.  "},{"title":"Path​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Path","content":"&lt;/&gt; type Path = string | {any} A path to a value in a table. Can be written as a string in dot format or an array of strings. :::Note The array format is faster to parse and should be used when possible. ::: local tbl = { MyPath = { To = { Value = 0; }; }; } local path1: Path = &quot;MyPath.To.Value&quot; -- Style 1 local path2: Path = {&quot;MyPath&quot;, &quot;To&quot;, &quot;Value&quot;} -- Style 2   "},{"title":"ValueListenerFn​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ValueListenerFn","content":"&lt;/&gt; type ValueListenerFn = ( newValue: any, oldValue: any?, changeMetadata: ChangeMetadata? ) → ()   "},{"title":"ListenerType​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ListenerType","content":"&lt;/&gt; type ListenerType = &quot;ValueChanged&quot; | &quot;ArraySet&quot; | &quot;ArrayInsert&quot; | &quot;ArrayRemove&quot; This information is mostly for internal use.  "},{"title":"DataChangeSource​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#DataChangeSource","content":"&lt;/&gt; type DataChangeSource = &quot;self&quot; | &quot;child&quot; | &quot;parent&quot; This information is mostly for internal use.  "},{"title":"ChangeMetadata​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ChangeMetadata","content":"&lt;/&gt; interface ChangeMetadata { ListenerType: ListenerType-- The listener type that was fired. SourceDirection: DataChangeSource-- The source direction of the change. SourcePath: {string}-- The origin path of the change. NewValue: any?-- [Only for value changes] The new value. OldValue: any?-- [Only for value changes] The old value. } Metadata about the change that fired a listener. Used to provide more context to listeners. Allows you to figure out where the change came from, if it wasnt a direct change. "},{"title":"Properties​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#properties","content":" "},{"title":"Enums​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Enums","content":"&lt;/&gt; TableManager.Enums: { ListenerType: ListenerTypeEnum, DataChangeSource: DataChangeSourceEnum } A collection of enums used by the TableManager. "},{"title":"Functions​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#new","content":"Constructor &lt;/&gt; TableManager.new(data: table?) → TableManager Creates a new TableManager. Takes a table to manage, if one is not given then it will construct an empty table. Modifying the given table Once you give a table to a TableManager, you should never modify it directly. Doing so can result in the TableManager being unable to properly track changes and potentially cause data desyncs. Key/Value Rules The given table's keys should follow these rules: No Mixed Tables (Tables containing keys of different datatypes) Avoid using tables as keys. Keys must not contain periods. Keys must not be empty strings. Tables/Arrays should be assigned to only one key. (No shared references as this can cause desyncs) Nested tables/arrays should not be given to other TableManager instances. (Can cause desyncs) info Only one TableManager should be created for a given table. Attempting to create a TableManager for a table that is already being managed will return the existing TableManager. Call metamethod You can call the TableManager class to create a new instance of it. TableManager() is equivalent to TableManager.new(). local manager = TableManager { Coins = 0; Title = &quot;Knight&quot;; }   "},{"title":"Destroy​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Destroy","content":"&lt;/&gt; TableManager:Destroy() → () Disconnects any listeners and removes the table from the managed tables.  "},{"title":"Get​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Get","content":"&lt;/&gt; TableManager:Get( path: Path, idx: (number | string)? ) → any Fetches the value at the given path. Accepts a string path or an array path. Accepts an optional secondary argument to fetch a value at an index in an array. Aliases: GetValue local manager = TableManager.new({ Currency = { Coins = 100; Gems = 10; }; }) -- The following are all equivalent acceptable methods of fetching the value. print(manager:Get(&quot;Currency.Coins&quot;)) -- 100 print(manager:Get({&quot;Currency&quot;, &quot;Coins&quot;})) -- 100 print(manager:Get().Currency.Coins) -- 100 Getting the Root Table Calling :Get() with no arguments, an empty string, or an empty table will return the root table.  "},{"title":"Set​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Set","content":"&lt;/&gt; TableManager:Set( path: Path, ...: any ) → () Sets the value at the given path to the given value. :Set acts as a combined function for :SetValue and :ArraySet. :Set(myPathToValue, newValue) :Set(myPathToArray, index, newValue) Overwriting the root table Overwriting the root table is not recommended, but is technically possible by giving an empty table or string as a Path. Doing so has not been tested in depth and may result in unintended behavior. Setting array values You cannot set values to nil in an array with this method due to the way it parses args. Use ArraySet instead if you need to set values to nil.  "},{"title":"Increment​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Increment","content":"&lt;/&gt; TableManager:Increment( path: Path, ...: any ) → number? Increments the value at the given path by the given amount. If the value is not a number, it will throw an error. :Increment acts as a combined function for :IncrementValue and :ArrayIncrement. :Increment(myPathToValue, amountToIncrementBy) :Increment(myPathToArray, index, amountToIncrementBy)   "},{"title":"Update​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Update","content":"&lt;/&gt; TableManager:Update( path: Path, ...: any ) → any? Mutates the value at the given path by calling the given function with the current value. :Update(myPathToValue, function(currentValue) return currentValue + 1 end) Aliases :Mutate is an alias for :Update. This alias is consistent with all other 'Update' methods.  "},{"title":"SetValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetValue","content":"&lt;/&gt; TableManager:SetValue( path: Path, value: any ) → boolean Sets the value at the given path to the given value. This will fire the ValueChanged signal if the value is different. Returns a boolean indicating whether or not the value was changed. local didChange = manager:SetValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"IncrementValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#IncrementValue","content":"&lt;/&gt; TableManager:IncrementValue( path: Path, amount: Numeric ) → number Increments the value at the given path by the given amount. If the value at the path or the given amount is not a number, it will throw an error. Returns the newly incremeneted value. local newValue = manager:IncrementValue(&quot;MyPath.To.Value&quot;, 100)   "},{"title":"UpdateValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#UpdateValue","content":"&lt;/&gt; TableManager:UpdateValue( path: Path, fn: (currentValue: any) → (any) ) → any Mutates the value at the given path by calling the given function with the current value. The function should return the new value. manager:SetValue(&quot;MyPath.To.Value&quot;, &quot;Hello World&quot;) local newValue = manager:UpdateValue(&quot;MyPath.To.Value&quot;, function(currentValue) return string.upper(currentValue) .. &quot;!&quot; end) print(newValue) -- HELLO WORLD! print(manager:GetValue(&quot;MyPath.To.Value&quot;)) -- HELLO WORLD!   "},{"title":"SetManyValues​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#SetManyValues","content":"&lt;/&gt; TableManager:SetManyValues( path: Path, valueDict: {[any]: any} ) → () Sets the values at the given path to the given values. This will fire the ValueChanged listener for each value that is different. caution Uses pairs to check through the given table and thus Does not support setting values to nil. local manager = TableManager.new({ Foo = { Bar = { Value1 = 0; Value2 = 0; Value3 = 0; }; }; }) manager:SetManyValues(&quot;Foo.Bar&quot;, { Value1 = 100; Value3 = 300; })   "},{"title":"ArrayUpdate​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayUpdate","content":"&lt;/&gt; TableManager:ArrayUpdate( path: Path,-- The path to the array to mutate. index: number | {number} | &quot;#&quot;,-- The index or indices to mutate. If &quot;#&quot; is given, it will mutate all indices. fn: (currentValue: any) → (any)-- The function to call with the current value. Should return the new value. ) → () Mutates an index or indices in the array at the given path by calling the given function with the current value. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayUpdate(&quot;MyArray&quot;, 3, function(currentValue) return currentValue * 2 }) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 6, 4, 5}   "},{"title":"ArrayIncrement​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayIncrement","content":"&lt;/&gt; TableManager:ArrayIncrement( path: Path,-- The path to the array to increment. index: number | {number},-- The index or indices to increment. amount: number?-- The amount to increment by. If not given, it will increment by 1. ) → () Increments the indices at the given path by the given amount. manager:SetValue(&quot;MyArray&quot;, {1, 2, 3, 4, 5}) manager:ArrayIncrement(&quot;MyArray&quot;, 3, 10) print(manager:GetValue(&quot;MyArray&quot;)) -- {1, 2, 13, 4, 5}   "},{"title":"ArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArraySet","content":"&lt;/&gt; TableManager:ArraySet( path: Path, index: (CanBeArray&lt;number&gt; | '#')?, value: any ) → () Sets the value at the given index in the array at the given path. The index can be a number or an array of numbers. If an array is given then the value will be set at each of those indices in the array.  "},{"title":"ArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayInsert","content":"&lt;/&gt; TableManager:ArrayInsert( path: Path, ...: any ) → () Inserts the given value into the array at the given path at the given index. If no index is given, it will insert at the end of the array. This follows the convention of table.insert where the index is given in the middle only if there are 3 args. x:ArrayInsert(&quot;MyArray&quot;, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, &quot;Hello&quot;) -- Inserts &quot;Hello&quot; at index 1 x:ArrayInsert(&quot;MyArray&quot;, 1) -- appends 1 to the end of the array x:ArrayInsert(&quot;MyArray&quot;, 1, 2) -- Inserts 2 at index 1   "},{"title":"ArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemove","content":"&lt;/&gt; TableManager:ArrayRemove( path: Path, index: number? ) → any Removes the value at the given index from the array at the given path. If no index is given, it will remove the last value in the array. Returns the value that was removed if one was.  "},{"title":"ArrayRemoveFirstValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ArrayRemoveFirstValue","content":"&lt;/&gt; TableManager:ArrayRemoveFirstValue( path: Path, value: any ) → number? Removes the first instance of the given value from the array at the given path. Returns a number indicating the index that it was was removed from if one was.  "},{"title":"ToFusionState​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#ToFusionState","content":"&lt;/&gt; TableManager:ToFusionState(path: Path) → FusionState&lt;any&gt; Returns a Fusion State object that is bound to the value at the given path. This method is memoized so calling it repeatedly with the same path will return the same State object and quickly. local path = &quot;MyPath.To.Value&quot; manager:SetValue(path, 100) local state = manager:ToFusionState(path) print(peek(state)) -- 100 manager:SetValue(path, 200) task.wait() -- If your signals are deffered then the state will update on the next frame print(peek(state)) -- 200 Deffered Signals The value of the Fusion State object is updated via the ValueChanged listener and thus may be deffered if your signals are deffered. Setting Although this currently returns a Fusion Value object, it is not recommended to set the value as this may be a Computed in the future. Setting the state will not actually change the value in the TableManager. Version This method uses Fusion 0.3.0 internally so it may not work with older versions.  "},{"title":"PromiseValue​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#PromiseValue","content":"&lt;/&gt; TableManager:PromiseValue( path: Path, condition: (value: any?) → (boolean) ) → Promise Creates a promise that resolves when the given condition is met. The condition is immediately and every time the value changes. If no condition is given then it will resolve with the current value unless it is nil, in which case it will resolve on the first change.  "},{"title":"Observe​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#Observe","content":"&lt;/&gt; TableManager:Observe( path: Path,-- The path to the value to observe. fn: ValueListenerFn,-- The function to call when the value changes. runOnNil: boolean?-- Whether or not to fire the function when the value is nil. ) → Connection-- A connection used to disconnect the listener. Observes a value at a path and calls the function immediately with the current value, as well as when it changes. Listening to nil values It will NOT fire if the new/starting value is nil, unless runOnNil is true. When it changes from nil, the oldValue will be the last known non nil value. The binding call of the function is an exception and will give nil as the oldValue. This is done so that Observe can be used to execute instructions when a value is percieved as 'ready'. local path = &quot;MyPath.To.Value&quot; local connection = manager:Observe(path, function(newValue) print(&quot;Value at&quot;, path, &quot;is&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"OnKeyChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyChange","content":"unreleased &lt;/&gt; TableManager:OnKeyChange( parentPath: Path?, fn: ( keyChanged: any, newValue: any, oldValue: any, changeMetadata: ChangeMetadata? ) → () ) → () Listens to a change at a specified path and calls the function when the value changes. keys with table values This method is not yet fully implemented and may not work as expected when listening to keys with table values or changing data from parent table. manager:Set(&quot;Stats&quot;, { Health = 100; Mana = 50; }) local connection = manager:OnKeyChange(&quot;Stats&quot;, function(key, newValue) print(`{key} changed to {newValue}`) end) manager:SetValue(&quot;Stats.Health&quot;, 200) -- Health changed to 200 manager:SetValue(&quot;Stats.Mana&quot;, 100) -- Mana changed to 100   "},{"title":"OnKeyAdd​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyAdd","content":"unreleased &lt;/&gt; TableManager:OnKeyAdd( parentPath: Path?, fn: ( newKey: any, newValue: any ) → () ) → Connection Listens to when a new key is added (Changed from nil) to a table at a specified path and calls the function.  "},{"title":"OnKeyRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnKeyRemove","content":"unreleased &lt;/&gt; TableManager:OnKeyRemove( parentPath: Path?, fn: ( removedKey: any, lastValue: any ) → () ) → Connection Listens to when a key is removed (Set to nil) from a table at a specified path and calls the function.  "},{"title":"OnValueChange​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnValueChange","content":"&lt;/&gt; TableManager:OnValueChange( path: Path, fn: ValueListenerFn ) → Connection Listens to a change at a specified path and calls the function when the value changes. This does NOT fire when the value is an array/dictionary and one of its children changes. local connection = manager:OnValueChange(&quot;MyPath.To.Value&quot;, function(newValue, oldValue) print(&quot;Value changed from&quot;, oldValue, &quot;to&quot;, newValue) end) connection() -- Disconnects the listener   "},{"title":"OnArraySet​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArraySet","content":"&lt;/&gt; TableManager:OnArraySet( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when an index is set in an array at a specified path and calls the function. The function receives the index and the new value. caution The array listeners do not fire from changes to parent or child values.  "},{"title":"OnArrayInsert​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArrayInsert","content":"&lt;/&gt; TableManager:OnArrayInsert( path: Path, fn: ( changedIndex: number, newValue: any ) → () ) → Connection Listens to when a value is inserted into an array at a specified path and calls the function when the value changes.  "},{"title":"OnArrayRemove​","type":1,"pageTitle":"TableManager","url":"/ModulesOnRails/api/TableManager#OnArrayRemove","content":"&lt;/&gt; TableManager:OnArrayRemove( path: Path, fn: ( oldIndex: number, oldValue: any ) → () ) → Connection Listens to when a value is removed from an array at a specified path and calls the function. "}]